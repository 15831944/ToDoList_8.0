	TITLE	D:\_CODE\Shared\Preferences.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_1CC@LAMD@?$AAM?$AAa?$AAg?$AAe?$AAl?$AAl?$AAa?$AAn?$AA?5?$AAM?$AAS?$AAW?$AAH?$AAE?$AAE?$AAL?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1O@JDNM@?$AAM?$AAo?$AAu?$AAs?$AAe?$AAZ?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@JHCA@?$AAM?$AAS?$AAW?$AAH?$AAE?$AAE?$AAL?$AA_?$AAR?$AAO?$AAL?$AAL?$AAM?$AAS?$AAG?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@MMPP@?$AAM?$AAS?$AAH?$AA_?$AAW?$AAH?$AAE?$AAE?$AAL?$AAS?$AAU?$AAP?$AAP?$AAO?$AAR?$AAT?$AA_?$AAM?$AAS?$AAG@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@GMOB@?$AAM?$AAS?$AAH?$AA_?$AAS?$AAC?$AAR?$AAO?$AAL?$AAL?$AA_?$AAL?$AAI?$AAN?$AAE?$AAS?$AA_?$AAM?$AAS?$AAG@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@DBHF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BA@GAJA@?$AA?$CF?$AAs?$AA?$DN?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@EHKI@?$AA?$CF?$AAs?$AA?$DN?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_11A@?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13OGPI@?$AA?$CC?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MDCF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KIFI@with?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LOPF@?5elements?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DANH@?6?7?$FL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MNLE@?$FN?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?data@CPlex@@QAEPAXXZ
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CTypedPtrList@VCObList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CTypedPtrList@VCObList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypedPtrList@VCObList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CTypedPtrList@VCPtrList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CTypedPtrList@VCPtrList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypedPtrList@VCPtrList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0INIENTRY@@QAE@PBG0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@INIENTRY@@QBE?AVCString@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Parse@INIENTRY@@QAEHABVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8INIENTRY@@QBEHABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0INISECTION@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E278
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E279
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E281
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E282
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E284
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E285
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E286
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E287
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPreferences@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPreferences@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CStdioFileEx@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1INIENTRY@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPreferences@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GINISECTION@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1INISECTION@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CPreferences@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ToString@CPreferences@@KA?AVCString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ToString@CPreferences@@KA?AVCString@@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProfileIntW@CPreferences@@UBEIPBG0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProfileInt@CPreferences@@UAEHPBG0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProfileStringW@CPreferences@@UAEHPBG00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteIniString@CPreferences@@KAHPBG00H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProfileDouble@CPreferences@@UBENPBG0N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetProfileArray@CPreferences@@QBEHPBGAAVCStringArray@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteProfileArray@CPreferences@@QAEXPBGABVCStringArray@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4INIENTRY@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindSection@CPreferences@@KAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSection@CPreferences@@QAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteEntry@CPreferences@@QAEHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasSection@CPreferences@@QBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSectionNames@CPreferences@@QAEHAAVCStringArray@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyFromFile@CPreferences@@SA?AVCString@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAUIUnknown@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@ABU_GUID@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInterfacePtr@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CTypedPtrList@VCObList@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CTypedPtrList@VCPtrList@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$_CTypedPtrList@VCObList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$_CTypedPtrList@VCPtrList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateObject@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEJABU_GUID@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateObject@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEJPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIID@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@SAABU_GUID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareElements@@YGHPBVCString@@PBQBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAPAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAUINIENTRY@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAUINIENTRY@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAPAUINISECTION@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GINIENTRY@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCNoTrackObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CNoTrackObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CArray@PAUINISECTION@@PAU1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$_CTypedPtrList@VCPtrList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$_CTypedPtrList@VCObList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IPreferences@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPreferences@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrList@VCPtrList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrList@VCObList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A ; CPreferences::s_aIni
PUBLIC	?s_bDirty@CPreferences@@1HA			; CPreferences::s_bDirty
PUBLIC	?s_bIni@CPreferences@@1HA			; CPreferences::s_bIni
PUBLIC	?s_nRef@CPreferences@@1HA			; CPreferences::s_nRef
PUBLIC	?s_cs@CPreferences@@1VCCriticalSection@@A	; CPreferences::s_cs
_BSS	SEGMENT
?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A DB 014H DUP (?) ; CPreferences::s_aIni
?s_bDirty@CPreferences@@1HA DD 01H DUP (?)		; CPreferences::s_bDirty
?s_bIni@CPreferences@@1HA DD 01H DUP (?)		; CPreferences::s_bIni
?s_nRef@CPreferences@@1HA DD 01H DUP (?)		; CPreferences::s_nRef
?s_cs@CPreferences@@1VCCriticalSection@@A DB 024H DUP (?) ; CPreferences::s_cs
_BSS	ENDS
_DATA	SEGMENT
__szAfxTempl DB	'afxtempl.h', 00H
	ORG $+1
_THIS_FILE DB	'D:\_CODE\Shared\Preferences.cpp', 00H
_ENDL	DD	FLAT:$SG75279
_DATA	ENDS
CRT$XCU	SEGMENT
_$S283	DD	FLAT:_$E282
_$S288	DD	FLAT:_$E287
CRT$XCU	ENDS
_DATA	SEGMENT
$SG75279 DB	0dH, 00H, 0aH, 00H, 00H, 00H
_DATA	ENDS
EXTRN	__chkesp:NEAR
;	COMDAT _$E282
_TEXT	SEGMENT
_$E282	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E278
	call	_$E281
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E282	ENDP
_TEXT	ENDS
PUBLIC	??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ	; CArray<INISECTION *,INISECTION *>::CArray<INISECTION *,INISECTION *>
;	COMDAT _$E278
_TEXT	SEGMENT
_$E278	PROC NEAR					; COMDAT

; 26   : CIniSectionArray	CPreferences::s_aIni;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ ; CArray<INISECTION *,INISECTION *>::CArray<INISECTION *,INISECTION *>
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E278	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E281
_TEXT	SEGMENT
_$E281	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:_$E279
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E281	ENDP
_TEXT	ENDS
PUBLIC	??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ	; CArray<INISECTION *,INISECTION *>::~CArray<INISECTION *,INISECTION *>
_BSS	SEGMENT
_$S280	DB	01H DUP (?)
_BSS	ENDS
;	COMDAT _$E279
_TEXT	SEGMENT
_$E279	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	xor	eax, eax
	mov	al, BYTE PTR _$S280
	and	eax, 1
	test	eax, eax
	jne	SHORT $L75285
	mov	cl, BYTE PTR _$S280
	or	cl, 1
	mov	BYTE PTR _$S280, cl
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ ; CArray<INISECTION *,INISECTION *>::~CArray<INISECTION *,INISECTION *>
$L75285:
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E279	ENDP
_TEXT	ENDS
;	COMDAT _$E287
_TEXT	SEGMENT
_$E287	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E284
	call	_$E286
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E287	ENDP
_TEXT	ENDS
EXTRN	??0CCriticalSection@@QAE@XZ:NEAR		; CCriticalSection::CCriticalSection
;	COMDAT _$E284
_TEXT	SEGMENT
_$E284	PROC NEAR					; COMDAT

; 30   : CCriticalSection	CPreferences::s_cs;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A
	call	??0CCriticalSection@@QAE@XZ		; CCriticalSection::CCriticalSection
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E284	ENDP
_TEXT	ENDS
;	COMDAT _$E286
_TEXT	SEGMENT
_$E286	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:_$E285
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E286	ENDP
_TEXT	ENDS
EXTRN	??1CCriticalSection@@UAE@XZ:NEAR		; CCriticalSection::~CCriticalSection
;	COMDAT _$E285
_TEXT	SEGMENT
_$E285	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	xor	eax, eax
	mov	al, BYTE PTR _$S280
	and	eax, 2
	test	eax, eax
	jne	SHORT $L75300
	mov	cl, BYTE PTR _$S280
	or	cl, 2
	mov	BYTE PTR _$S280, cl
	mov	ecx, OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A
	call	??1CCriticalSection@@UAE@XZ		; CCriticalSection::~CCriticalSection
$L75300:
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E285	ENDP
_TEXT	ENDS
PUBLIC	??0INIENTRY@@QAE@PBG0H@Z			; INIENTRY::INIENTRY
PUBLIC	?Parse@INIENTRY@@QAEHABVCString@@@Z		; INIENTRY::Parse
PUBLIC	??1INIENTRY@@QAE@XZ				; INIENTRY::~INIENTRY
PUBLIC	??0INISECTION@@QAE@PBG@Z			; INISECTION::INISECTION
PUBLIC	??0IPreferences@@QAE@XZ				; IPreferences::IPreferences
PUBLIC	??0CPreferences@@QAE@XZ				; CPreferences::CPreferences
PUBLIC	?GetProfileIntW@CPreferences@@UBEIPBG0H@Z	; CPreferences::GetProfileIntW
PUBLIC	?WriteProfileInt@CPreferences@@UAEHPBG0H@Z	; CPreferences::WriteProfileInt
PUBLIC	?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z ; CPreferences::GetProfileStringW
PUBLIC	?WriteProfileStringW@CPreferences@@UAEHPBG00@Z	; CPreferences::WriteProfileStringW
PUBLIC	?GetProfileDouble@CPreferences@@UBENPBG0N@Z	; CPreferences::GetProfileDouble
PUBLIC	?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z	; CPreferences::WriteProfileDouble
PUBLIC	?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z ; CArray<INISECTION *,INISECTION *>::Add
PUBLIC	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z ; CPreferences::SetEntryValue
PUBLIC	??_7CPreferences@@6B@				; CPreferences::`vftable'
PUBLIC	??1CStdioFileEx@@UAE@XZ				; CStdioFileEx::~CStdioFileEx
EXTRN	?FileExists@FileMisc@@YAHPBG@Z:NEAR		; FileMisc::FileExists
EXTRN	?ReplaceExtension@FileMisc@@YAAAVCString@@AAV2@PBG@Z:NEAR ; FileMisc::ReplaceExtension
EXTRN	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z:NEAR	; CSingleLock::CSingleLock
EXTRN	??1CSingleLock@@QAE@XZ:NEAR			; CSingleLock::~CSingleLock
EXTRN	?AfxGetApp@@YGPAVCWinApp@@XZ:NEAR		; AfxGetApp
EXTRN	?AfxAssertFailedLine@@YGHPBDH@Z:NEAR		; AfxAssertFailedLine
EXTRN	??0CString@@QAE@XZ:NEAR				; CString::CString
EXTRN	??0CString@@QAE@ABV0@@Z:NEAR			; CString::CString
EXTRN	??0CString@@QAE@PBG@Z:NEAR			; CString::CString
EXTRN	?GetLength@CString@@QBEHXZ:NEAR			; CString::GetLength
EXTRN	?IsEmpty@CString@@QBEHXZ:NEAR			; CString::IsEmpty
EXTRN	??ACString@@QBEGH@Z:NEAR			; CString::operator[]
EXTRN	??BCString@@QBEPBGXZ:NEAR			; CString::operator unsigned short const *
EXTRN	__imp__DeleteFileW@4:NEAR
EXTRN	__except_list:DWORD
EXTRN	__chkstk:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?Mid@CString@@QBE?AV1@HH@Z:NEAR			; CString::Mid
EXTRN	??2@YAPAXIPBDH@Z:NEAR				; operator new
EXTRN	??3@YAXPAXPBDH@Z:NEAR				; operator delete
EXTRN	__imp__CopyFileW@12:NEAR
EXTRN	??0CStdioFileEx@@QAE@XZ:NEAR			; CStdioFileEx::CStdioFileEx
EXTRN	?Open@CStdioFileEx@@UAEHPBGIW4SFE_SAVEAS@@PAVCFileException@@@Z:NEAR ; CStdioFileEx::Open
EXTRN	?ReadString@CStdioFileEx@@UAEHAAVCString@@@Z:NEAR ; CStdioFileEx::ReadString
EXTRN	??1CString@@QAE@XZ:NEAR				; CString::~CString
;	COMDAT ??_7CPreferences@@6B@
; File D:\_CODE\Shared\Preferences.cpp
CONST	SEGMENT
??_7CPreferences@@6B@ DD FLAT:?GetProfileIntW@CPreferences@@UBEIPBG0H@Z ; CPreferences::`vftable'
	DD	FLAT:?WriteProfileInt@CPreferences@@UAEHPBG0H@Z
	DD	FLAT:?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z
	DD	FLAT:?WriteProfileStringW@CPreferences@@UAEHPBG00@Z
	DD	FLAT:?GetProfileDouble@CPreferences@@UBENPBG0N@Z
	DD	FLAT:?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z
CONST	ENDS
;	COMDAT data
data	SEGMENT
$SG75314 DB	'b', 00H, 'a', 00H, 'k', 00H, '.', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76606	DD	019930520H
	DD	08H
	DD	FLAT:$T76610
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76610	DD	0ffffffffH
	DD	FLAT:$L76595
	DD	00H
	DD	FLAT:$L76596
	DD	01H
	DD	FLAT:$L76597
	DD	02H
	DD	FLAT:$L76598
	DD	03H
	DD	FLAT:$L76599
	DD	04H
	DD	FLAT:$L76600
	DD	05H
	DD	FLAT:$L76601
	DD	04H
	DD	FLAT:$L76602
xdata$x	ENDS
;	COMDAT ??0CPreferences@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12400
_lock$ = -24
_sIniPath$75312 = -28
_sBackupPath$75313 = -32
_file$75316 = -12364
_sLine$75318 = -12372
_pCurSection$75319 = -12368
_sSection$75326 = -12376
_ie$75340 = -12388
$T76591 = -12392
$T76592 = -12396
__$EHRec$ = -12
??0CPreferences@@QAE@XZ PROC NEAR			; CPreferences::CPreferences, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76607
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	eax, 12392				; 00003068H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12404]
	mov	ecx, 3098				; 00000c1aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IPreferences@@QAE@XZ			; IPreferences::IPreferences
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPreferences@@6B@ ; CPreferences::`vftable'

; 38   : 	// prevent anyone else changing the shared resources
; 39   : 	// for the duration of this function
; 40   : 	CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 41   : 			
; 42   : 	// if no other object is active we need to do the setup
; 43   : 	if (s_nRef == 0)

	cmp	DWORD PTR ?s_nRef@CPreferences@@1HA, 0	; CPreferences::s_nRef
	jne	$L75311

; 45   : 		// figure out whether we're using an ini file or the registry
; 46   : 		s_bIni = (AfxGetApp()->m_pszRegistryKey == NULL);

	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	xor	ecx, ecx
	cmp	DWORD PTR [eax+132], 0
	sete	cl
	mov	DWORD PTR ?s_bIni@CPreferences@@1HA, ecx ; CPreferences::s_bIni

; 47   : 		
; 48   : 		if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75311

; 50   : 			// check for existing backup file first
; 51   : 			CString sIniPath(AfxGetApp()->m_pszProfileName);

	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	edx, DWORD PTR [eax+152]
	push	edx
	lea	ecx, DWORD PTR _sIniPath$75312[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 52   : 			CString sBackupPath(sIniPath);

	lea	eax, DWORD PTR _sIniPath$75312[ebp]
	push	eax
	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 53   : 			
; 54   : 			FileMisc::ReplaceExtension(sBackupPath, _T("bak.ini"));

	push	OFFSET FLAT:$SG75314
	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	push	ecx
	call	?ReplaceExtension@FileMisc@@YAAAVCString@@AAV2@PBG@Z ; FileMisc::ReplaceExtension
	add	esp, 8

; 55   : 			
; 56   : 			if (FileMisc::FileExists(sBackupPath))

	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?FileExists@FileMisc@@YAHPBG@Z		; FileMisc::FileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $L75315

; 57   : 				::CopyFile(sBackupPath, sIniPath, FALSE);			

	mov	esi, esp
	push	0
	lea	ecx, DWORD PTR _sIniPath$75312[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	DWORD PTR __imp__CopyFileW@12
	cmp	esi, esp
	call	__chkesp
$L75315:

; 58   : 			
; 59   : 			// read the ini file
; 60   : 			CStdioFileEx file;

	lea	ecx, DWORD PTR _file$75316[ebp]
	call	??0CStdioFileEx@@QAE@XZ			; CStdioFileEx::CStdioFileEx
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 61   : 			
; 62   : 			if (file.Open(sIniPath, CFile::modeRead))

	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _sIniPath$75312[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _file$75316[ebp]
	call	?Open@CStdioFileEx@@UAEHPBGIW4SFE_SAVEAS@@PAVCFileException@@@Z ; CStdioFileEx::Open
	test	eax, eax
	je	$L75317

; 64   : 				CString sLine;

	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 65   : 				INISECTION* pCurSection = NULL;

	mov	DWORD PTR _pCurSection$75319[ebp], 0
$L75321:

; 66   : 				
; 67   : 				while (file.ReadString(sLine))

	lea	edx, DWORD PTR _sLine$75318[ebp]
	push	edx
	lea	ecx, DWORD PTR _file$75316[ebp]
	call	?ReadString@CStdioFileEx@@UAEHAAVCString@@@Z ; CStdioFileEx::ReadString
	test	eax, eax
	je	$L75322

; 69   : 					if (sLine.IsEmpty())

	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	je	SHORT $L75323

; 70   : 						continue;

	jmp	SHORT $L75321
$L75323:

; 71   : 					
; 72   : 					// is it a section ?
; 73   : 					else if (sLine[0] == '[')

	push	0
	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	??ACString@@QBEGH@Z			; CString::operator[]
	and	eax, 65535				; 0000ffffH
	cmp	eax, 91					; 0000005bH
	jne	$L75325

; 75   : 						CString sSection = sLine.Mid(1, sLine.GetLength() - 2);

	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	sub	eax, 2
	push	eax
	push	1
	lea	eax, DWORD PTR _sSection$75326[ebp]
	push	eax
	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	?Mid@CString@@QBE?AV1@HH@Z		; CString::Mid
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 76   : 
; 77   : 						// assume (for speed) that the section is already unique
; 78   : 						pCurSection = new INISECTION(sSection);

	push	78					; 0000004eH
	push	OFFSET FLAT:_THIS_FILE
	push	32					; 00000020H
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T76592[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T76592[ebp], 0
	je	SHORT $L76593
	lea	ecx, DWORD PTR _sSection$75326[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR $T76592[ebp]
	call	??0INISECTION@@QAE@PBG@Z		; INISECTION::INISECTION
	mov	DWORD PTR -12404+[ebp], eax
	jmp	SHORT $L76594
$L76593:
	mov	DWORD PTR -12404+[ebp], 0
$L76594:
	mov	ecx, DWORD PTR -12404+[ebp]
	mov	DWORD PTR $T76591[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T76591[ebp]
	mov	DWORD PTR _pCurSection$75319[ebp], edx

; 79   : 						s_aIni.Add(pCurSection);

	mov	eax, DWORD PTR _pCurSection$75319[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z ; CArray<INISECTION *,INISECTION *>::Add
$L75334:

; 80   : 
; 81   : 						ASSERT (pCurSection != NULL);

	cmp	DWORD PTR _pCurSection$75319[ebp], 0
	jne	SHORT $L75337
	push	81					; 00000051H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75337
	int	3
$L75337:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75334

; 82   : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _sSection$75326[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 83   : 					// else an entry
; 84   : 					else if (pCurSection)

	jmp	SHORT $L75339
$L75325:
	cmp	DWORD PTR _pCurSection$75319[ebp], 0
	je	SHORT $L75339

; 86   : 						INIENTRY ie;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _ie$75340[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 87   : 
; 88   : 						if (ie.Parse(sLine))

	lea	edx, DWORD PTR _sLine$75318[ebp]
	push	edx
	lea	ecx, DWORD PTR _ie$75340[ebp]
	call	?Parse@INIENTRY@@QAEHABVCString@@@Z	; INIENTRY::Parse
	test	eax, eax
	je	SHORT $L75341

; 89   : 							SetEntryValue(*pCurSection, ie);

	lea	eax, DWORD PTR _ie$75340[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCurSection$75319[ebp]
	push	ecx
	call	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z ; CPreferences::SetEntryValue
	add	esp, 8
$L75341:

; 90   : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _ie$75340[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
$L75339:

; 91   : 				}

	jmp	$L75321
$L75322:

; 92   : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75317:

; 93   : 
; 94   : 			s_bDirty = FALSE;

	mov	DWORD PTR ?s_bDirty@CPreferences@@1HA, 0 ; CPreferences::s_bDirty

; 95   : 
; 96   : 			// delete backup
; 97   : 			::DeleteFile(sBackupPath);

	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4
	cmp	esi, esp
	call	__chkesp

; 98   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _file$75316[ebp]
	call	??1CStdioFileEx@@UAE@XZ			; CStdioFileEx::~CStdioFileEx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sIniPath$75312[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75311:

; 100  : 				
; 101  : 	s_nRef++; // increment reference count

	mov	edx, DWORD PTR ?s_nRef@CPreferences@@1HA ; CPreferences::s_nRef
	add	edx, 1
	mov	DWORD PTR ?s_nRef@CPreferences@@1HA, edx ; CPreferences::s_nRef

; 102  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12404				; 00003074H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76595:
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76596:
	lea	ecx, DWORD PTR _sIniPath$75312[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76597:
	lea	ecx, DWORD PTR _sBackupPath$75313[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76598:
	lea	ecx, DWORD PTR _file$75316[ebp]
	call	??1CStdioFileEx@@UAE@XZ			; CStdioFileEx::~CStdioFileEx
	ret	0
$L76599:
	lea	ecx, DWORD PTR _sLine$75318[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76600:
	lea	ecx, DWORD PTR _sSection$75326[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76601:
	push	78					; 0000004eH
	push	OFFSET FLAT:_THIS_FILE
	mov	eax, DWORD PTR $T76592[ebp]
	push	eax
	call	??3@YAXPAXPBDH@Z			; operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L76602:
	lea	ecx, DWORD PTR _ie$75340[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L76607:
	mov	eax, OFFSET FLAT:$T76606
	jmp	___CxxFrameHandler
text$x	ENDS
??0CPreferences@@QAE@XZ ENDP				; CPreferences::CPreferences
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.h
xdata$x	SEGMENT
$T76620	DD	019930520H
	DD	01H
	DD	FLAT:$T76622
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76622	DD	0ffffffffH
	DD	FLAT:$L76617
xdata$x	ENDS
;	COMDAT ??0INIENTRY@@QAE@PBG0H@Z
_TEXT	SEGMENT
_szName$ = 8
_szValue$ = 12
_bQuote$ = 16
_this$ = -16
__$EHRec$ = -12
??0INIENTRY@@QAE@PBG0H@Z PROC NEAR			; INIENTRY::INIENTRY, COMDAT

; 21   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76621
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bQuote$[ebp]
	mov	DWORD PTR [edx+8], eax

; 22   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76617:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76621:
	mov	eax, OFFSET FLAT:$T76620
	jmp	___CxxFrameHandler
text$x	ENDS
??0INIENTRY@@QAE@PBG0H@Z ENDP				; INIENTRY::INIENTRY
PUBLIC	??_C@_11A@?$AA?$AA@				; `string'
PUBLIC	??_C@_13OGPI@?$AA?$CC?$AA?$AA@			; `string'
EXTRN	??4CString@@QAEABV0@ABV0@@Z:NEAR		; CString::operator=
EXTRN	?Mid@CString@@QBE?AV1@H@Z:NEAR			; CString::Mid
EXTRN	?Left@CString@@QBE?AV1@H@Z:NEAR			; CString::Left
EXTRN	?TrimRight@CString@@QAEXXZ:NEAR			; CString::TrimRight
EXTRN	?TrimLeft@CString@@QAEXXZ:NEAR			; CString::TrimLeft
EXTRN	?Replace@CString@@QAEHPBG0@Z:NEAR		; CString::Replace
EXTRN	?Find@CString@@QBEHG@Z:NEAR			; CString::Find
;	COMDAT ??_C@_11A@?$AA?$AA@
; File D:\_CODE\Shared\Preferences.h
_BSS	SEGMENT
??_C@_11A@?$AA?$AA@ DW 01H DUP (?)			; `string'
_BSS	ENDS
;	COMDAT ??_C@_13OGPI@?$AA?$CC?$AA?$AA@
_DATA	SEGMENT
??_C@_13OGPI@?$AA?$CC?$AA?$AA@ DB '"', 00H, 00H, 00H	; `string'
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76632	DD	019930520H
	DD	02H
	DD	FLAT:$T76634
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76634	DD	0ffffffffH
	DD	FLAT:$L76629
	DD	0ffffffffH
	DD	FLAT:$L76630
xdata$x	ENDS
;	COMDAT ?Parse@INIENTRY@@QAEHABVCString@@@Z
_TEXT	SEGMENT
_sEntry$ = 8
_this$ = -28
_nEquals$ = -16
$T76627 = -20
$T76628 = -24
__$EHRec$ = -12
?Parse@INIENTRY@@QAEHABVCString@@@Z PROC NEAR		; INIENTRY::Parse, COMDAT

; 37   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76633
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		int nEquals = sEntry.Find('=');

	push	61					; 0000003dH
	mov	ecx, DWORD PTR _sEntry$[ebp]
	call	?Find@CString@@QBEHG@Z			; CString::Find
	mov	DWORD PTR _nEquals$[ebp], eax

; 39   : 		
; 40   : 		if (nEquals != -1)

	cmp	DWORD PTR _nEquals$[ebp], -1
	je	$L74028

; 42   : 			sName = sEntry.Left(nEquals);

	mov	eax, DWORD PTR _nEquals$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76627[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sEntry$[ebp]
	call	?Left@CString@@QBE?AV1@H@Z		; CString::Left
	mov	DWORD PTR -32+[ebp], eax
	mov	edx, DWORD PTR -32+[ebp]
	mov	DWORD PTR -36+[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR -36+[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76627[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 43   : 			sName.TrimRight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrimRight@CString@@QAEXXZ		; CString::TrimRight

; 44   : 			
; 45   : 			sValue = sEntry.Mid(nEquals + 1);

	mov	ecx, DWORD PTR _nEquals$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR $T76628[ebp]
	push	edx
	mov	ecx, DWORD PTR _sEntry$[ebp]
	call	?Mid@CString@@QBE?AV1@H@Z		; CString::Mid
	mov	DWORD PTR -40+[ebp], eax
	mov	eax, DWORD PTR -40+[ebp]
	mov	DWORD PTR -44+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -44+[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76628[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 46   : 			sValue.TrimLeft();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?TrimLeft@CString@@QAEXXZ		; CString::TrimLeft

; 47   : 			
; 48   : 			// remove quotes
; 49   : 			bQuoted = sValue.Replace(_T("\""), _T(""));

	push	OFFSET FLAT:??_C@_11A@?$AA?$AA@		; `string'
	push	OFFSET FLAT:??_C@_13OGPI@?$AA?$CC?$AA?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Replace@CString@@QAEHPBG0@Z		; CString::Replace
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 50   : 
; 51   : 			return !sName.IsEmpty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	neg	eax
	sbb	eax, eax
	inc	eax
	jmp	SHORT $L74026
$L74028:

; 53   : 
; 54   : 		return FALSE;

	xor	eax, eax
$L74026:

; 55   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76629:
	lea	ecx, DWORD PTR $T76627[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76630:
	lea	ecx, DWORD PTR $T76628[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76633:
	mov	eax, OFFSET FLAT:$T76632
	jmp	___CxxFrameHandler
text$x	ENDS
?Parse@INIENTRY@@QAEHABVCString@@@Z ENDP		; INIENTRY::Parse
PUBLIC	??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
PUBLIC	?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::InitHashTable
PUBLIC	??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ	; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.h
xdata$x	SEGMENT
$T76643	DD	019930520H
	DD	02H
	DD	FLAT:$T76645
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76645	DD	0ffffffffH
	DD	FLAT:$L76640
	DD	00H
	DD	FLAT:$L76641
xdata$x	ENDS
;	COMDAT ??0INISECTION@@QAE@PBG@Z
_TEXT	SEGMENT
_szName$ = 8
_this$ = -16
__$EHRec$ = -12
??0INISECTION@@QAE@PBG@Z PROC NEAR			; INISECTION::INISECTION, COMDAT

; 74   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76644
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 75   : 		aEntries.InitHashTable(200);

	push	1
	push	200					; 000000c8H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::InitHashTable

; 76   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76640:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76641:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
	ret	0
$L76644:
	mov	eax, OFFSET FLAT:$T76643
	jmp	___CxxFrameHandler
text$x	ENDS
??0INISECTION@@QAE@PBG@Z ENDP				; INISECTION::INISECTION
PUBLIC	??_7IPreferences@@6B@				; IPreferences::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IPreferences@@6B@
CONST	SEGMENT
??_7IPreferences@@6B@ DD FLAT:__purecall		; IPreferences::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IPreferences@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPreferences@@QAE@XZ PROC NEAR			; IPreferences::IPreferences, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IPreferences@@6B@ ; IPreferences::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0IPreferences@@QAE@XZ ENDP				; IPreferences::IPreferences
_TEXT	ENDS
EXTRN	??1CStdioFile@@UAE@XZ:NEAR			; CStdioFile::~CStdioFile
;	COMDAT ??1CStdioFileEx@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CStdioFileEx@@UAE@XZ PROC NEAR			; CStdioFileEx::~CStdioFileEx, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CStdioFile@@UAE@XZ			; CStdioFile::~CStdioFile
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CStdioFileEx@@UAE@XZ ENDP				; CStdioFileEx::~CStdioFileEx
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76658	DD	019930520H
	DD	01H
	DD	FLAT:$T76660
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76660	DD	0ffffffffH
	DD	FLAT:$L76655
xdata$x	ENDS
;	COMDAT ??1INIENTRY@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1INIENTRY@@QAE@XZ PROC NEAR				; INIENTRY::~INIENTRY, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76659
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76655:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76659:
	mov	eax, OFFSET FLAT:$T76658
	jmp	___CxxFrameHandler
text$x	ENDS
??1INIENTRY@@QAE@XZ ENDP				; INIENTRY::~INIENTRY
PUBLIC	??_GINISECTION@@QAEPAXI@Z			; INISECTION::`scalar deleting destructor'
PUBLIC	??1CPreferences@@QAE@XZ				; CPreferences::~CPreferences
PUBLIC	?Save@CPreferences@@SAHXZ			; CPreferences::Save
PUBLIC	?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ	; CArray<INISECTION *,INISECTION *>::GetSize
PUBLIC	?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ ; CArray<INISECTION *,INISECTION *>::RemoveAll
PUBLIC	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76671	DD	019930520H
	DD	01H
	DD	FLAT:$T76673
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76673	DD	0ffffffffH
	DD	FLAT:$L76669
xdata$x	ENDS
;	COMDAT ??1CPreferences@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40
_lock$ = -24
_nSection$75353 = -28
$T76665 = -32
$T76666 = -36
__$EHRec$ = -12
??1CPreferences@@QAE@XZ PROC NEAR			; CPreferences::~CPreferences, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76672
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPreferences@@6B@ ; CPreferences::`vftable'

; 106  : 	// prevent anyone else changing the shared resources
; 107  : 	// for the duration of this function
; 108  : 	CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 109  : 			
; 110  : 	s_nRef--; // decrement reference count

	mov	ecx, DWORD PTR ?s_nRef@CPreferences@@1HA ; CPreferences::s_nRef
	sub	ecx, 1
	mov	DWORD PTR ?s_nRef@CPreferences@@1HA, ecx ; CPreferences::s_nRef

; 111  : 	
; 112  : 	// save ini?
; 113  : 	if (s_nRef == 0 && s_bIni)

	cmp	DWORD PTR ?s_nRef@CPreferences@@1HA, 0	; CPreferences::s_nRef
	jne	SHORT $L75352
	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75352

; 115  : 		Save();

	call	?Save@CPreferences@@SAHXZ		; CPreferences::Save

; 116  : 
; 117  : 		// cleanup
; 118  : 		int nSection = s_aIni.GetSize();

	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ ; CArray<INISECTION *,INISECTION *>::GetSize
	mov	DWORD PTR _nSection$75353[ebp], eax
$L75355:

; 119  : 		
; 120  : 		while (nSection--)

	mov	edx, DWORD PTR _nSection$75353[ebp]
	mov	eax, DWORD PTR _nSection$75353[ebp]
	sub	eax, 1
	mov	DWORD PTR _nSection$75353[ebp], eax
	test	edx, edx
	je	SHORT $L75356

; 121  : 			delete s_aIni[nSection];

	mov	ecx, DWORD PTR _nSection$75353[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T76666[ebp], edx
	mov	eax, DWORD PTR $T76666[ebp]
	mov	DWORD PTR $T76665[ebp], eax
	cmp	DWORD PTR $T76665[ebp], 0
	je	SHORT $L76667
	push	1
	mov	ecx, DWORD PTR $T76665[ebp]
	call	??_GINISECTION@@QAEPAXI@Z		; INISECTION::`scalar deleting destructor'
	mov	DWORD PTR -44+[ebp], eax
	jmp	SHORT $L76668
$L76667:
	mov	DWORD PTR -44+[ebp], 0
$L76668:
	jmp	SHORT $L75355
$L75356:

; 122  : 		
; 123  : 		s_aIni.RemoveAll();

	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ ; CArray<INISECTION *,INISECTION *>::RemoveAll
$L75352:

; 125  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76669:
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76672:
	mov	eax, OFFSET FLAT:$T76671
	jmp	___CxxFrameHandler
text$x	ENDS
??1CPreferences@@QAE@XZ ENDP				; CPreferences::~CPreferences
PUBLIC	??1INISECTION@@QAE@XZ				; INISECTION::~INISECTION
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GINISECTION@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GINISECTION@@QAEPAXI@Z PROC NEAR			; INISECTION::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1INISECTION@@QAE@XZ			; INISECTION::~INISECTION
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L75362
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L75362:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GINISECTION@@QAEPAXI@Z ENDP				; INISECTION::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76683	DD	019930520H
	DD	01H
	DD	FLAT:$T76685
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76685	DD	0ffffffffH
	DD	FLAT:$L76680
xdata$x	ENDS
;	COMDAT ??1INISECTION@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1INISECTION@@QAE@XZ PROC NEAR				; INISECTION::~INISECTION, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76684
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76680:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76684:
	mov	eax, OFFSET FLAT:$T76683
	jmp	___CxxFrameHandler
text$x	ENDS
??1INISECTION@@QAE@XZ ENDP				; INISECTION::~INISECTION
PUBLIC	?Format@INIENTRY@@QBE?AVCString@@XZ		; INIENTRY::Format
PUBLIC	?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetCount
PUBLIC	?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetStartPosition
PUBLIC	?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetNextAssoc
PUBLIC	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
PUBLIC	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z ; CPreferences::SetEntryValue
EXTRN	?GetAppVersion@FileMisc@@YA?AVCString@@XZ:NEAR	; FileMisc::GetAppVersion
EXTRN	?CopyFileW@FileMisc@@YAHPBG0HHH@Z:NEAR		; FileMisc::CopyFileW
EXTRN	??0CStringArray@@QAE@XZ:NEAR			; CStringArray::CStringArray
EXTRN	?SetSize@CStringArray@@QAEXHH@Z:NEAR		; CStringArray::SetSize
EXTRN	?SetAt@CStringArray@@QAEXHABVCString@@@Z:NEAR	; CStringArray::SetAt
EXTRN	??1CStringArray@@UAE@XZ:NEAR			; CStringArray::~CStringArray
EXTRN	?FormatArray@Misc@@YA?AVCString@@ABVCStringArray@@PBG@Z:NEAR ; Misc::FormatArray
EXTRN	?SortArray@Misc@@YAXAAVCStringArray@@P6AHPBX1@Z@Z:NEAR ; Misc::SortArray
EXTRN	??YCString@@QAEABV0@PBG@Z:NEAR			; CString::operator+=
EXTRN	?WriteString@CStdioFileEx@@UAEXPBG@Z:NEAR	; CStdioFileEx::WriteString
EXTRN	?Format@CString@@QAAXPBGZZ:NEAR			; CString::Format
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75371 DB	'b', 00H, 'a', 00H, 'k', 00H, '.', 00H, 'i', 00H, 'n', 00H
	DB	'i', 00H, 00H, 00H
$SG75376 DB	'A', 00H, 'p', 00H, 'p', 00H, 'V', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG75383 DB	'V', 00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, 00H, 00H
$SG75390 DB	'[', 00H, '%', 00H, 's', 00H, ']', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76706	DD	019930520H
	DD	0bH
	DD	FLAT:$T76708
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76708	DD	0ffffffffH
	DD	FLAT:$L76694
	DD	00H
	DD	FLAT:$L76695
	DD	01H
	DD	FLAT:$L76696
	DD	02H
	DD	FLAT:$L76697
	DD	03H
	DD	FLAT:$L76698
	DD	03H
	DD	FLAT:$L76699
	DD	05H
	DD	FLAT:$L76700
	DD	06H
	DD	FLAT:$L76701
	DD	07H
	DD	FLAT:$L76702
	DD	08H
	DD	FLAT:$L76703
	DD	06H
	DD	FLAT:$L76704
xdata$x	ENDS
;	COMDAT ?Save@CPreferences@@SAHXZ
_TEXT	SEGMENT
_lock$ = -24
_sIniPath$ = -32
_sBackupPath$ = -40
_file$ = -12372
_pSection$ = -36
_nSection$ = -28
_pSection$75388 = -12376
_sLine$75389 = -12408
_aEntries$75391 = -12396
_pos$75392 = -12404
_nEntry$75393 = -12400
_sDummy$75397 = -12416
_ie$75398 = -12428
_sSection$75400 = -12412
$T76690 = -12432
$T76691 = -12436
$T76692 = -12440
$T76693 = -12444
__$EHRec$ = -12
?Save@CPreferences@@SAHXZ PROC NEAR			; CPreferences::Save, COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76707
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	eax, 12452				; 000030a4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12464]
	mov	ecx, 3113				; 00000c29H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 129  : 	//TRACE(_T("CPreferences::Save(sections: %d)\n"), s_aIni.GetSize());
; 130  : 
; 131  : 	if (!(s_bDirty))

	cmp	DWORD PTR ?s_bDirty@CPreferences@@1HA, 0 ; CPreferences::s_bDirty
	jne	SHORT $L75367

; 132  : 		return TRUE; // nothing to do

	mov	eax, 1
	jmp	$L75366
$L75367:

; 133  : 
; 134  : 	// prevent anyone else changing the shared resources
; 135  : 	// for the duration of this function
; 136  : 	CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 137  : 
; 138  : 	// backup file first
; 139  : 	CString sIniPath(AfxGetApp()->m_pszProfileName);

	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	eax, DWORD PTR [eax+152]
	push	eax
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 140  : 	CString sBackupPath(sIniPath);

	lea	ecx, DWORD PTR _sIniPath$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 141  : 	
; 142  : 	FileMisc::ReplaceExtension(sBackupPath, _T("bak.ini"));

	push	OFFSET FLAT:$SG75371
	lea	edx, DWORD PTR _sBackupPath$[ebp]
	push	edx
	call	?ReplaceExtension@FileMisc@@YAAAVCString@@AAV2@PBG@Z ; FileMisc::ReplaceExtension
	add	esp, 8

; 143  : 	FileMisc::CopyFile(sIniPath, sBackupPath, TRUE, TRUE);

	push	0
	push	1
	push	1
	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?CopyFileW@FileMisc@@YAHPBG0HHH@Z	; FileMisc::CopyFileW
	add	esp, 20					; 00000014H

; 144  : 	
; 145  : 	// write prefs
; 146  : 	CStdioFileEx file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0CStdioFileEx@@QAE@XZ			; CStdioFileEx::CStdioFileEx
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 147  : 	
; 148  : 	if (!file.Open(sIniPath, CFile::modeWrite | CFile::modeCreate))

	push	0
	push	2
	push	4097					; 00001001H
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?Open@CStdioFileEx@@UAEHPBGIW4SFE_SAVEAS@@PAVCFileException@@@Z ; CStdioFileEx::Open
	test	eax, eax
	jne	SHORT $L75373

; 149  : 		return FALSE;

	mov	DWORD PTR $T76690[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CStdioFileEx@@UAE@XZ			; CStdioFileEx::~CStdioFileEx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76690[ebp]
	jmp	$L75366
$L75373:

; 150  : 	
; 151  : 	// insert application version
; 152  : 	INISECTION* pSection = GetSection(_T("AppVer"), TRUE);

	push	1
	push	OFFSET FLAT:$SG75376
	call	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
	add	esp, 8
	mov	DWORD PTR _pSection$[ebp], eax
$L75377:

; 153  : 	ASSERT(pSection);

	cmp	DWORD PTR _pSection$[ebp], 0
	jne	SHORT $L75380
	push	153					; 00000099H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75380
	int	3
$L75380:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75377

; 154  : 	
; 155  : 	if (pSection)

	cmp	DWORD PTR _pSection$[ebp], 0
	je	SHORT $L75381

; 156  : 		SetEntryValue(*pSection, _T("Version"), FileMisc::GetAppVersion(), FALSE);

	push	0
	lea	ecx, DWORD PTR $T76691[ebp]
	push	ecx
	call	?GetAppVersion@FileMisc@@YA?AVCString@@XZ ; FileMisc::GetAppVersion
	add	esp, 4
	mov	DWORD PTR -12448+[ebp], eax
	mov	edx, DWORD PTR -12448+[ebp]
	mov	DWORD PTR -12452+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR -12452+[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	push	OFFSET FLAT:$SG75383
	mov	eax, DWORD PTR _pSection$[ebp]
	push	eax
	call	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z ; CPreferences::SetEntryValue
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T76691[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75381:

; 157  : 	
; 158  : 	for (int nSection = 0; nSection < s_aIni.GetSize(); nSection++)

	mov	DWORD PTR _nSection$[ebp], 0
	jmp	SHORT $L75385
$L75386:
	mov	ecx, DWORD PTR _nSection$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nSection$[ebp], ecx
$L75385:
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ ; CArray<INISECTION *,INISECTION *>::GetSize
	cmp	DWORD PTR _nSection$[ebp], eax
	jge	$L75387

; 160  : 		// write section line
; 161  : 		INISECTION* pSection = s_aIni[nSection];

	mov	edx, DWORD PTR _nSection$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pSection$75388[ebp], eax

; 162  : 		
; 163  : 		CString sLine;

	lea	ecx, DWORD PTR _sLine$75389[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 164  : 		sLine.Format(_T("[%s]%s"), pSection->sSection, ENDL);

	mov	ecx, DWORD PTR _ENDL
	push	ecx
	mov	edx, DWORD PTR _pSection$75388[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:$SG75390
	lea	ecx, DWORD PTR _sLine$75389[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 165  : 		
; 166  : 		file.WriteString(sLine);

	lea	ecx, DWORD PTR _sLine$75389[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?WriteString@CStdioFileEx@@UAEXPBG@Z	; CStdioFileEx::WriteString

; 167  : 		
; 168  : 		// write entries to a CStringArray, then sort it and write it to file
; 169  : 		CStringArray aEntries;

	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	call	??0CStringArray@@QAE@XZ			; CStringArray::CStringArray
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 170  : 		aEntries.SetSize(pSection->aEntries.GetCount(), 10);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _pSection$75388[ebp]
	add	ecx, 4
	call	?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetCount
	push	eax
	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	call	?SetSize@CStringArray@@QAEXHH@Z		; CStringArray::SetSize

; 171  : 		
; 172  : 		// save map to array
; 173  : 		POSITION pos = pSection->aEntries.GetStartPosition();

	mov	ecx, DWORD PTR _pSection$75388[ebp]
	add	ecx, 4
	call	?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetStartPosition
	mov	DWORD PTR _pos$75392[ebp], eax

; 174  : 		int nEntry = 0;

	mov	DWORD PTR _nEntry$75393[ebp], 0
$L75395:

; 175  : 		
; 176  : 		while (pos)

	cmp	DWORD PTR _pos$75392[ebp], 0
	je	$L75396

; 178  : 			CString sDummy;

	lea	ecx, DWORD PTR _sDummy$75397[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 179  : 			INIENTRY ie;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _ie$75398[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 180  : 			
; 181  : 			pSection->aEntries.GetNextAssoc(pos, sDummy, ie);

	lea	edx, DWORD PTR _ie$75398[ebp]
	push	edx
	lea	eax, DWORD PTR _sDummy$75397[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$75392[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSection$75388[ebp]
	add	ecx, 4
	call	?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetNextAssoc

; 182  : 
; 183  : 			aEntries.SetAt(nEntry++, ie.Format());

	lea	edx, DWORD PTR $T76692[ebp]
	push	edx
	lea	ecx, DWORD PTR _ie$75398[ebp]
	call	?Format@INIENTRY@@QBE?AVCString@@XZ	; INIENTRY::Format
	mov	DWORD PTR -12456+[ebp], eax
	mov	eax, DWORD PTR -12456+[ebp]
	mov	DWORD PTR -12460+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR -12460+[ebp]
	push	ecx
	mov	edx, DWORD PTR _nEntry$75393[ebp]
	mov	DWORD PTR -12464+[ebp], edx
	mov	eax, DWORD PTR -12464+[ebp]
	push	eax
	mov	ecx, DWORD PTR _nEntry$75393[ebp]
	add	ecx, 1
	mov	DWORD PTR _nEntry$75393[ebp], ecx
	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	call	?SetAt@CStringArray@@QAEXHABVCString@@@Z ; CStringArray::SetAt
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T76692[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 184  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _ie$75398[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _sDummy$75397[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L75395
$L75396:

; 185  : 		
; 186  : 		// sort array
; 187  : 		Misc::SortArray(aEntries);

	push	0
	lea	edx, DWORD PTR _aEntries$75391[ebp]
	push	edx
	call	?SortArray@Misc@@YAXAAVCStringArray@@P6AHPBX1@Z@Z ; Misc::SortArray
	add	esp, 8

; 188  : 		
; 189  : 		// format by newlines
; 190  : 		CString sSection = Misc::FormatArray(aEntries, ENDL);

	mov	eax, DWORD PTR _ENDL
	push	eax
	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	push	ecx
	lea	edx, DWORD PTR _sSection$75400[ebp]
	push	edx
	call	?FormatArray@Misc@@YA?AVCString@@ABVCStringArray@@PBG@Z ; Misc::FormatArray
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 191  : 		sSection += ENDL;

	mov	eax, DWORD PTR _ENDL
	push	eax
	lea	ecx, DWORD PTR _sSection$75400[ebp]
	call	??YCString@@QAEABV0@PBG@Z		; CString::operator+=

; 192  : 		sSection += ENDL;

	mov	ecx, DWORD PTR _ENDL
	push	ecx
	lea	ecx, DWORD PTR _sSection$75400[ebp]
	call	??YCString@@QAEABV0@PBG@Z		; CString::operator+=

; 193  : 		
; 194  : 		// save to file
; 195  : 		file.WriteString(sSection);

	lea	ecx, DWORD PTR _sSection$75400[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?WriteString@CStdioFileEx@@UAEXPBG@Z	; CStdioFileEx::WriteString

; 196  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _sSection$75400[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _sLine$75389[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L75386
$L75387:

; 197  : 	
; 198  : 	s_bDirty = FALSE;

	mov	DWORD PTR ?s_bDirty@CPreferences@@1HA, 0 ; CPreferences::s_bDirty

; 199  : 	
; 200  : 	// delete backup
; 201  : 	::DeleteFile(sBackupPath);

	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileW@4
	cmp	esi, esp
	call	__chkesp

; 202  : 
; 203  : 	return TRUE;

	mov	DWORD PTR $T76693[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CStdioFileEx@@UAE@XZ			; CStdioFileEx::~CStdioFileEx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76693[ebp]
$L75366:

; 204  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12464				; 000030b0H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76694:
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76695:
	lea	ecx, DWORD PTR _sIniPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76696:
	lea	ecx, DWORD PTR _sBackupPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76697:
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1CStdioFileEx@@UAE@XZ			; CStdioFileEx::~CStdioFileEx
	ret	0
$L76698:
	lea	ecx, DWORD PTR $T76691[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76699:
	lea	ecx, DWORD PTR _sLine$75389[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76700:
	lea	ecx, DWORD PTR _aEntries$75391[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	ret	0
$L76701:
	lea	ecx, DWORD PTR _sDummy$75397[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76702:
	lea	ecx, DWORD PTR _ie$75398[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L76703:
	lea	ecx, DWORD PTR $T76692[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76704:
	lea	ecx, DWORD PTR _sSection$75400[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76707:
	mov	eax, OFFSET FLAT:$T76706
	jmp	___CxxFrameHandler
text$x	ENDS
?Save@CPreferences@@SAHXZ ENDP				; CPreferences::Save
PUBLIC	??_C@_1BA@GAJA@?$AA?$CF?$AAs?$AA?$DN?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EHKI@?$AA?$CF?$AAs?$AA?$DN?$AA?$CF?$AAs?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BA@GAJA@?$AA?$CF?$AAs?$AA?$DN?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@
; File D:\_CODE\Shared\Preferences.h
_DATA	SEGMENT
??_C@_1BA@GAJA@?$AA?$CF?$AAs?$AA?$DN?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@ DB '%'
	DB	00H, 's', 00H, '=', 00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H
	DB	00H, 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_1M@EHKI@?$AA?$CF?$AAs?$AA?$DN?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT
??_C@_1M@EHKI@?$AA?$CF?$AAs?$AA?$DN?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, '=', 00H, '%', 00H, 's', 00H, 00H, 00H	; `string'
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76719	DD	019930520H
	DD	02H
	DD	FLAT:$T76721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76721	DD	0ffffffffH
	DD	FLAT:$L76715
	DD	00H
	DD	FLAT:$L76714
xdata$x	ENDS
;	COMDAT ?Format@INIENTRY@@QBE?AVCString@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -24
_sEntry$ = -16
$T76716 = -20
__$EHRec$ = -12
?Format@INIENTRY@@QBE?AVCString@@XZ PROC NEAR		; INIENTRY::Format, COMDAT

; 25   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76720
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T76716[ebp], 0

; 26   : 		CString sEntry;

	lea	ecx, DWORD PTR _sEntry$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 27   : 
; 28   : 		if (bQuoted)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L74021

; 29   : 			sEntry.Format(_T("%s=\"%s\""), sName, sValue);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:??_C@_1BA@GAJA@?$AA?$CF?$AAs?$AA?$DN?$AA?$CC?$AA?$CF?$AAs?$AA?$CC?$AA?$AA@ ; `string'
	lea	edx, DWORD PTR _sEntry$[ebp]
	push	edx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 30   : 		else

	jmp	SHORT $L74023
$L74021:

; 31   : 			sEntry.Format(_T("%s=%s"), sName, sValue);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_1M@EHKI@?$AA?$CF?$AAs?$AA?$DN?$AA?$CF?$AAs?$AA?$AA@ ; `string'
	lea	ecx, DWORD PTR _sEntry$[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H
$L74023:

; 32   : 
; 33   : 		return sEntry;

	lea	edx, DWORD PTR _sEntry$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	eax, DWORD PTR $T76716[ebp]
	or	al, 1
	mov	DWORD PTR $T76716[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sEntry$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 34   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76714:
	lea	ecx, DWORD PTR _sEntry$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76715:
	mov	eax, DWORD PTR $T76716[ebp]
	and	eax, 1
	test	eax, eax
	je	$L76717
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76717:
	ret	0
$L76720:
	mov	eax, OFFSET FLAT:$T76719
	jmp	___CxxFrameHandler
text$x	ENDS
?Format@INIENTRY@@QBE?AVCString@@XZ ENDP		; INIENTRY::Format
PUBLIC	?ToString@CPreferences@@KA?AVCString@@H@Z	; CPreferences::ToString
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75408 DB	'%', 00H, 'l', 00H, 'd', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76731	DD	019930520H
	DD	02H
	DD	FLAT:$T76733
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76733	DD	0ffffffffH
	DD	FLAT:$L76727
	DD	00H
	DD	FLAT:$L76726
xdata$x	ENDS
;	COMDAT ?ToString@CPreferences@@KA?AVCString@@H@Z
_TEXT	SEGMENT
_nValue$ = 12
___$ReturnUdt$ = 8
_sValue$ = -16
$T76728 = -20
__$EHRec$ = -12
?ToString@CPreferences@@KA?AVCString@@H@Z PROC NEAR	; CPreferences::ToString, COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76732
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR $T76728[ebp], 0

; 208  : 	CString sValue;

	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 209  : 	sValue.Format(_T("%ld"), nValue);

	mov	eax, DWORD PTR _nValue$[ebp]
	push	eax
	push	OFFSET FLAT:$SG75408
	lea	ecx, DWORD PTR _sValue$[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 12					; 0000000cH

; 210  : 	return sValue;

	lea	edx, DWORD PTR _sValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	eax, DWORD PTR $T76728[ebp]
	or	al, 1
	mov	DWORD PTR $T76728[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76726:
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76727:
	mov	eax, DWORD PTR $T76728[ebp]
	and	eax, 1
	test	eax, eax
	je	$L76729
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76729:
	ret	0
$L76732:
	mov	eax, OFFSET FLAT:$T76731
	jmp	___CxxFrameHandler
text$x	ENDS
?ToString@CPreferences@@KA?AVCString@@H@Z ENDP		; CPreferences::ToString
PUBLIC	?ToString@CPreferences@@KA?AVCString@@N@Z	; CPreferences::ToString
EXTRN	__fltused:NEAR
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75414 DB	'%', 00H, '.', 00H, '6', 00H, 'f', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76744	DD	019930520H
	DD	02H
	DD	FLAT:$T76747
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76747	DD	0ffffffffH
	DD	FLAT:$L76740
	DD	00H
	DD	FLAT:$L76739
xdata$x	ENDS
;	COMDAT ?ToString@CPreferences@@KA?AVCString@@N@Z
_TEXT	SEGMENT
_dValue$ = 12
___$ReturnUdt$ = 8
_sValue$ = -16
$T76741 = -20
__$EHRec$ = -12
?ToString@CPreferences@@KA?AVCString@@N@Z PROC NEAR	; CPreferences::ToString, COMDAT

; 214  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76745
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR $T76741[ebp], 0

; 215  : 	CString sValue;

	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 216  : 	sValue.Format(_T("%.6f"), dValue);

	mov	eax, DWORD PTR _dValue$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dValue$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG75414
	lea	edx, DWORD PTR _sValue$[ebp]
	push	edx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 217  : 	return sValue;

	lea	eax, DWORD PTR _sValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	ecx, DWORD PTR $T76741[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76741[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 218  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76739:
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76740:
	mov	eax, DWORD PTR $T76741[ebp]
	and	eax, 1
	test	eax, eax
	je	$L76742
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76742:
	ret	0
$L76745:
	mov	eax, OFFSET FLAT:$T76744
	jmp	___CxxFrameHandler
text$x	ENDS
?ToString@CPreferences@@KA?AVCString@@N@Z ENDP		; CPreferences::ToString
EXTRN	__imp___wtol:NEAR
EXTRN	?GetProfileIntW@CWinApp@@QAEIPBG0H@Z:NEAR	; CWinApp::GetProfileIntW
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76757	DD	019930520H
	DD	01H
	DD	FLAT:$T76759
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76759	DD	0ffffffffH
	DD	FLAT:$L76755
xdata$x	ENDS
;	COMDAT ?GetProfileIntW@CPreferences@@UBEIPBG0H@Z
_TEXT	SEGMENT
_lpszSection$ = 8
_lpszEntry$ = 12
_nDefault$ = 16
_this$ = -28
_sValue$75422 = -16
$T76753 = -20
$T76754 = -24
__$EHRec$ = -12
?GetProfileIntW@CPreferences@@UBEIPBG0H@Z PROC NEAR	; CPreferences::GetProfileIntW, COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76758
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75421

; 224  : 		CString sValue = GetProfileString(lpszSection, lpszEntry);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sValue$75422[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 225  : 		
; 226  : 		if (sValue.IsEmpty()) 

	lea	ecx, DWORD PTR _sValue$75422[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	je	SHORT $L75424

; 227  : 			return nDefault;

	mov	eax, DWORD PTR _nDefault$[ebp]
	mov	DWORD PTR $T76753[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sValue$75422[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76753[ebp]
	jmp	SHORT $L75428
$L75424:

; 229  : 			return _ttol(sValue);

	lea	ecx, DWORD PTR _sValue$75422[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp___wtol
	add	esp, 4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR $T76754[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sValue$75422[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76754[ebp]
	jmp	SHORT $L75428
$L75421:

; 232  : 		return AfxGetApp()->GetProfileInt(lpszSection, lpszEntry, nDefault);

	mov	ecx, DWORD PTR _nDefault$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, eax
	call	?GetProfileIntW@CWinApp@@QAEIPBG0H@Z	; CWinApp::GetProfileIntW
$L75428:

; 233  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76755:
	lea	ecx, DWORD PTR _sValue$75422[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76758:
	mov	eax, OFFSET FLAT:$T76757
	jmp	___CxxFrameHandler
text$x	ENDS
?GetProfileIntW@CPreferences@@UBEIPBG0H@Z ENDP		; CPreferences::GetProfileIntW
PUBLIC	?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z	; CPreferences::WriteProfileStringW
EXTRN	?WriteProfileInt@CWinApp@@QAEHPBG0H@Z:NEAR	; CWinApp::WriteProfileInt
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76768	DD	019930520H
	DD	01H
	DD	FLAT:$T76770
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76770	DD	0ffffffffH
	DD	FLAT:$L76766
xdata$x	ENDS
;	COMDAT ?WriteProfileInt@CPreferences@@UAEHPBG0H@Z
_TEXT	SEGMENT
_lpszSection$ = 8
_lpszEntry$ = 12
_nValue$ = 16
_this$ = -24
$T76764 = -16
$T76765 = -20
__$EHRec$ = -12
?WriteProfileInt@CPreferences@@UAEHPBG0H@Z PROC NEAR	; CPreferences::WriteProfileInt, COMDAT

; 236  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76769
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75435

; 238  : 		return WriteProfileString(lpszSection, lpszEntry, ToString(nValue), FALSE);

	push	0
	mov	eax, DWORD PTR _nValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76765[ebp]
	push	ecx
	call	?ToString@CPreferences@@KA?AVCString@@H@Z ; CPreferences::ToString
	add	esp, 8
	mov	DWORD PTR -28+[ebp], eax
	mov	edx, DWORD PTR -28+[ebp]
	mov	DWORD PTR -32+[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -32+[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z ; CPreferences::WriteProfileStringW
	mov	DWORD PTR $T76764[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76765[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76764[ebp]
	jmp	SHORT $L75438
$L75435:

; 240  : 		return AfxGetApp()->WriteProfileInt(lpszSection, lpszEntry, nValue);

	mov	edx, DWORD PTR _nValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, eax
	call	?WriteProfileInt@CWinApp@@QAEHPBG0H@Z	; CWinApp::WriteProfileInt
$L75438:

; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76766:
	lea	ecx, DWORD PTR $T76765[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76769:
	mov	eax, OFFSET FLAT:$T76768
	jmp	___CxxFrameHandler
text$x	ENDS
?WriteProfileInt@CPreferences@@UAEHPBG0H@Z ENDP		; CPreferences::WriteProfileInt
PUBLIC	?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z ; CPreferences::GetIniString
EXTRN	?GetProfileStringW@CWinApp@@QAE?AVCString@@PBG00@Z:NEAR ; CWinApp::GetProfileStringW
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76780	DD	019930520H
	DD	01H
	DD	FLAT:$T76782
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76782	DD	0ffffffffH
	DD	FLAT:$L76775
xdata$x	ENDS
;	COMDAT ?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z
_TEXT	SEGMENT
_lpszSection$ = 12
_lpszEntry$ = 16
_lpszDefault$ = 20
___$ReturnUdt$ = 8
_this$ = -32
_lock$75447 = -24
$T76777 = -28
__$EHRec$ = -12
?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z PROC NEAR ; CPreferences::GetProfileStringW, COMDAT

; 244  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76781
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T76777[ebp], 0

; 245  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75446

; 247  : 		// prevent anyone else changing the shared resources
; 248  : 		// for the duration of this function
; 249  : 		CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$75447[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 250  : 
; 251  : 		return GetIniString(lpszSection, lpszEntry, lpszDefault);

	mov	eax, DWORD PTR _lpszDefault$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z ; CPreferences::GetIniString
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR $T76777[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76777[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75447[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L75445
$L75446:

; 253  : 
; 254  : 	// else registry
; 255  : 	return AfxGetApp()->GetProfileString(lpszSection, lpszEntry, lpszDefault);

	mov	edx, DWORD PTR _lpszDefault$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, eax
	call	?GetProfileStringW@CWinApp@@QAE?AVCString@@PBG00@Z ; CWinApp::GetProfileStringW
	mov	eax, DWORD PTR $T76777[ebp]
	or	al, 1
	mov	DWORD PTR $T76777[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L75445:

; 256  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76775:
	lea	ecx, DWORD PTR _lock$75447[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76781:
	mov	eax, OFFSET FLAT:$T76780
	jmp	___CxxFrameHandler
text$x	ENDS
?GetProfileStringW@CPreferences@@UBE?AVCString@@PBG00@Z ENDP ; CPreferences::GetProfileStringW
;	COMDAT ?WriteProfileStringW@CPreferences@@UAEHPBG00@Z
_TEXT	SEGMENT
_lpszSection$ = 8
_lpszEntry$ = 12
_lpszValue$ = 16
_this$ = -4
?WriteProfileStringW@CPreferences@@UAEHPBG00@Z PROC NEAR ; CPreferences::WriteProfileStringW, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	// quote string values passed in from outside
; 261  : 	return WriteProfileString(lpszSection, lpszEntry, lpszValue, TRUE);

	push	1
	mov	eax, DWORD PTR _lpszValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z ; CPreferences::WriteProfileStringW

; 262  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteProfileStringW@CPreferences@@UAEHPBG00@Z ENDP	; CPreferences::WriteProfileStringW
_TEXT	ENDS
PUBLIC	?WriteIniString@CPreferences@@KAHPBG00H@Z	; CPreferences::WriteIniString
EXTRN	?WriteProfileStringW@CWinApp@@QAEHPBG00@Z:NEAR	; CWinApp::WriteProfileStringW
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76792	DD	019930520H
	DD	01H
	DD	FLAT:$T76794
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76794	DD	0ffffffffH
	DD	FLAT:$L76790
xdata$x	ENDS
;	COMDAT ?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z
_TEXT	SEGMENT
_lpszSection$ = 8
_lpszEntry$ = 12
_lpszValue$ = 16
_bQuoted$ = 20
_this$ = -32
_lock$75464 = -24
$T76789 = -28
__$EHRec$ = -12
?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z PROC NEAR ; CPreferences::WriteProfileStringW, COMDAT

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76793
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75463

; 268  : 		// prevent anyone else changing the shared resources
; 269  : 		// for the duration of this function
; 270  : 		CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$75464[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 
; 272  : 		return WriteIniString(lpszSection, lpszEntry, lpszValue, bQuoted);

	mov	eax, DWORD PTR _bQuoted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?WriteIniString@CPreferences@@KAHPBG00H@Z ; CPreferences::WriteIniString
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T76789[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75464[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76789[ebp]
	jmp	SHORT $L75462
$L75463:

; 274  : 
; 275  : 	// else registry
; 276  : 	return AfxGetApp()->WriteProfileString(lpszSection, lpszEntry, lpszValue);

	mov	ecx, DWORD PTR _lpszValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, eax
	call	?WriteProfileStringW@CWinApp@@QAEHPBG00@Z ; CWinApp::WriteProfileStringW
$L75462:

; 277  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76790:
	lea	ecx, DWORD PTR _lock$75464[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76793:
	mov	eax, OFFSET FLAT:$T76792
	jmp	___CxxFrameHandler
text$x	ENDS
?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z ENDP	; CPreferences::WriteProfileStringW
PUBLIC	?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z ; CPreferences::GetEntryValue
;	COMDAT ?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z
_TEXT	SEGMENT
$T76800 = -8
_lpszSection$ = 12
_lpszEntry$ = 16
_lpszDefault$ = 20
___$ReturnUdt$ = 8
_pSection$75477 = -4
?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z PROC NEAR ; CPreferences::GetIniString, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR $T76800[ebp], 0
$L75472:

; 281  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75475
	push	281					; 00000119H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75475
	int	3
$L75475:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75472

; 282  : 
; 283  : 	// this is an internal method that assumes callers
; 284  : 	// have initialised a lock already
; 285  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 286  : 	
; 287  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75478

; 289  : 		INISECTION* pSection = GetSection(lpszSection, FALSE);

	push	0
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
	add	esp, 8
	mov	DWORD PTR _pSection$75477[ebp], eax

; 290  : 		
; 291  : 		if (pSection)

	cmp	DWORD PTR _pSection$75477[ebp], 0
	je	SHORT $L75478

; 292  : 			return GetEntryValue(*pSection, lpszEntry, lpszDefault);

	mov	edx, DWORD PTR _lpszDefault$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSection$75477[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z ; CPreferences::GetEntryValue
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR $T76800[ebp]
	or	al, 1
	mov	DWORD PTR $T76800[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L75471
$L75478:

; 294  : 	
; 295  : 	// else
; 296  : 	return lpszDefault;

	mov	ecx, DWORD PTR _lpszDefault$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	edx, DWORD PTR $T76800[ebp]
	or	edx, 1
	mov	DWORD PTR $T76800[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L75471:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIniString@CPreferences@@KA?AVCString@@PBG00@Z ENDP	; CPreferences::GetIniString
_TEXT	ENDS
;	COMDAT ?WriteIniString@CPreferences@@KAHPBG00H@Z
_TEXT	SEGMENT
_lpszSection$ = 8
_lpszEntry$ = 12
_lpszValue$ = 16
_bQuoted$ = 20
_pSection$75491 = -4
?WriteIniString@CPreferences@@KAHPBG00H@Z PROC NEAR	; CPreferences::WriteIniString, COMDAT

; 300  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
$L75486:

; 301  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75489
	push	301					; 0000012dH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75489
	int	3
$L75489:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75486

; 302  : 
; 303  : 	// this is an internal method that assumes callers
; 304  : 	// have initialised a lock already
; 305  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 306  : 	
; 307  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75496

; 309  : 		INISECTION* pSection = GetSection(lpszSection, TRUE);

	push	1
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
	add	esp, 8
	mov	DWORD PTR _pSection$75491[ebp], eax
$L75492:

; 310  : 		ASSERT(pSection);

	cmp	DWORD PTR _pSection$75491[ebp], 0
	jne	SHORT $L75495
	push	310					; 00000136H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75495
	int	3
$L75495:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75492

; 311  : 		
; 312  : 		if (pSection)

	cmp	DWORD PTR _pSection$75491[ebp], 0
	je	SHORT $L75496

; 314  : 			SetEntryValue(*pSection, lpszEntry, lpszValue, bQuoted);

	mov	eax, DWORD PTR _bQuoted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSection$75491[ebp]
	push	eax
	call	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z ; CPreferences::SetEntryValue
	add	esp, 16					; 00000010H

; 315  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L75485
$L75496:

; 318  : 	
; 319  : 	// else
; 320  : 	return FALSE;

	xor	eax, eax
$L75485:

; 321  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteIniString@CPreferences@@KAHPBG00H@Z ENDP		; CPreferences::WriteIniString
_TEXT	ENDS
EXTRN	?Atof@Misc@@YANABVCString@@@Z:NEAR		; Misc::Atof
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76812	DD	019930520H
	DD	03H
	DD	FLAT:$T76814
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76814	DD	0ffffffffH
	DD	FLAT:$L76809
	DD	00H
	DD	FLAT:$L76810
	DD	0ffffffffH
	DD	FLAT:$L76810
xdata$x	ENDS
;	COMDAT ?GetProfileDouble@CPreferences@@UBENPBG0N@Z
_TEXT	SEGMENT
$T76806 = -20
$T76807 = -28
$T76808 = -36
__$EHRec$ = -12
_lpszSection$ = 8
_lpszEntry$ = 12
_dDefault$ = 16
_this$ = -40
_sValue$ = -16
?GetProfileDouble@CPreferences@@UBENPBG0N@Z PROC NEAR	; CPreferences::GetProfileDouble, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76813
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 325  : 	CString sValue = GetProfileString(lpszSection, lpszEntry, ToString(dDefault));

	mov	eax, DWORD PTR _dDefault$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dDefault$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76806[ebp]
	push	edx
	call	?ToString@CPreferences@@KA?AVCString@@N@Z ; CPreferences::ToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR -44+[ebp], eax
	mov	eax, DWORD PTR -44+[ebp]
	mov	DWORD PTR -48+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -48+[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	lea	eax, DWORD PTR _sValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__chkesp
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T76806[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 326  : 	
; 327  : 	if (sValue.IsEmpty())

	lea	ecx, DWORD PTR _sValue$[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	je	SHORT $L75506

; 328  : 		return dDefault;

	mov	eax, DWORD PTR _dDefault$[ebp]
	mov	DWORD PTR $T76807[ebp], eax
	mov	ecx, DWORD PTR _dDefault$[ebp+4]
	mov	DWORD PTR $T76807[ebp+4], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	fld	QWORD PTR $T76807[ebp]
	jmp	SHORT $L75502
$L75506:

; 330  : 		return Misc::Atof(sValue);

	lea	edx, DWORD PTR _sValue$[ebp]
	push	edx
	call	?Atof@Misc@@YANABVCString@@@Z		; Misc::Atof
	add	esp, 4
	fstp	QWORD PTR $T76808[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	fld	QWORD PTR $T76808[ebp]
$L75502:

; 331  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76809:
	lea	ecx, DWORD PTR $T76806[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76810:
	lea	ecx, DWORD PTR _sValue$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76813:
	mov	eax, OFFSET FLAT:$T76812
	jmp	___CxxFrameHandler
text$x	ENDS
?GetProfileDouble@CPreferences@@UBENPBG0N@Z ENDP	; CPreferences::GetProfileDouble
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76823	DD	019930520H
	DD	01H
	DD	FLAT:$T76825
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76825	DD	0ffffffffH
	DD	FLAT:$L76821
xdata$x	ENDS
;	COMDAT ?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z
_TEXT	SEGMENT
$T76819 = -16
$T76820 = -20
__$EHRec$ = -12
_lpszSection$ = 8
_lpszEntry$ = 12
_dValue$ = 16
_this$ = -24
?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z PROC NEAR	; CPreferences::WriteProfileDouble, COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76824
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	return WriteProfileString(lpszSection, lpszEntry, ToString(dValue), FALSE);

	push	0
	mov	eax, DWORD PTR _dValue$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76820[ebp]
	push	edx
	call	?ToString@CPreferences@@KA?AVCString@@N@Z ; CPreferences::ToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR -28+[ebp], eax
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -32+[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteProfileStringW@CPreferences@@IAEHPBG00H@Z ; CPreferences::WriteProfileStringW
	mov	DWORD PTR $T76819[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76820[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76819[ebp]

; 336  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76821:
	lea	ecx, DWORD PTR $T76820[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76824:
	mov	eax, OFFSET FLAT:$T76823
	jmp	___CxxFrameHandler
text$x	ENDS
?WriteProfileDouble@CPreferences@@UAEHPBG0N@Z ENDP	; CPreferences::WriteProfileDouble
PUBLIC	?GetProfileArray@CPreferences@@QBEHPBGAAVCStringArray@@H@Z ; CPreferences::GetProfileArray
EXTRN	?GetSize@CStringArray@@QBEHXZ:NEAR		; CStringArray::GetSize
EXTRN	?RemoveAll@CStringArray@@QAEXXZ:NEAR		; CStringArray::RemoveAll
EXTRN	?Add@CStringArray@@QAEHABVCString@@@Z:NEAR	; CStringArray::Add
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75525 DB	'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG75532 DB	'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, '%', 00H, 'd', 00H
	DB	00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76835	DD	019930520H
	DD	03H
	DD	FLAT:$T76837
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76837	DD	0ffffffffH
	DD	FLAT:$L76831
	DD	00H
	DD	FLAT:$L76832
	DD	01H
	DD	FLAT:$L76833
xdata$x	ENDS
;	COMDAT ?GetProfileArray@CPreferences@@QBEHPBGAAVCStringArray@@H@Z
_TEXT	SEGMENT
$T76830 = -32
__$EHRec$ = -12
_lpszSection$ = 8
_aItems$ = 12
_bAllowEmpty$ = 16
_this$ = -36
_nCount$ = -20
_nItem$ = -16
_sItemKey$75530 = -28
_sItem$75531 = -24
?GetProfileArray@CPreferences@@QBEHPBGAAVCStringArray@@H@Z PROC NEAR ; CPreferences::GetProfileArray, COMDAT

; 339  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76836
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 340  : 	aItems.RemoveAll();

	mov	ecx, DWORD PTR _aItems$[ebp]
	call	?RemoveAll@CStringArray@@QAEXXZ		; CStringArray::RemoveAll

; 341  : 	int nCount = GetProfileInt(lpszSection, _T("ItemCount"), 0);

	mov	esi, esp
	push	0
	push	OFFSET FLAT:$SG75525
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _nCount$[ebp], eax

; 342  : 	
; 343  : 	// items
; 344  : 	for (int nItem = 0; nItem < nCount; nItem++)

	mov	DWORD PTR _nItem$[ebp], 0
	jmp	SHORT $L75527
$L75528:
	mov	eax, DWORD PTR _nItem$[ebp]
	add	eax, 1
	mov	DWORD PTR _nItem$[ebp], eax
$L75527:
	mov	ecx, DWORD PTR _nItem$[ebp]
	cmp	ecx, DWORD PTR _nCount$[ebp]
	jge	$L75529

; 346  : 		CString sItemKey, sItem;

	lea	ecx, DWORD PTR _sItemKey$75530[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sItem$75531[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 347  : 		sItemKey.Format(_T("Item%d"), nItem);

	mov	edx, DWORD PTR _nItem$[ebp]
	push	edx
	push	OFFSET FLAT:$SG75532
	lea	eax, DWORD PTR _sItemKey$75530[ebp]
	push	eax
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 12					; 0000000cH

; 348  : 		sItem = GetProfileString(lpszSection, sItemKey);

	mov	esi, esp
	push	0
	lea	ecx, DWORD PTR _sItemKey$75530[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76830[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR -40+[ebp], eax
	mov	eax, DWORD PTR -40+[ebp]
	mov	DWORD PTR -44+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR -44+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sItem$75531[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T76830[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 349  : 		
; 350  : 		if (bAllowEmpty || !sItem.IsEmpty())

	cmp	DWORD PTR _bAllowEmpty$[ebp], 0
	jne	SHORT $L75535
	lea	ecx, DWORD PTR _sItem$75531[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	SHORT $L75534
$L75535:

; 351  : 			aItems.Add(sItem);

	lea	edx, DWORD PTR _sItem$75531[ebp]
	push	edx
	mov	ecx, DWORD PTR _aItems$[ebp]
	call	?Add@CStringArray@@QAEHABVCString@@@Z	; CStringArray::Add
$L75534:

; 352  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sItem$75531[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sItemKey$75530[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L75528
$L75529:

; 353  : 	
; 354  : 	return aItems.GetSize();

	mov	ecx, DWORD PTR _aItems$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize

; 355  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76831:
	lea	ecx, DWORD PTR _sItemKey$75530[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76832:
	lea	ecx, DWORD PTR _sItem$75531[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76833:
	lea	ecx, DWORD PTR $T76830[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76836:
	mov	eax, OFFSET FLAT:$T76835
	jmp	___CxxFrameHandler
text$x	ENDS
?GetProfileArray@CPreferences@@QBEHPBGAAVCStringArray@@H@Z ENDP ; CPreferences::GetProfileArray
PUBLIC	?WriteProfileArray@CPreferences@@QAEXPBGABVCStringArray@@@Z ; CPreferences::WriteProfileArray
EXTRN	??ACStringArray@@QBE?AVCString@@H@Z:NEAR	; CStringArray::operator[]
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75547 DB	'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, '%', 00H, 'd', 00H
	DB	00H, 00H
	ORG $+2
$SG75549 DB	'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76847	DD	019930520H
	DD	02H
	DD	FLAT:$T76849
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76849	DD	0ffffffffH
	DD	FLAT:$L76844
	DD	00H
	DD	FLAT:$L76845
xdata$x	ENDS
;	COMDAT ?WriteProfileArray@CPreferences@@QAEXPBGABVCStringArray@@@Z
_TEXT	SEGMENT
$T76843 = -28
__$EHRec$ = -12
_lpszSection$ = 8
_aItems$ = 12
_this$ = -32
_nCount$ = -20
_nItem$ = -16
_sItemKey$75546 = -24
?WriteProfileArray@CPreferences@@QAEXPBGABVCStringArray@@@Z PROC NEAR ; CPreferences::WriteProfileArray, COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76848
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 359  : 	int nCount = aItems.GetSize();

	mov	ecx, DWORD PTR _aItems$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize
	mov	DWORD PTR _nCount$[ebp], eax

; 360  : 	
; 361  : 	// items
; 362  : 	for (int nItem = 0; nItem < nCount; nItem++)

	mov	DWORD PTR _nItem$[ebp], 0
	jmp	SHORT $L75543
$L75544:
	mov	eax, DWORD PTR _nItem$[ebp]
	add	eax, 1
	mov	DWORD PTR _nItem$[ebp], eax
$L75543:
	mov	ecx, DWORD PTR _nItem$[ebp]
	cmp	ecx, DWORD PTR _nCount$[ebp]
	jge	$L75545

; 364  : 		CString sItemKey;

	lea	ecx, DWORD PTR _sItemKey$75546[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 365  : 		sItemKey.Format(_T("Item%d"), nItem);

	mov	edx, DWORD PTR _nItem$[ebp]
	push	edx
	push	OFFSET FLAT:$SG75547
	lea	eax, DWORD PTR _sItemKey$75546[ebp]
	push	eax
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 12					; 0000000cH

; 366  : 		WriteProfileString(lpszSection, sItemKey, aItems[nItem]);

	mov	ecx, DWORD PTR _nItem$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76843[ebp]
	push	edx
	mov	ecx, DWORD PTR _aItems$[ebp]
	call	??ACStringArray@@QBE?AVCString@@H@Z	; CStringArray::operator[]
	mov	DWORD PTR -36+[ebp], eax
	mov	eax, DWORD PTR -36+[ebp]
	mov	DWORD PTR -40+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -40+[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _sItemKey$75546[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+12]
	cmp	esi, esp
	call	__chkesp
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76843[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 367  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sItemKey$75546[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L75544
$L75545:

; 368  : 	
; 369  : 	// item count
; 370  : 	WriteProfileInt(lpszSection, _T("ItemCount"), nCount);

	mov	esi, esp
	mov	ecx, DWORD PTR _nCount$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG75549
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__chkesp

; 371  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76844:
	lea	ecx, DWORD PTR _sItemKey$75546[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76845:
	lea	ecx, DWORD PTR $T76843[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76848:
	mov	eax, OFFSET FLAT:$T76847
	jmp	___CxxFrameHandler
text$x	ENDS
?WriteProfileArray@CPreferences@@QAEXPBGABVCStringArray@@@Z ENDP ; CPreferences::WriteProfileArray
PUBLIC	?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Lookup
EXTRN	?MakeUpper@CString@@QAEXXZ:NEAR			; CString::MakeUpper
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76861	DD	019930520H
	DD	02H
	DD	FLAT:$T76863
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76863	DD	0ffffffffH
	DD	FLAT:$L76855
	DD	00H
	DD	FLAT:$L76856
xdata$x	ENDS
;	COMDAT ?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z
_TEXT	SEGMENT
$T76858 = -32
__$EHRec$ = -12
_section$ = 12
_lpszEntry$ = 16
_lpszDefault$ = 20
___$ReturnUdt$ = 8
_sKey$75561 = -16
_ie$75562 = -28
?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z PROC NEAR ; CPreferences::GetEntryValue, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76862
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR $T76858[ebp], 0
$L75556:

; 375  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75559
	push	375					; 00000177H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75559
	int	3
$L75559:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75556

; 376  : 	
; 377  : 	// this is an internal method that assumes callers
; 378  : 	// have initialised a lock already
; 379  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 380  : 	
; 381  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75560

; 383  : 		CString sKey(lpszEntry);

	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 384  : 		sKey.MakeUpper();

	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	?MakeUpper@CString@@QAEXXZ		; CString::MakeUpper

; 385  : 		
; 386  : 		INIENTRY ie;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _ie$75562[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 387  : 		
; 388  : 		if (section.aEntries.Lookup(sKey, ie) && !ie.sValue.IsEmpty())

	lea	edx, DWORD PTR _ie$75562[ebp]
	push	edx
	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _section$[ebp]
	add	ecx, 4
	call	?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Lookup
	test	eax, eax
	je	SHORT $L75563
	lea	ecx, DWORD PTR _ie$75562[ebp+4]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	SHORT $L75563

; 389  : 			return ie.sValue;

	lea	eax, DWORD PTR _ie$75562[ebp+4]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	ecx, DWORD PTR $T76858[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76858[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ie$75562[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L75555
$L75563:

; 390  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ie$75562[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75560:

; 391  : 	
; 392  : 	return lpszDefault;

	mov	edx, DWORD PTR _lpszDefault$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	eax, DWORD PTR $T76858[ebp]
	or	al, 1
	mov	DWORD PTR $T76858[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L75555:

; 393  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76855:
	lea	ecx, DWORD PTR _sKey$75561[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76856:
	lea	ecx, DWORD PTR _ie$75562[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L76862:
	mov	eax, OFFSET FLAT:$T76861
	jmp	___CxxFrameHandler
text$x	ENDS
?GetEntryValue@CPreferences@@KA?AVCString@@ABUINISECTION@@PBG1@Z ENDP ; CPreferences::GetEntryValue
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76871	DD	019930520H
	DD	01H
	DD	FLAT:$T76873
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76873	DD	0ffffffffH
	DD	FLAT:$L76869
xdata$x	ENDS
;	COMDAT ?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z
_TEXT	SEGMENT
$T76868 = -24
__$EHRec$ = -12
_section$ = 8
_lpszEntry$ = 12
_szValue$ = 16
_bQuoted$ = 20
?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z PROC NEAR ; CPreferences::SetEntryValue, COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76872
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax

; 397  : 	SetEntryValue(section, INIENTRY(lpszEntry, szValue, bQuoted));

	mov	eax, DWORD PTR _bQuoted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T76868[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	DWORD PTR -28+[ebp], eax
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -32+[ebp]
	push	ecx
	mov	edx, DWORD PTR _section$[ebp]
	push	edx
	call	?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z ; CPreferences::SetEntryValue
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76868[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY

; 398  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76869:
	lea	ecx, DWORD PTR $T76868[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L76872:
	mov	eax, OFFSET FLAT:$T76871
	jmp	___CxxFrameHandler
text$x	ENDS
?SetEntryValue@CPreferences@@KAXAAUINISECTION@@PBG1H@Z ENDP ; CPreferences::SetEntryValue
PUBLIC	??8INIENTRY@@QBEHABU0@@Z			; INIENTRY::operator==
PUBLIC	??4INIENTRY@@QAEAAU0@ABU0@@Z			; INIENTRY::operator=
PUBLIC	??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::operator[]
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76881	DD	019930520H
	DD	02H
	DD	FLAT:$T76883
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76883	DD	0ffffffffH
	DD	FLAT:$L76878
	DD	00H
	DD	FLAT:$L76879
xdata$x	ENDS
;	COMDAT ?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_section$ = 8
_ie$ = 12
_ieExist$75580 = -28
_sKey$75581 = -16
?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z PROC NEAR ; CPreferences::SetEntryValue, COMDAT

; 401  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76882
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
$L75575:

; 402  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75578
	push	402					; 00000192H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75578
	int	3
$L75578:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75575

; 403  : 	
; 404  : 	// this is an internal method that assumes callers
; 405  : 	// have initialised a lock already
; 406  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 407  : 	
; 408  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75579

; 410  : 		INIENTRY ieExist;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _ieExist$75580[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 411  : 		CString sKey(ie.sName);

	mov	ecx, DWORD PTR _ie$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 412  : 		sKey.MakeUpper();

	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	?MakeUpper@CString@@QAEXXZ		; CString::MakeUpper

; 413  : 
; 414  : 		if (!section.aEntries.Lookup(sKey, ieExist) || !(ie == ieExist))

	lea	edx, DWORD PTR _ieExist$75580[ebp]
	push	edx
	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _section$[ebp]
	add	ecx, 4
	call	?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Lookup
	test	eax, eax
	je	SHORT $L75583
	lea	eax, DWORD PTR _ieExist$75580[ebp]
	push	eax
	mov	ecx, DWORD PTR _ie$[ebp]
	call	??8INIENTRY@@QBEHABU0@@Z		; INIENTRY::operator==
	test	eax, eax
	jne	SHORT $L75582
$L75583:

; 416  : 			section.aEntries[sKey] = ie;

	mov	ecx, DWORD PTR _ie$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _section$[ebp]
	add	ecx, 4
	call	??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::operator[]
	mov	ecx, eax
	call	??4INIENTRY@@QAEAAU0@ABU0@@Z		; INIENTRY::operator=

; 417  : 			s_bDirty = TRUE;

	mov	DWORD PTR ?s_bDirty@CPreferences@@1HA, 1 ; CPreferences::s_bDirty
$L75582:

; 419  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ieExist$75580[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
$L75579:

; 420  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76878:
	lea	ecx, DWORD PTR _ieExist$75580[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L76879:
	lea	ecx, DWORD PTR _sKey$75581[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76882:
	mov	eax, OFFSET FLAT:$T76881
	jmp	___CxxFrameHandler
text$x	ENDS
?SetEntryValue@CPreferences@@KAXAAUINISECTION@@ABUINIENTRY@@@Z ENDP ; CPreferences::SetEntryValue
EXTRN	??8@YG_NABVCString@@0@Z:NEAR			; operator==
;	COMDAT ??8INIENTRY@@QBEHABU0@@Z
_TEXT	SEGMENT
_ie$ = 8
_this$ = -4
??8INIENTRY@@QBEHABU0@@Z PROC NEAR			; INIENTRY::operator==, COMDAT

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		return ((sName == ie.sName) && 
; 60   : 				(sValue == ie.sValue) && 
; 61   : 				(bQuoted == ie.bQuoted));

	mov	eax, DWORD PTR _ie$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??8@YG_NABVCString@@0@Z			; operator==
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76888
	mov	edx, DWORD PTR _ie$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??8@YG_NABVCString@@0@Z			; operator==
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L76888
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ie$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $L76888
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L76889
$L76888:
	mov	DWORD PTR -8+[ebp], 0
$L76889:
	mov	eax, DWORD PTR -8+[ebp]

; 62   : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??8INIENTRY@@QBEHABU0@@Z ENDP				; INIENTRY::operator==
_TEXT	ENDS
;	COMDAT ??4INIENTRY@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4INIENTRY@@QAEAAU0@ABU0@@Z PROC NEAR			; INIENTRY::operator=, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??4INIENTRY@@QAEAAU0@ABU0@@Z ENDP			; INIENTRY::operator=
_TEXT	ENDS
PUBLIC	?FindSection@CPreferences@@KAHPBGH@Z		; CPreferences::FindSection
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76900	DD	019930520H
	DD	01H
	DD	FLAT:$T76902
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76902	DD	0ffffffffH
	DD	FLAT:$L76898
xdata$x	ENDS
;	COMDAT ?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z
_TEXT	SEGMENT
$T76894 = -24
$T76895 = -28
__$EHRec$ = -12
_lpszSection$ = 8
_bCreateNotExist$ = 12
_nSection$75596 = -16
_pSection$75599 = -20
?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z PROC NEAR ; CPreferences::GetSection, COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76901
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
$L75591:

; 424  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75594
	push	424					; 000001a8H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75594
	int	3
$L75594:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75591

; 425  : 	
; 426  : 	// this is an internal method that assumes callers
; 427  : 	// have initialised a lock already
; 428  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 429  : 	
; 430  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75598

; 432  : 		int nSection = FindSection(lpszSection);

	push	0
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?FindSection@CPreferences@@KAHPBGH@Z	; CPreferences::FindSection
	add	esp, 8
	mov	DWORD PTR _nSection$75596[ebp], eax

; 433  : 
; 434  : 		if (nSection != -1)

	cmp	DWORD PTR _nSection$75596[ebp], -1
	je	SHORT $L75597

; 435  : 			return s_aIni[nSection];

	mov	edx, DWORD PTR _nSection$75596[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $L75590
$L75597:

; 436  : 		
; 437  : 		// add a new section
; 438  : 		if (bCreateNotExist)

	cmp	DWORD PTR _bCreateNotExist$[ebp], 0
	je	SHORT $L75598

; 440  : 			INISECTION* pSection = new INISECTION(lpszSection);

	push	440					; 000001b8H
	push	OFFSET FLAT:_THIS_FILE
	push	32					; 00000020H
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T76895[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76895[ebp], 0
	je	SHORT $L76896
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T76895[ebp]
	call	??0INISECTION@@QAE@PBG@Z		; INISECTION::INISECTION
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L76897
$L76896:
	mov	DWORD PTR -32+[ebp], 0
$L76897:
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR $T76894[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T76894[ebp]
	mov	DWORD PTR _pSection$75599[ebp], edx

; 441  : 			
; 442  : 			s_aIni.Add(pSection);

	mov	eax, DWORD PTR _pSection$75599[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z ; CArray<INISECTION *,INISECTION *>::Add

; 443  : 			return pSection;

	mov	eax, DWORD PTR _pSection$75599[ebp]
	jmp	SHORT $L75590
$L75598:

; 446  : 	
; 447  : 	// else
; 448  : 	return NULL;

	xor	eax, eax
$L75590:

; 449  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76898:
	push	440					; 000001b8H
	push	OFFSET FLAT:_THIS_FILE
	mov	eax, DWORD PTR $T76895[ebp]
	push	eax
	call	??3@YAXPAXPBDH@Z			; operator delete
	add	esp, 12					; 0000000cH
	ret	0
$L76901:
	mov	eax, OFFSET FLAT:$T76900
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ENDP	; CPreferences::GetSection
EXTRN	?CompareNoCase@CString@@QBEHPBG@Z:NEAR		; CString::CompareNoCase
EXTRN	__imp__lstrlenW@4:NEAR
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76910	DD	019930520H
	DD	01H
	DD	FLAT:$T76912
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76912	DD	0ffffffffH
	DD	FLAT:$L76908
xdata$x	ENDS
;	COMDAT ?FindSection@CPreferences@@KAHPBGH@Z
_TEXT	SEGMENT
$T76907 = -32
__$EHRec$ = -12
_lpszSection$ = 8
_bIncSubSections$ = 12
_nLenSection$75615 = -20
_nSection$75616 = -16
_sSection$75620 = -24
_sTest$75627 = -28
?FindSection@CPreferences@@KAHPBGH@Z PROC NEAR		; CPreferences::FindSection, COMDAT

; 452  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76911
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
$L75610:

; 453  : 	ASSERT(s_bIni);

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	jne	SHORT $L75613
	push	453					; 000001c5H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75613
	int	3
$L75613:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75610

; 454  : 	
; 455  : 	// this is an internal method that assumes callers
; 456  : 	// have initialised a lock already
; 457  : //	VERIFY(::TryEnterCriticalSection(s_cs));
; 458  : 
; 459  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75619

; 461  : 		int nLenSection = lstrlen(lpszSection);

	mov	esi, esp
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _nLenSection$75615[ebp], eax

; 462  : 		int nSection = s_aIni.GetSize();

	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ ; CArray<INISECTION *,INISECTION *>::GetSize
	mov	DWORD PTR _nSection$75616[ebp], eax
$L75618:

; 463  : 		
; 464  : 		while (nSection--)

	mov	edx, DWORD PTR _nSection$75616[ebp]
	mov	eax, DWORD PTR _nSection$75616[ebp]
	sub	eax, 1
	mov	DWORD PTR _nSection$75616[ebp], eax
	test	edx, edx
	je	$L75619

; 466  : 			const CString& sSection = s_aIni[nSection]->sSection;

	mov	ecx, DWORD PTR _nSection$75616[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _sSection$75620[ebp], edx

; 467  : 
; 468  : 			if (sSection.GetLength() < nLenSection)

	mov	ecx, DWORD PTR _sSection$75620[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	cmp	eax, DWORD PTR _nLenSection$75615[ebp]
	jge	SHORT $L75621

; 469  : 				continue;

	jmp	SHORT $L75618
$L75621:

; 470  : 			
; 471  : 			else if (sSection.GetLength() == nLenSection)

	mov	ecx, DWORD PTR _sSection$75620[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	cmp	eax, DWORD PTR _nLenSection$75615[ebp]
	jne	SHORT $L75623

; 473  : 				if (sSection.CompareNoCase(lpszSection) == 0)

	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sSection$75620[ebp]
	call	?CompareNoCase@CString@@QBEHPBG@Z	; CString::CompareNoCase
	test	eax, eax
	jne	SHORT $L75624

; 474  : 					return nSection;

	mov	eax, DWORD PTR _nSection$75616[ebp]
	jmp	SHORT $L75609
$L75624:

; 476  : 			else // sSection.GetLength() > nLenSection

	jmp	SHORT $L75626
$L75623:

; 478  : 				if (bIncSubSections)

	cmp	DWORD PTR _bIncSubSections$[ebp], 0
	je	SHORT $L75626

; 480  : 					// look for parent section at head of subsection
; 481  : 					CString sTest = sSection.Left(nLenSection);

	mov	ecx, DWORD PTR _nLenSection$75615[ebp]
	push	ecx
	lea	edx, DWORD PTR _sTest$75627[ebp]
	push	edx
	mov	ecx, DWORD PTR _sSection$75620[ebp]
	call	?Left@CString@@QBE?AV1@H@Z		; CString::Left
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 482  : 
; 483  : 					if (sTest.CompareNoCase(lpszSection) == 0)

	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sTest$75627[ebp]
	call	?CompareNoCase@CString@@QBEHPBG@Z	; CString::CompareNoCase
	test	eax, eax
	jne	SHORT $L75629

; 484  : 						return nSection;

	mov	ecx, DWORD PTR _nSection$75616[ebp]
	mov	DWORD PTR $T76907[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sTest$75627[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76907[ebp]
	jmp	SHORT $L75609
$L75629:

; 485  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sTest$75627[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75626:

; 487  : 		}

	jmp	$L75618
$L75619:

; 489  : 
; 490  : 	// not found
; 491  : 	return -1;

	or	eax, -1
$L75609:

; 492  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76908:
	lea	ecx, DWORD PTR _sTest$75627[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76911:
	mov	eax, OFFSET FLAT:$T76910
	jmp	___CxxFrameHandler
text$x	ENDS
?FindSection@CPreferences@@KAHPBGH@Z ENDP		; CPreferences::FindSection
PUBLIC	?DeleteSection@CPreferences@@QAEHPBGH@Z		; CPreferences::DeleteSection
PUBLIC	?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::RemoveAt
EXTRN	?DeleteKey@CRegKey@@SAJPAUHKEY__@@PBG@Z:NEAR	; CRegKey::DeleteKey
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75656 DB	'%', 00H, 's', 00H, '\', 00H, '%', 00H, 's', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76931	DD	019930520H
	DD	02H
	DD	FLAT:$T76933
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76933	DD	0ffffffffH
	DD	FLAT:$L76928
	DD	0ffffffffH
	DD	FLAT:$L76929
xdata$x	ENDS
;	COMDAT ?DeleteSection@CPreferences@@QAEHPBGH@Z
_TEXT	SEGMENT
$T76917 = -36
$T76918 = -40
$T76921 = -44
$T76922 = -48
$T76925 = -52
$T76926 = -56
$T76927 = -60
__$EHRec$ = -12
_lpszSection$ = 8
_bIncSubSections$ = 12
_this$ = -64
_lock$75642 = -28
_nSection$75643 = -32
_sFullKey$ = -16
?DeleteSection@CPreferences@@QAEHPBGH@Z PROC NEAR	; CPreferences::DeleteSection, COMDAT

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76932
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L75636:

; 496  : 	ASSERT(lpszSection && *lpszSection);

	cmp	DWORD PTR _lpszSection$[ebp], 0
	je	SHORT $L75640
	mov	eax, DWORD PTR _lpszSection$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $L75639
$L75640:
	push	496					; 000001f0H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75639
	int	3
$L75639:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75636

; 497  : 
; 498  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75641

; 500  : 		// prevent anyone else changing the shared resources
; 501  : 		// for the duration of this function
; 502  : 		CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$75642[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 503  : 		
; 504  : 		int nSection = FindSection(lpszSection);

	push	0
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?FindSection@CPreferences@@KAHPBGH@Z	; CPreferences::FindSection
	add	esp, 8
	mov	DWORD PTR _nSection$75643[ebp], eax

; 505  : 		 
; 506  : 		if (nSection != -1)

	cmp	DWORD PTR _nSection$75643[ebp], -1
	je	$L75644

; 508  : 			delete s_aIni[nSection];

	mov	ecx, DWORD PTR _nSection$75643[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T76918[ebp], edx
	mov	eax, DWORD PTR $T76918[ebp]
	mov	DWORD PTR $T76917[ebp], eax
	cmp	DWORD PTR $T76917[ebp], 0
	je	SHORT $L76919
	push	1
	mov	ecx, DWORD PTR $T76917[ebp]
	call	??_GINISECTION@@QAEPAXI@Z		; INISECTION::`scalar deleting destructor'
	mov	DWORD PTR -68+[ebp], eax
	jmp	SHORT $L76920
$L76919:
	mov	DWORD PTR -68+[ebp], 0
$L76920:

; 509  : 			s_aIni.RemoveAt(nSection);

	push	1
	mov	ecx, DWORD PTR _nSection$75643[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::RemoveAt

; 510  : 			s_bDirty = TRUE;

	mov	DWORD PTR ?s_bDirty@CPreferences@@1HA, 1 ; CPreferences::s_bDirty

; 511  : 			
; 512  : 			if (bIncSubSections)

	cmp	DWORD PTR _bIncSubSections$[ebp], 0
	je	SHORT $L75650

; 514  : 				nSection = FindSection(lpszSection, TRUE);

	push	1
	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	call	?FindSection@CPreferences@@KAHPBGH@Z	; CPreferences::FindSection
	add	esp, 8
	mov	DWORD PTR _nSection$75643[ebp], eax
$L75649:

; 515  : 
; 516  : 				while (nSection != -1)

	cmp	DWORD PTR _nSection$75643[ebp], -1
	je	SHORT $L75650

; 518  : 					delete s_aIni[nSection];

	mov	eax, DWORD PTR _nSection$75643[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T76922[ebp], ecx
	mov	edx, DWORD PTR $T76922[ebp]
	mov	DWORD PTR $T76921[ebp], edx
	cmp	DWORD PTR $T76921[ebp], 0
	je	SHORT $L76923
	push	1
	mov	ecx, DWORD PTR $T76921[ebp]
	call	??_GINISECTION@@QAEPAXI@Z		; INISECTION::`scalar deleting destructor'
	mov	DWORD PTR -72+[ebp], eax
	jmp	SHORT $L76924
$L76923:
	mov	DWORD PTR -72+[ebp], 0
$L76924:

; 519  : 					s_aIni.RemoveAt(nSection);

	push	1
	mov	eax, DWORD PTR _nSection$75643[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::RemoveAt

; 520  : 					nSection = FindSection(lpszSection, TRUE);

	push	1
	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?FindSection@CPreferences@@KAHPBGH@Z	; CPreferences::FindSection
	add	esp, 8
	mov	DWORD PTR _nSection$75643[ebp], eax

; 521  : 				} 

	jmp	SHORT $L75649
$L75650:

; 523  : 
; 524  : 			return TRUE;

	mov	DWORD PTR $T76925[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75642[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76925[ebp]
	jmp	SHORT $L75635
$L75644:

; 526  : 
; 527  : 		// not found
; 528  : 		return FALSE;

	mov	DWORD PTR $T76926[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75642[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76926[ebp]
	jmp	SHORT $L75635
$L75641:

; 530  : 
; 531  : 	// else registry
; 532  : 	CString sFullKey;

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 533  : 	sFullKey.Format(_T("%s\\%s"), AfxGetApp()->m_pszRegistryKey, lpszSection);

	mov	edx, DWORD PTR _lpszSection$[ebp]
	push	edx
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	eax, DWORD PTR [eax+132]
	push	eax
	push	OFFSET FLAT:$SG75656
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 534  : 
; 535  : 	return CRegKey::DeleteKey(HKEY_CURRENT_USER, sFullKey);

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	push	-2147483647				; 80000001H
	call	?DeleteKey@CRegKey@@SAJPAUHKEY__@@PBG@Z	; CRegKey::DeleteKey
	add	esp, 8
	mov	DWORD PTR $T76927[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76927[ebp]
$L75635:

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 72					; 00000048H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76928:
	lea	ecx, DWORD PTR _lock$75642[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76929:
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76932:
	mov	eax, OFFSET FLAT:$T76931
	jmp	___CxxFrameHandler
text$x	ENDS
?DeleteSection@CPreferences@@QAEHPBGH@Z ENDP		; CPreferences::DeleteSection
PUBLIC	?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveKey
PUBLIC	?DeleteEntry@CPreferences@@QAEHPBG0@Z		; CPreferences::DeleteEntry
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75682 DB	'%', 00H, 's', 00H, '\', 00H, '%', 00H, 's', 00H, '\', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76946	DD	019930520H
	DD	03H
	DD	FLAT:$T76948
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76948	DD	0ffffffffH
	DD	FLAT:$L76942
	DD	00H
	DD	FLAT:$L76943
	DD	0ffffffffH
	DD	FLAT:$L76944
xdata$x	ENDS
;	COMDAT ?DeleteEntry@CPreferences@@QAEHPBG0@Z
_TEXT	SEGMENT
$T76939 = -40
$T76940 = -44
$T76941 = -48
__$EHRec$ = -12
_lpszSection$ = 8
_lpszEntry$ = 12
_this$ = -52
_lock$75675 = -28
_pSection$75676 = -32
_sKey$75678 = -36
_sFullKey$ = -16
?DeleteEntry@CPreferences@@QAEHPBG0@Z PROC NEAR		; CPreferences::DeleteEntry, COMDAT

; 539  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76947
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$L75664:

; 540  : 	ASSERT(lpszSection && *lpszSection);

	cmp	DWORD PTR _lpszSection$[ebp], 0
	je	SHORT $L75668
	mov	eax, DWORD PTR _lpszSection$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $L75667
$L75668:
	push	540					; 0000021cH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75667
	int	3
$L75667:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75664
$L75666:

; 541  : 	ASSERT(lpszEntry && *lpszEntry);

	cmp	DWORD PTR _lpszEntry$[ebp], 0
	je	SHORT $L75673
	mov	eax, DWORD PTR _lpszEntry$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $L75672
$L75673:
	push	541					; 0000021dH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75672
	int	3
$L75672:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75666

; 542  : 
; 543  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	$L75674

; 545  : 		// prevent anyone else changing the shared resources
; 546  : 		// for the duration of this function
; 547  : 		CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$75675[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 548  : 		
; 549  : 		INISECTION* pSection = GetSection(lpszSection, FALSE);

	push	0
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
	add	esp, 8
	mov	DWORD PTR _pSection$75676[ebp], eax

; 550  : 
; 551  : 		if (pSection)

	cmp	DWORD PTR _pSection$75676[ebp], 0
	je	SHORT $L75677

; 553  : 			CString sKey(lpszEntry);

	mov	ecx, DWORD PTR _lpszEntry$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$75678[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 554  : 			sKey.MakeUpper();

	lea	ecx, DWORD PTR _sKey$75678[ebp]
	call	?MakeUpper@CString@@QAEXXZ		; CString::MakeUpper

; 555  : 
; 556  : 			pSection->aEntries.RemoveKey(sKey);

	lea	ecx, DWORD PTR _sKey$75678[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _pSection$75676[ebp]
	add	ecx, 4
	call	?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveKey

; 557  : 			s_bDirty = TRUE;

	mov	DWORD PTR ?s_bDirty@CPreferences@@1HA, 1 ; CPreferences::s_bDirty

; 558  : 
; 559  : 			return TRUE;

	mov	DWORD PTR $T76939[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sKey$75678[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75675[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76939[ebp]
	jmp	SHORT $L75663
$L75677:

; 561  : 
; 562  : 		// not found
; 563  : 		return FALSE;

	mov	DWORD PTR $T76940[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75675[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76940[ebp]
	jmp	SHORT $L75663
$L75674:

; 565  : 
; 566  : 	// else registry
; 567  : 	CString sFullKey;

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 568  : 	sFullKey.Format(_T("%s\\%s\\%s"), AfxGetApp()->m_pszRegistryKey, lpszSection, lpszEntry);

	mov	edx, DWORD PTR _lpszEntry$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	push	OFFSET FLAT:$SG75682
	lea	edx, DWORD PTR _sFullKey$[ebp]
	push	edx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 20					; 00000014H

; 569  : 
; 570  : 	return CRegKey::DeleteKey(HKEY_CURRENT_USER, sFullKey);

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	push	-2147483647				; 80000001H
	call	?DeleteKey@CRegKey@@SAJPAUHKEY__@@PBG@Z	; CRegKey::DeleteKey
	add	esp, 8
	mov	DWORD PTR $T76941[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76941[ebp]
$L75663:

; 571  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76942:
	lea	ecx, DWORD PTR _lock$75675[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76943:
	lea	ecx, DWORD PTR _sKey$75678[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76944:
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76947:
	mov	eax, OFFSET FLAT:$T76946
	jmp	___CxxFrameHandler
text$x	ENDS
?DeleteEntry@CPreferences@@QAEHPBG0@Z ENDP		; CPreferences::DeleteEntry
PUBLIC	?HasSection@CPreferences@@QBEHPBG@Z		; CPreferences::HasSection
EXTRN	?KeyExists@CRegKey@@SAHPAUHKEY__@@PBG@Z:NEAR	; CRegKey::KeyExists
;	COMDAT data
; File D:\_CODE\Shared\Preferences.cpp
data	SEGMENT
$SG75693 DB	'%', 00H, 's', 00H, '\', 00H, '%', 00H, 's', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T76959	DD	019930520H
	DD	02H
	DD	FLAT:$T76961
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76961	DD	0ffffffffH
	DD	FLAT:$L76956
	DD	0ffffffffH
	DD	FLAT:$L76957
xdata$x	ENDS
;	COMDAT ?HasSection@CPreferences@@QBEHPBG@Z
_TEXT	SEGMENT
$T76954 = -32
$T76955 = -36
__$EHRec$ = -12
_lpszSection$ = 8
_this$ = -40
_lock$75690 = -28
_sFullKey$ = -16
?HasSection@CPreferences@@QBEHPBG@Z PROC NEAR		; CPreferences::HasSection, COMDAT

; 574  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76960
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75689

; 577  : 		// prevent anyone else changing the shared resources
; 578  : 		// for the duration of this function
; 579  : 		CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$75690[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 580  : 		
; 581  : 		return (GetSection(lpszSection, FALSE) != NULL);

	push	0
	mov	eax, DWORD PTR _lpszSection$[ebp]
	push	eax
	call	?GetSection@CPreferences@@KAPAUINISECTION@@PBGH@Z ; CPreferences::GetSection
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	DWORD PTR $T76954[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$75690[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76954[ebp]
	jmp	SHORT $L75688
$L75689:

; 583  : 
; 584  : 	// else registry
; 585  : 	CString sFullKey;

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 586  : 	sFullKey.Format(_T("%s\\%s"), AfxGetApp()->m_pszRegistryKey, lpszSection);

	mov	ecx, DWORD PTR _lpszSection$[ebp]
	push	ecx
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	edx, DWORD PTR [eax+132]
	push	edx
	push	OFFSET FLAT:$SG75693
	lea	eax, DWORD PTR _sFullKey$[ebp]
	push	eax
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 587  : 
; 588  : 	return CRegKey::KeyExists(HKEY_CURRENT_USER, sFullKey);

	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	push	-2147483647				; 80000001H
	call	?KeyExists@CRegKey@@SAHPAUHKEY__@@PBG@Z	; CRegKey::KeyExists
	add	esp, 8
	mov	DWORD PTR $T76955[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T76955[ebp]
$L75688:

; 589  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76956:
	lea	ecx, DWORD PTR _lock$75690[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76957:
	lea	ecx, DWORD PTR _sFullKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76960:
	mov	eax, OFFSET FLAT:$T76959
	jmp	___CxxFrameHandler
text$x	ENDS
?HasSection@CPreferences@@QBEHPBG@Z ENDP		; CPreferences::HasSection
PUBLIC	?GetSectionNames@CPreferences@@QAEHAAVCStringArray@@@Z ; CPreferences::GetSectionNames
EXTRN	??ACStringArray@@QAEAAVCString@@H@Z:NEAR	; CStringArray::operator[]
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76970	DD	019930520H
	DD	01H
	DD	FLAT:$T76972
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76972	DD	0ffffffffH
	DD	FLAT:$L76968
xdata$x	ENDS
;	COMDAT ?GetSectionNames@CPreferences@@QAEHAAVCStringArray@@@Z
_TEXT	SEGMENT
$T76967 = -32
__$EHRec$ = -12
_aSections$ = 8
_this$ = -36
_lock$ = -24
_nSection$75702 = -28
?GetSectionNames@CPreferences@@QAEHAAVCStringArray@@@Z PROC NEAR ; CPreferences::GetSectionNames, COMDAT

; 592  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76971
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 	// prevent anyone else changing the shared resources
; 594  : 	// for the duration of this function
; 595  : 	CSingleLock lock(&s_cs, TRUE);

	push	1
	push	OFFSET FLAT:?s_cs@CPreferences@@1VCCriticalSection@@A ; CPreferences::s_cs
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??0CSingleLock@@QAE@PAVCSyncObject@@H@Z	; CSingleLock::CSingleLock
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 596  : 	
; 597  : 	aSections.RemoveAll();

	mov	ecx, DWORD PTR _aSections$[ebp]
	call	?RemoveAll@CStringArray@@QAEXXZ		; CStringArray::RemoveAll

; 598  : 
; 599  : 	if (s_bIni)

	cmp	DWORD PTR ?s_bIni@CPreferences@@1HA, 0	; CPreferences::s_bIni
	je	SHORT $L75705

; 601  : 		int nSection = s_aIni.GetSize();

	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ ; CArray<INISECTION *,INISECTION *>::GetSize
	mov	DWORD PTR _nSection$75702[ebp], eax

; 602  : 		aSections.SetSize(nSection);

	push	-1
	mov	eax, DWORD PTR _nSection$75702[ebp]
	push	eax
	mov	ecx, DWORD PTR _aSections$[ebp]
	call	?SetSize@CStringArray@@QAEXHH@Z		; CStringArray::SetSize
$L75704:

; 603  : 		
; 604  : 		while (nSection--)

	mov	ecx, DWORD PTR _nSection$75702[ebp]
	mov	edx, DWORD PTR _nSection$75702[ebp]
	sub	edx, 1
	mov	DWORD PTR _nSection$75702[ebp], edx
	test	ecx, ecx
	je	SHORT $L75705

; 605  : 			aSections[nSection] = s_aIni[nSection]->sSection;

	mov	eax, DWORD PTR _nSection$75702[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?s_aIni@CPreferences@@1V?$CArray@PAUINISECTION@@PAU1@@@A
	call	??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _nSection$75702[ebp]
	push	edx
	mov	ecx, DWORD PTR _aSections$[ebp]
	call	??ACStringArray@@QAEAAVCString@@H@Z	; CStringArray::operator[]
	mov	ecx, eax
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	jmp	SHORT $L75704
$L75705:

; 607  : 
; 608  : 	return aSections.GetSize();

	mov	ecx, DWORD PTR _aSections$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize
	mov	DWORD PTR $T76967[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	mov	eax, DWORD PTR $T76967[ebp]

; 609  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76968:
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1CSingleLock@@QAE@XZ			; CSingleLock::~CSingleLock
	ret	0
$L76971:
	mov	eax, OFFSET FLAT:$T76970
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSectionNames@CPreferences@@QAEHAAVCStringArray@@@Z ENDP ; CPreferences::GetSectionNames
PUBLIC	?KeyFromFile@CPreferences@@SA?AVCString@@PBGH@Z	; CPreferences::KeyFromFile
EXTRN	?GetFileNameFromPath@FileMisc@@YA?AVCString@@PBGH@Z:NEAR ; FileMisc::GetFileNameFromPath
EXTRN	?GetPathType@CDriveInfo@@SAHPBG@Z:NEAR		; CDriveInfo::GetPathType
EXTRN	?Replace@CString@@QAEHGG@Z:NEAR			; CString::Replace
;	COMDAT xdata$x
; File D:\_CODE\Shared\Preferences.cpp
xdata$x	SEGMENT
$T76995	DD	019930520H
	DD	07H
	DD	FLAT:$T76997
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T76997	DD	0ffffffffH
	DD	FLAT:$L76992
	DD	00H
	DD	FLAT:$L76984
	DD	01H
	DD	FLAT:$L76986
	DD	02H
	DD	FLAT:$L76988
	DD	00H
	DD	FLAT:$L76988
	DD	04H
	DD	FLAT:$L76986
	DD	04H
	DD	FLAT:$L76991
xdata$x	ENDS
;	COMDAT ?KeyFromFile@CPreferences@@SA?AVCString@@PBGH@Z
_TEXT	SEGMENT
$T76977 = -24
$T76978 = -28
$T76979 = -32
$T76982 = -36
$T76983 = -40
__$EHRec$ = -12
_szFilePath$ = 12
_bFileNameOnly$ = 16
___$ReturnUdt$ = 8
_sKey$ = -16
_nType$75717 = -20
?KeyFromFile@CPreferences@@SA?AVCString@@PBGH@Z PROC NEAR ; CPreferences::KeyFromFile, COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L76996
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T76983[ebp], 0

; 613  : 	CString sKey = (bFileNameOnly ? FileMisc::GetFileNameFromPath(szFilePath) : szFilePath);

	cmp	DWORD PTR _bFileNameOnly$[ebp], 0
	je	SHORT $L76980
	push	1
	mov	eax, DWORD PTR _szFilePath$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76978[ebp]
	push	ecx
	call	?GetFileNameFromPath@FileMisc@@YA?AVCString@@PBGH@Z ; FileMisc::GetFileNameFromPath
	add	esp, 12					; 0000000cH
	mov	DWORD PTR -44+[ebp], eax
	mov	edx, DWORD PTR $T76983[ebp]
	or	edx, 1
	mov	DWORD PTR $T76983[ebp], edx
	mov	eax, DWORD PTR -44+[ebp]
	mov	DWORD PTR -48+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR -52+[ebp], ecx
	jmp	SHORT $L76981
$L76980:
	mov	edx, DWORD PTR _szFilePath$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T76979[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR -56+[ebp], eax
	mov	eax, DWORD PTR $T76983[ebp]
	or	al, 2
	mov	DWORD PTR $T76983[ebp], eax
	mov	ecx, DWORD PTR -56+[ebp]
	mov	DWORD PTR -60+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR -60+[ebp]
	mov	DWORD PTR -52+[ebp], edx
$L76981:
	mov	eax, DWORD PTR -52+[ebp]
	mov	DWORD PTR $T76977[ebp], eax
	mov	ecx, DWORD PTR $T76977[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T76983[ebp]
	and	edx, 2
	test	edx, edx
	je	SHORT $L76989
	and	DWORD PTR $T76983[ebp], -3		; fffffffdH
	lea	ecx, DWORD PTR $T76979[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76989:
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR $T76983[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76990
	and	DWORD PTR $T76983[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T76978[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76990:

; 614  : 	sKey.Replace('\\', '_');

	push	95					; 0000005fH
	push	92					; 0000005cH
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	?Replace@CString@@QAEHGG@Z		; CString::Replace

; 615  : 
; 616  : 	// if the filepath is on a removable drive then we strip off the drive letter
; 617  : 	if (!bFileNameOnly)

	cmp	DWORD PTR _bFileNameOnly$[ebp], 0
	jne	SHORT $L75718

; 619  : 		int nType = CDriveInfo::GetPathType(szFilePath);

	mov	ecx, DWORD PTR _szFilePath$[ebp]
	push	ecx
	call	?GetPathType@CDriveInfo@@SAHPBG@Z	; CDriveInfo::GetPathType
	add	esp, 4
	mov	DWORD PTR _nType$75717[ebp], eax

; 620  : 
; 621  : 		if (nType == DRIVE_REMOVABLE)

	cmp	DWORD PTR _nType$75717[ebp], 2
	jne	SHORT $L75718

; 622  : 			sKey = sKey.Mid(1);

	push	1
	lea	edx, DWORD PTR $T76982[ebp]
	push	edx
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	?Mid@CString@@QBE?AV1@H@Z		; CString::Mid
	mov	DWORD PTR -64+[ebp], eax
	mov	eax, DWORD PTR -64+[ebp]
	mov	DWORD PTR -68+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR -68+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T76982[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75718:

; 624  : 
; 625  : 	return sKey;

	lea	edx, DWORD PTR _sKey$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	eax, DWORD PTR $T76983[ebp]
	or	al, 4
	mov	DWORD PTR $T76983[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 626  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L76984:
	mov	eax, DWORD PTR $T76983[ebp]
	and	eax, 1
	test	eax, eax
	je	$L76985
	lea	ecx, DWORD PTR $T76978[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76985:
	ret	0
$L76986:
	mov	eax, DWORD PTR $T76983[ebp]
	and	eax, 2
	test	eax, eax
	je	$L76987
	lea	ecx, DWORD PTR $T76979[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76987:
	ret	0
$L76988:
	lea	ecx, DWORD PTR _sKey$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76991:
	lea	ecx, DWORD PTR $T76982[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L76992:
	mov	eax, DWORD PTR $T76983[ebp]
	and	eax, 4
	test	eax, eax
	je	$L76993
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76993:
	ret	0
$L76996:
	mov	eax, OFFSET FLAT:$T76995
	jmp	___CxxFrameHandler
text$x	ENDS
?KeyFromFile@CPreferences@@SA?AVCString@@PBGH@Z ENDP	; CPreferences::KeyFromFile
PUBLIC	?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Serialize
PUBLIC	?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Dump
PUBLIC	?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::AssertValid
PUBLIC	??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@	; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`vftable'
PUBLIC	??_G?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`scalar deleting destructor'
PUBLIC	??_E?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CObject::GetRuntimeClass
EXTRN	??1CObject@@UAE@XZ:NEAR				; CObject::~CObject
EXTRN	??0CObject@@IAE@XZ:NEAR				; CObject::CObject
;	COMDAT ??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
CONST	SEGMENT
??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@ DD FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`vftable'
	DD	FLAT:??_E?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ
	DD	FLAT:?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T77004	DD	019930520H
	DD	01H
	DD	FLAT:$T77006
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77006	DD	0ffffffffH
	DD	FLAT:$L77002
xdata$x	ENDS
;	COMDAT ??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z
_TEXT	SEGMENT
_nBlockSize$ = 8
_this$ = -16
__$EHRec$ = -12
??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>, COMDAT

; 1201 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77005
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CObject@@IAE@XZ			; CObject::CObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`vftable'
$L75808:

; 1202 : 	ASSERT(nBlockSize > 0);

	cmp	DWORD PTR _nBlockSize$[ebp], 0
	jg	SHORT $L75811
	push	1202					; 000004b2H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75811
	int	3
$L75811:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75808

; 1203 : 
; 1204 : 	m_pHashTable = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1205 : 	m_nHashTableSize = 17;  // default size

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 17			; 00000011H

; 1206 : 	m_nCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1207 : 	m_pFreeList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1208 : 	m_pBlocks = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1209 : 	m_nBlockSize = nBlockSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nBlockSize$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 1210 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77002:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L77005:
	mov	eax, OFFSET FLAT:$T77004
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAE@H@Z ENDP	; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
;	COMDAT ?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetCount, COMDAT

; 1182 : 	{ return m_nCount; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCount@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHXZ ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetCount
_TEXT	ENDS
PUBLIC	?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetAssocAt
EXTRN	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z:NEAR ; AfxAssertValidObject
;	COMDAT ?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z
_TEXT	SEGMENT
_key$ = 8
_rValue$ = 12
_this$ = -12
_nHash$ = -8
_pAssoc$ = -4
?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Lookup, COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1342 : 	ASSERT_VALID(this);

	push	1342					; 0000053eH
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1343 : 
; 1344 : 	UINT nHash;
; 1345 : 	CAssoc* pAssoc = GetAssocAt(key, nHash);

	lea	ecx, DWORD PTR _nHash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetAssocAt
	mov	DWORD PTR _pAssoc$[ebp], eax

; 1346 : 	if (pAssoc == NULL)

	cmp	DWORD PTR _pAssoc$[ebp], 0
	jne	SHORT $L75822

; 1347 : 		return FALSE;  // not in map

	xor	eax, eax
	jmp	SHORT $L75819
$L75822:

; 1348 : 
; 1349 : 	rValue = pAssoc->value;

	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _rValue$[ebp]
	call	??4INIENTRY@@QAEAAU0@ABU0@@Z		; INIENTRY::operator=

; 1350 : 	return TRUE;

	mov	eax, 1
$L75819:

; 1351 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?Lookup@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEHPBGAAUINIENTRY@@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Lookup
_TEXT	ENDS
PUBLIC	?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::NewAssoc
EXTRN	??4CString@@QAEABV0@PBG@Z:NEAR			; CString::operator=
;	COMDAT ??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z
_TEXT	SEGMENT
_key$ = 8
_this$ = -12
_nHash$ = -8
_pAssoc$ = -4
??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::operator[], COMDAT

; 1355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1356 : 	ASSERT_VALID(this);

	push	1356					; 0000054cH
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1357 : 
; 1358 : 	UINT nHash;
; 1359 : 	CAssoc* pAssoc;
; 1360 : 	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)

	lea	ecx, DWORD PTR _nHash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetAssocAt
	mov	DWORD PTR _pAssoc$[ebp], eax
	cmp	DWORD PTR _pAssoc$[ebp], 0
	jne	SHORT $L75829

; 1362 : 		if (m_pHashTable == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L75830

; 1363 : 			InitHashTable(m_nHashTableSize);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::InitHashTable
$L75830:

; 1364 : 
; 1365 : 		// it doesn't exist, add a new Association
; 1366 : 		pAssoc = NewAssoc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::NewAssoc
	mov	DWORD PTR _pAssoc$[ebp], eax

; 1367 : 		pAssoc->nHashValue = nHash;

	mov	eax, DWORD PTR _pAssoc$[ebp]
	mov	ecx, DWORD PTR _nHash$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1368 : 		pAssoc->key = key;

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	add	ecx, 8
	call	??4CString@@QAEABV0@PBG@Z		; CString::operator=

; 1369 : 		// 'pAssoc->value' is a constructed object, nothing more
; 1370 : 
; 1371 : 		// put into hash table
; 1372 : 		pAssoc->pNext = m_pHashTable[nHash];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	eax, DWORD PTR _nHash$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], ecx

; 1373 : 		m_pHashTable[nHash] = pAssoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nHash$[ebp]
	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$L75829:

; 1375 : 	return pAssoc->value;  // return new reference

	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH

; 1376 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::operator[]
_TEXT	ENDS
PUBLIC	?CompareElements@@YGHPBVCString@@PBQBG@Z	; CompareElements
PUBLIC	?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::FreeAssoc
EXTRN	?HashKey@@YGIPBG@Z:NEAR				; HashKey
;	COMDAT ?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z
_TEXT	SEGMENT
_key$ = 8
_this$ = -12
_ppAssocPrev$ = -4
_pAssoc$ = -8
?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveKey, COMDAT

; 1381 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1382 : 	ASSERT_VALID(this);

	push	1382					; 00000566H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1383 : 
; 1384 : 	if (m_pHashTable == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L75835

; 1385 : 		return FALSE;  // nothing in the table

	xor	eax, eax
	jmp	SHORT $L75834
$L75835:

; 1388 : 	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	call	?HashKey@@YGIPBG@Z			; HashKey
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _ppAssocPrev$[ebp], edx

; 1389 : 
; 1390 : 	CAssoc* pAssoc;
; 1391 : 	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)

	mov	eax, DWORD PTR _ppAssocPrev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAssoc$[ebp], ecx
	jmp	SHORT $L75841
$L75842:
	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pAssoc$[ebp], eax
$L75841:
	cmp	DWORD PTR _pAssoc$[ebp], 0
	je	SHORT $L75843

; 1393 : 		if (CompareElements(&pAssoc->key, &key))

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAssoc$[ebp]
	add	edx, 8
	push	edx
	call	?CompareElements@@YGHPBVCString@@PBQBG@Z ; CompareElements
	test	eax, eax
	je	SHORT $L75850

; 1395 : 			// remove it
; 1396 : 			*ppAssocPrev = pAssoc->pNext;  // remove from list

	mov	eax, DWORD PTR _ppAssocPrev$[ebp]
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1397 : 			FreeAssoc(pAssoc);

	mov	eax, DWORD PTR _pAssoc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::FreeAssoc

; 1398 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L75834
$L75850:

; 1400 : 		ppAssocPrev = &pAssoc->pNext;

	mov	ecx, DWORD PTR _pAssoc$[ebp]
	mov	DWORD PTR _ppAssocPrev$[ebp], ecx

; 1401 : 	}

	jmp	SHORT $L75842
$L75843:

; 1402 : 	return FALSE;  // not found

	xor	eax, eax
$L75834:

; 1403 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveKey@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEHPBG@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveKey
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetStartPosition, COMDAT

; 1191 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetStartPosition
_TEXT	ENDS
EXTRN	?AfxIsValidAddress@@YGHPBXIH@Z:NEAR		; AfxIsValidAddress
;	COMDAT ?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z
_TEXT	SEGMENT
_rNextPosition$ = 8
_rKey$ = 12
_rValue$ = 16
_this$ = -20
_pAssocRet$ = -4
_nBucket$75874 = -12
_pAssocNext$ = -8
_nBucket$75890 = -16
?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetNextAssoc, COMDAT

; 1408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 	ASSERT_VALID(this);

	push	1409					; 00000581H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L75861:

; 1410 : 	ASSERT(m_pHashTable != NULL);  // never call on empty map

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L75864
	push	1410					; 00000582H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75864
	int	3
$L75864:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75861

; 1411 : 
; 1412 : 	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	mov	eax, DWORD PTR _rNextPosition$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAssocRet$[ebp], ecx
$L75867:

; 1413 : 	ASSERT(pAssocRet != NULL);

	cmp	DWORD PTR _pAssocRet$[ebp], 0
	jne	SHORT $L75870
	push	1413					; 00000585H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75870
	int	3
$L75870:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75867

; 1414 : 
; 1415 : 	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)

	cmp	DWORD PTR _pAssocRet$[ebp], -1
	jne	SHORT $L75881

; 1417 : 		// find the first association
; 1418 : 		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)

	mov	DWORD PTR _nBucket$75874[ebp], 0
	jmp	SHORT $L75875
$L75876:
	mov	eax, DWORD PTR _nBucket$75874[ebp]
	add	eax, 1
	mov	DWORD PTR _nBucket$75874[ebp], eax
$L75875:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nBucket$75874[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $L75877

; 1419 : 			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nBucket$75874[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pAssocRet$[ebp], eax
	cmp	DWORD PTR _pAssocRet$[ebp], 0
	je	SHORT $L75878

; 1420 : 				break;

	jmp	SHORT $L75877
$L75878:

; 1421 : 		ASSERT(pAssocRet != NULL);  // must find something

	jmp	SHORT $L75876
$L75877:
	cmp	DWORD PTR _pAssocRet$[ebp], 0
	jne	SHORT $L75882
	push	1421					; 0000058dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75882
	int	3
$L75882:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75877
$L75881:

; 1423 : 
; 1424 : 	// find next association
; 1425 : 	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));

	push	1
	push	24					; 00000018H
	mov	edx, DWORD PTR _pAssocRet$[ebp]
	push	edx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L75887
	push	1425					; 00000591H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75887
	int	3
$L75887:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75881

; 1426 : 	CAssoc* pAssocNext;
; 1427 : 	if ((pAssocNext = pAssocRet->pNext) == NULL)

	mov	ecx, DWORD PTR _pAssocRet$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pAssocNext$[ebp], edx
	cmp	DWORD PTR _pAssocNext$[ebp], 0
	jne	SHORT $L75893

; 1429 : 		// go to next bucket
; 1430 : 		for (UINT nBucket = pAssocRet->nHashValue + 1;

	mov	eax, DWORD PTR _pAssocRet$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _nBucket$75890[ebp], ecx

; 1431 : 		  nBucket < m_nHashTableSize; nBucket++)

	jmp	SHORT $L75891
$L75892:
	mov	edx, DWORD PTR _nBucket$75890[ebp]
	add	edx, 1
	mov	DWORD PTR _nBucket$75890[ebp], edx
$L75891:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nBucket$75890[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $L75893

; 1432 : 			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nBucket$75890[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pAssocNext$[ebp], edx
	cmp	DWORD PTR _pAssocNext$[ebp], 0
	je	SHORT $L75894

; 1433 : 				break;

	jmp	SHORT $L75893
$L75894:

; 1434 : 	}

	jmp	SHORT $L75892
$L75893:

; 1435 : 
; 1436 : 	rNextPosition = (POSITION) pAssocNext;

	mov	eax, DWORD PTR _rNextPosition$[ebp]
	mov	ecx, DWORD PTR _pAssocNext$[ebp]
	mov	DWORD PTR [eax], ecx

; 1437 : 
; 1438 : 	// fill in return data
; 1439 : 	rKey = pAssocRet->key;

	mov	edx, DWORD PTR _pAssocRet$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _rKey$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=

; 1440 : 	rValue = pAssocRet->value;

	mov	eax, DWORD PTR _pAssocRet$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _rValue$[ebp]
	call	??4INIENTRY@@QAEAAU0@ABU0@@Z		; INIENTRY::operator=

; 1441 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetNextAssoc
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z
_TEXT	SEGMENT
_nHashSize$ = 8
_bAllocNow$ = 12
_this$ = -12
$T77023 = -4
$T77024 = -8
?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::InitHashTable, COMDAT

; 1218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1219 : 	ASSERT_VALID(this);

	push	1219					; 000004c3H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L75901:

; 1220 : 	ASSERT(m_nCount == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L75904
	push	1220					; 000004c4H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75904
	int	3
$L75904:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75901
$L75903:

; 1221 : 	ASSERT(nHashSize > 0);

	cmp	DWORD PTR _nHashSize$[ebp], 0
	ja	SHORT $L75908
	push	1221					; 000004c5H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75908
	int	3
$L75908:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75903

; 1222 : 
; 1223 : 	if (m_pHashTable != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L75909

; 1225 : 		// free hash table
; 1226 : 		delete[] m_pHashTable;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T77023[ebp], eax
	mov	ecx, DWORD PTR $T77023[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1227 : 		m_pHashTable = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L75909:

; 1229 : 
; 1230 : 	if (bAllocNow)

	cmp	DWORD PTR _bAllocNow$[ebp], 0
	je	SHORT $L75911

; 1232 : 		m_pHashTable = new CAssoc* [nHashSize];

	push	1232					; 000004d0H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _nHashSize$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T77024[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77024[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1233 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

	mov	eax, DWORD PTR _nHashSize$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$L75911:

; 1235 : 	m_nHashTableSize = nHashSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nHashSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1236 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?InitHashTable@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXIH@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::InitHashTable
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveAll
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T77029	DD	019930520H
	DD	01H
	DD	FLAT:$T77031
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77031	DD	0ffffffffH
	DD	FLAT:$L77027
xdata$x	ENDS
;	COMDAT ??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>, COMDAT

; 1270 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77030
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@6B@ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1271 : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveAll
$L75918:

; 1272 : 	ASSERT(m_nCount == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L75921
	push	1272					; 000004f8H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75921
	int	3
$L75921:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L75918

; 1273 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77027:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L77030:
	mov	eax, OFFSET FLAT:$T77029
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ ENDP	; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
PUBLIC	?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z ; SerializeElements
PUBLIC	?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::SetAt
EXTRN	?ReadCount@CArchive@@QAEKXZ:NEAR		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:NEAR		; CArchive::WriteCount
EXTRN	?Serialize@CObject@@UAEXAAVCArchive@@@Z:NEAR	; CObject::Serialize
EXTRN	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z:NEAR ; SerializeElements
EXTRN	?IsStoring@CArchive@@QBEHXZ:NEAR		; CArchive::IsStoring
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T77039	DD	019930520H
	DD	02H
	DD	FLAT:$T77041
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77041	DD	0ffffffffH
	DD	FLAT:$L77036
	DD	00H
	DD	FLAT:$L77037
xdata$x	ENDS
;	COMDAT ?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_ar$ = 8
_this$ = -44
_nHash$75932 = -16
_pAssoc$75936 = -20
_nNewCount$75952 = -24
_newKey$75956 = -28
_newValue$75957 = -40
__$EHRec$ = -12
?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Serialize, COMDAT

; 1445 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77040
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1446 : 	ASSERT_VALID(this);

	push	1446					; 000005a6H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1447 : 
; 1448 : 	CObject::Serialize(ar);

	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Serialize@CObject@@UAEXAAVCArchive@@@Z	; CObject::Serialize

; 1449 : 
; 1450 : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	$L75926

; 1452 : 		ar.WriteCount(m_nCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?WriteCount@CArchive@@QAEXK@Z		; CArchive::WriteCount

; 1453 : 		if (m_nCount == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $L75927

; 1454 : 			return;  // nothing more to do

	jmp	$L75925
$L75927:

; 1455 : 
; 1456 : 		ASSERT(m_pHashTable != NULL);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L75931
	push	1456					; 000005b0H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L75931
	int	3
$L75931:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L75927

; 1457 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

	mov	DWORD PTR _nHash$75932[ebp], 0
	jmp	SHORT $L75933
$L75934:
	mov	ecx, DWORD PTR _nHash$75932[ebp]
	add	ecx, 1
	mov	DWORD PTR _nHash$75932[ebp], ecx
$L75933:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nHash$75932[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $L75935

; 1459 : 			CAssoc* pAssoc;
; 1460 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nHash$75932[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pAssoc$75936[ebp], ecx

; 1461 : 			  pAssoc = pAssoc->pNext)

	jmp	SHORT $L75937
$L75938:
	mov	edx, DWORD PTR _pAssoc$75936[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pAssoc$75936[ebp], eax
$L75937:
	cmp	DWORD PTR _pAssoc$75936[ebp], 0
	je	SHORT $L75939

; 1463 : 				SerializeElements<KEY>(ar, &pAssoc->key, 1);

	push	1
	mov	ecx, DWORD PTR _pAssoc$75936[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	call	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z ; SerializeElements

; 1464 : 				SerializeElements<VALUE>(ar, &pAssoc->value, 1);

	push	1
	mov	eax, DWORD PTR _pAssoc$75936[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	call	?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z ; SerializeElements

; 1465 : 			}

	jmp	SHORT $L75938
$L75939:

; 1466 : 		}

	jmp	SHORT $L75934
$L75935:

; 1468 : 	else

	jmp	$L75955
$L75926:

; 1470 : 		DWORD nNewCount = ar.ReadCount();

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?ReadCount@CArchive@@QAEKXZ		; CArchive::ReadCount
	mov	DWORD PTR _nNewCount$75952[ebp], eax
$L75954:

; 1471 : 		while (nNewCount--)

	mov	edx, DWORD PTR _nNewCount$75952[ebp]
	mov	eax, DWORD PTR _nNewCount$75952[ebp]
	sub	eax, 1
	mov	DWORD PTR _nNewCount$75952[ebp], eax
	test	edx, edx
	je	SHORT $L75955

; 1473 : 			KEY newKey;

	lea	ecx, DWORD PTR _newKey$75956[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1474 : 			VALUE newValue;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _newValue$75957[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1475 : 			SerializeElements<KEY>(ar, &newKey, 1);

	push	1
	lea	ecx, DWORD PTR _newKey$75956[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	call	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z ; SerializeElements

; 1476 : 			SerializeElements<VALUE>(ar, &newValue, 1);

	push	1
	lea	eax, DWORD PTR _newValue$75957[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	call	?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z ; SerializeElements

; 1477 : 			SetAt(newKey, newValue);

	lea	edx, DWORD PTR _newValue$75957[ebp]
	push	edx
	lea	ecx, DWORD PTR _newKey$75956[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::SetAt

; 1478 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _newValue$75957[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _newKey$75956[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L75954
$L75955:
$L75925:

; 1480 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77036:
	lea	ecx, DWORD PTR _newKey$75956[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L77037:
	lea	ecx, DWORD PTR _newValue$75957[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L77040:
	mov	eax, OFFSET FLAT:$T77039
	jmp	___CxxFrameHandler
text$x	ENDS
?Serialize@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEXAAVCArchive@@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Serialize
PUBLIC	??_C@_05KIFI@with?5?$AA@			; `string'
PUBLIC	??_C@_09LOPF@?5elements?$AA@			; `string'
PUBLIC	??_C@_03DANH@?6?7?$FL?$AA@			; `string'
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ; DumpElements
PUBLIC	??_C@_04MNLE@?$FN?5?$DN?5?$AA@			; `string'
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z ; DumpElements
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
EXTRN	?Dump@CObject@@UBEXAAVCDumpContext@@@Z:NEAR	; CObject::Dump
EXTRN	?GetDepth@CDumpContext@@QBEHXZ:NEAR		; CDumpContext::GetDepth
EXTRN	??6CDumpContext@@QAEAAV0@PBD@Z:NEAR		; CDumpContext::operator<<
EXTRN	??6CDumpContext@@QAEAAV0@H@Z:NEAR		; CDumpContext::operator<<
;	COMDAT ??_C@_05KIFI@with?5?$AA@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
_DATA	SEGMENT
??_C@_05KIFI@with?5?$AA@ DB 'with ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LOPF@?5elements?$AA@
_DATA	SEGMENT
??_C@_09LOPF@?5elements?$AA@ DB ' elements', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03DANH@?6?7?$FL?$AA@
_DATA	SEGMENT
??_C@_03DANH@?6?7?$FL?$AA@ DB 0aH, 09H, '[', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MNLE@?$FN?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_04MNLE@?$FN?5?$DN?5?$AA@ DB '] = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
_DATA	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T77049	DD	019930520H
	DD	02H
	DD	FLAT:$T77051
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77051	DD	0ffffffffH
	DD	FLAT:$L77046
	DD	00H
	DD	FLAT:$L77047
xdata$x	ENDS
;	COMDAT ?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_dc$ = 8
_this$ = -36
_key$75975 = -28
_val$75976 = -24
_pos$75977 = -32
__$EHRec$ = -12
?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Dump, COMDAT

; 1485 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77050
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : 	CObject::Dump(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Dump@CObject@@UBEXAAVCDumpContext@@@Z	; CObject::Dump

; 1487 : 
; 1488 : 	dc << "with " << m_nCount << " elements";

	push	OFFSET FLAT:??_C@_09LOPF@?5elements?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET FLAT:??_C@_05KIFI@with?5?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@H@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1489 : 	if (dc.GetDepth() > 0)

	mov	ecx, DWORD PTR _dc$[ebp]
	call	?GetDepth@CDumpContext@@QBEHXZ		; CDumpContext::GetDepth
	test	eax, eax
	jle	$L75974

; 1491 : 		// Dump in format "[key] -> value"
; 1492 : 		KEY key;

	lea	ecx, DWORD PTR _key$75975[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1493 : 		VALUE val;

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _val$75976[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1494 : 
; 1495 : 		POSITION pos = GetStartPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartPosition@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEPAU__POSITION@@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetStartPosition
	mov	DWORD PTR _pos$75977[ebp], eax
$L75979:

; 1496 : 		while (pos != NULL)

	cmp	DWORD PTR _pos$75977[ebp], 0
	je	SHORT $L75980

; 1498 : 			GetNextAssoc(pos, key, val);

	lea	eax, DWORD PTR _val$75976[ebp]
	push	eax
	lea	ecx, DWORD PTR _key$75975[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$75977[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QBEXAAPAU__POSITION@@AAVCString@@AAUINIENTRY@@@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetNextAssoc

; 1499 : 			dc << "\n\t[";

	push	OFFSET FLAT:??_C@_03DANH@?6?7?$FL?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1500 : 			DumpElements<KEY>(dc, &key, 1);

	push	1
	lea	eax, DWORD PTR _key$75975[ebp]
	push	eax
	mov	ecx, DWORD PTR _dc$[ebp]
	push	ecx
	call	?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ; DumpElements

; 1501 : 			dc << "] = ";

	push	OFFSET FLAT:??_C@_04MNLE@?$FN?5?$DN?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1502 : 			DumpElements<VALUE>(dc, &val, 1);

	push	1
	lea	edx, DWORD PTR _val$75976[ebp]
	push	edx
	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	call	?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z ; DumpElements

; 1503 : 		}

	jmp	SHORT $L75979
$L75980:

; 1504 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _val$75976[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$75975[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L75974:

; 1505 : 
; 1506 : 	dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1507 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77046:
	lea	ecx, DWORD PTR _key$75975[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L77047:
	lea	ecx, DWORD PTR _val$75976[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	ret	0
$L77050:
	mov	eax, OFFSET FLAT:$T77049
	jmp	___CxxFrameHandler
text$x	ENDS
?Dump@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXAAVCDumpContext@@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::Dump
EXTRN	?AssertValid@CObject@@UBEXXZ:NEAR		; CObject::AssertValid
;	COMDAT ?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::AssertValid, COMDAT

; 1511 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1512 : 	CObject::AssertValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssertValid@CObject@@UBEXXZ		; CObject::AssertValid
$L75999:

; 1513 : 
; 1514 : 	ASSERT(m_nHashTableSize > 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	ja	SHORT $L76002
	push	1514					; 000005eaH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76002
	int	3
$L76002:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L75999
$L76001:

; 1515 : 	ASSERT(m_nCount == 0 || m_pHashTable != NULL);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L76006
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L76006
	push	1515					; 000005ebH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76006
	int	3
$L76006:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76001

; 1516 : 		// non-empty map should have hash table
; 1517 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertValid@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UBEXXZ ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::AssertValid
_TEXT	ENDS
PUBLIC	?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z ; CArray<INISECTION *,INISECTION *>::Serialize
PUBLIC	?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z ; CArray<INISECTION *,INISECTION *>::Dump
PUBLIC	?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ ; CArray<INISECTION *,INISECTION *>::AssertValid
PUBLIC	??_7?$CArray@PAUINISECTION@@PAU1@@@6B@		; CArray<INISECTION *,INISECTION *>::`vftable'
PUBLIC	??_G?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z	; CArray<INISECTION *,INISECTION *>::`scalar deleting destructor'
PUBLIC	??_E?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z	; CArray<INISECTION *,INISECTION *>::`vector deleting destructor'
;	COMDAT ??_7?$CArray@PAUINISECTION@@PAU1@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
CONST	SEGMENT
??_7?$CArray@PAUINISECTION@@PAU1@@@6B@ DD FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ ; CArray<INISECTION *,INISECTION *>::`vftable'
	DD	FLAT:??_E?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ
	DD	FLAT:?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ PROC NEAR	; CArray<INISECTION *,INISECTION *>::CArray<INISECTION *,INISECTION *>, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CObject@@IAE@XZ			; CObject::CObject
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@PAUINISECTION@@PAU1@@@6B@ ; CArray<INISECTION *,INISECTION *>::`vftable'

; 288  : 	m_pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 289  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 290  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CArray@PAUINISECTION@@PAU1@@@QAE@XZ ENDP		; CArray<INISECTION *,INISECTION *>::CArray<INISECTION *,INISECTION *>
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ PROC NEAR ; CArray<INISECTION *,INISECTION *>::GetSize, COMDAT

; 245  : 	{ return m_nSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CArray@PAUINISECTION@@PAU1@@@QBEHXZ ENDP	; CArray<INISECTION *,INISECTION *>::GetSize
_TEXT	ENDS
PUBLIC	?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::SetSize
;	COMDAT ?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ PROC NEAR ; CArray<INISECTION *,INISECTION *>::RemoveAll, COMDAT

; 251  : 	{ SetSize(0, -1); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	-1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::SetSize
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CArray@PAUINISECTION@@PAU1@@@QAEXXZ ENDP	; CArray<INISECTION *,INISECTION *>::RemoveAll
_TEXT	ENDS
PUBLIC	?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z ; CArray<INISECTION *,INISECTION *>::SetAtGrow
;	COMDAT ?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z
_TEXT	SEGMENT
_newElement$ = 8
_this$ = -8
_nIndex$ = -4
?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::Add, COMDAT

; 272  : 	{ int nIndex = m_nSize;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nIndex$[ebp], ecx

; 273  : 		SetAtGrow(nIndex, newElement);

	mov	edx, DWORD PTR _newElement$[ebp]
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z ; CArray<INISECTION *,INISECTION *>::SetAtGrow

; 274  : 		return nIndex; }

	mov	eax, DWORD PTR _nIndex$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CArray@PAUINISECTION@@PAU1@@@QAEHPAUINISECTION@@@Z ENDP ; CArray<INISECTION *,INISECTION *>::Add
_TEXT	ENDS
PUBLIC	?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::ElementAt
;	COMDAT ??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::operator[], COMDAT

; 280  : 	{ return ElementAt(nIndex); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ; CArray<INISECTION *,INISECTION *>::ElementAt
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ENDP ; CArray<INISECTION *,INISECTION *>::operator[]
_TEXT	ENDS
PUBLIC	?DestructElements@@YGXPAPAUINISECTION@@H@Z	; DestructElements
EXTRN	__imp__memmove:NEAR
;	COMDAT ?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z
_TEXT	SEGMENT
_nIndex$ = 8
_nCount$ = 12
_this$ = -8
_nMoveCount$ = -4
?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::RemoveAt, COMDAT

; 481  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 	ASSERT_VALID(this);

	push	482					; 000001e2H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L76030:

; 483  : 	ASSERT(nIndex >= 0);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jge	SHORT $L76033
	push	483					; 000001e3H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76033
	int	3
$L76033:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76030
$L76032:

; 484  : 	ASSERT(nCount >= 0);

	cmp	DWORD PTR _nCount$[ebp], 0
	jge	SHORT $L76037
	push	484					; 000001e4H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76037
	int	3
$L76037:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76032
$L76036:

; 485  : 	ASSERT(nIndex + nCount <= m_nSize);

	mov	eax, DWORD PTR _nIndex$[ebp]
	add	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	jle	SHORT $L76041
	push	485					; 000001e5H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76041
	int	3
$L76041:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76036

; 486  : 
; 487  : 	// just remove a range
; 488  : 	int nMoveCount = m_nSize - (nIndex + nCount);

	mov	eax, DWORD PTR _nIndex$[ebp]
	add	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR _nMoveCount$[ebp], edx

; 489  : 	DestructElements<TYPE>(&m_pData[nIndex], nCount);

	mov	eax, DWORD PTR _nCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?DestructElements@@YGXPAPAUINISECTION@@H@Z ; DestructElements

; 490  : 	if (nMoveCount)

	cmp	DWORD PTR _nMoveCount$[ebp], 0
	je	SHORT $L76048

; 492  : 			nMoveCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nMoveCount$[ebp]
	shl	edx, 2
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	add	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__chkesp
$L76048:

; 493  : 	m_nSize -= nCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 494  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveAt@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ENDP	; CArray<INISECTION *,INISECTION *>::RemoveAt
_TEXT	ENDS
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T77074	DD	019930520H
	DD	01H
	DD	FLAT:$T77076
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77076	DD	0ffffffffH
	DD	FLAT:$L77072
xdata$x	ENDS
;	COMDAT ??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ
_TEXT	SEGMENT
$T77071 = -16
__$EHRec$ = -12
_this$ = -20
??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ PROC NEAR	; CArray<INISECTION *,INISECTION *>::~CArray<INISECTION *,INISECTION *>, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77075
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@PAUINISECTION@@PAU1@@@6B@ ; CArray<INISECTION *,INISECTION *>::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 295  : 	ASSERT_VALID(this);

	push	295					; 00000127H
	push	OFFSET FLAT:__szAfxTempl
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 296  : 
; 297  : 	if (m_pData != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L76053

; 299  : 		DestructElements<TYPE>(m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestructElements@@YGXPAPAUINISECTION@@H@Z ; DestructElements

; 300  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T77071[ebp], edx
	mov	eax, DWORD PTR $T77071[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L76053:

; 302  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77072:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L77075:
	mov	eax, OFFSET FLAT:$T77074
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ ENDP		; CArray<INISECTION *,INISECTION *>::~CArray<INISECTION *,INISECTION *>
PUBLIC	?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z ; SerializeElements
;	COMDAT ?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_ar$ = 8
_this$ = -8
_nOldSize$76066 = -4
?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::Serialize, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	ASSERT_VALID(this);

	push	515					; 00000203H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 516  : 
; 517  : 	CObject::Serialize(ar);

	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Serialize@CObject@@UAEXAAVCArchive@@@Z	; CObject::Serialize

; 518  : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L76064

; 520  : 		ar.WriteCount(m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?WriteCount@CArchive@@QAEXK@Z		; CArchive::WriteCount

; 522  : 	else

	jmp	SHORT $L76065
$L76064:

; 524  : 		DWORD nOldSize = ar.ReadCount();

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?ReadCount@CArchive@@QAEKXZ		; CArchive::ReadCount
	mov	DWORD PTR _nOldSize$76066[ebp], eax

; 525  : 		SetSize(nOldSize, -1);

	push	-1
	mov	ecx, DWORD PTR _nOldSize$76066[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::SetSize
$L76065:

; 527  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ar$[ebp]
	push	eax
	call	?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z ; SerializeElements

; 528  : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Serialize@?$CArray@PAUINISECTION@@PAU1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<INISECTION *,INISECTION *>::Serialize
_TEXT	ENDS
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z ; DumpElements
;	COMDAT ?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_dc$ = 8
_this$ = -4
?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::Dump, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	CObject::Dump(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Dump@CObject@@UBEXAAVCDumpContext@@@Z	; CObject::Dump

; 535  : 
; 536  : 	dc << "with " << m_nSize << " elements";

	push	OFFSET FLAT:??_C@_09LOPF@?5elements?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET FLAT:??_C@_05KIFI@with?5?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@H@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 537  : 	if (dc.GetDepth() > 0)

	mov	ecx, DWORD PTR _dc$[ebp]
	call	?GetDepth@CDumpContext@@QBEHXZ		; CDumpContext::GetDepth
	test	eax, eax
	jle	SHORT $L76077

; 539  : 		dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 540  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _dc$[ebp]
	push	ecx
	call	?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z ; DumpElements
$L76077:

; 542  : 
; 543  : 	dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 544  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Dump@?$CArray@PAUINISECTION@@PAU1@@@UBEXAAVCDumpContext@@@Z ENDP ; CArray<INISECTION *,INISECTION *>::Dump
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ PROC NEAR ; CArray<INISECTION *,INISECTION *>::AssertValid, COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	CObject::AssertValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssertValid@CObject@@UBEXXZ		; CObject::AssertValid

; 550  : 
; 551  : 	if (m_pData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L76087
$L76088:

; 553  : 		ASSERT(m_nSize == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $L76091
	push	553					; 00000229H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76091
	int	3
$L76091:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76088
$L76090:

; 554  : 		ASSERT(m_nMaxSize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L76095
	push	554					; 0000022aH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76095
	int	3
$L76095:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76090

; 556  : 	else

	jmp	$L76111
$L76087:

; 558  : 		ASSERT(m_nSize >= 0);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jge	SHORT $L76100
	push	558					; 0000022eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76100
	int	3
$L76100:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L76087
$L76099:

; 559  : 		ASSERT(m_nMaxSize >= 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $L76104
	push	559					; 0000022fH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76104
	int	3
$L76104:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76099
$L76103:

; 560  : 		ASSERT(m_nSize <= m_nMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $L76108
	push	560					; 00000230H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76108
	int	3
$L76108:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L76103
$L76107:

; 561  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76113
	push	561					; 00000231H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76113
	int	3
$L76113:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76107
$L76111:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertValid@?$CArray@PAUINISECTION@@PAU1@@@UBEXXZ ENDP	; CArray<INISECTION *,INISECTION *>::AssertValid
_TEXT	ENDS
EXTRN	??3CObject@@SGXPAX@Z:NEAR			; CObject::operator delete
;	COMDAT ??_G?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAE@XZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::~CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76118
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L76118:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@UAEPAXI@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z PROC NEAR	; CArray<INISECTION *,INISECTION *>::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CArray@PAUINISECTION@@PAU1@@@UAE@XZ ; CArray<INISECTION *,INISECTION *>::~CArray<INISECTION *,INISECTION *>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76121
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L76121:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CArray@PAUINISECTION@@PAU1@@@UAEPAXI@Z ENDP	; CArray<INISECTION *,INISECTION *>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z
_TEXT	SEGMENT
_key$ = 8
_newValue$ = 12
_this$ = -4
?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::SetAt, COMDAT

; 1188 : 	{ (*this)[key] = newValue; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _newValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEAAUINIENTRY@@PBG@Z ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::operator[]
	mov	ecx, eax
	call	??4INIENTRY@@QAEAAU0@ABU0@@Z		; INIENTRY::operator=
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXPBGAAUINIENTRY@@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::SetAt
_TEXT	ENDS
PUBLIC	?DestructElements@@YGXPAUINIENTRY@@H@Z		; DestructElements
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:NEAR		; CPlex::FreeDataChain
EXTRN	?DestructElements@@YGXPAVCString@@H@Z:NEAR	; DestructElements
;	COMDAT ?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ
_TEXT	SEGMENT
$T77093 = -12
_this$ = -16
_nHash$76131 = -4
_pAssoc$76135 = -8
?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveAll, COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1241 : 	ASSERT_VALID(this);

	push	1241					; 000004d9H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1242 : 
; 1243 : 	if (m_pHashTable != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L76134

; 1245 : 		// destroy elements (values and keys)
; 1246 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

	mov	DWORD PTR _nHash$76131[ebp], 0
	jmp	SHORT $L76132
$L76133:
	mov	edx, DWORD PTR _nHash$76131[ebp]
	add	edx, 1
	mov	DWORD PTR _nHash$76131[ebp], edx
$L76132:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nHash$76131[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $L76134

; 1248 : 			CAssoc* pAssoc;
; 1249 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nHash$76131[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pAssoc$76135[ebp], edx

; 1250 : 			  pAssoc = pAssoc->pNext)

	jmp	SHORT $L76136
$L76137:
	mov	eax, DWORD PTR _pAssoc$76135[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAssoc$76135[ebp], ecx
$L76136:
	cmp	DWORD PTR _pAssoc$76135[ebp], 0
	je	SHORT $L76138

; 1252 : 				DestructElements<VALUE>(&pAssoc->value, 1);

	push	1
	mov	edx, DWORD PTR _pAssoc$76135[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	?DestructElements@@YGXPAUINIENTRY@@H@Z	; DestructElements

; 1253 : 				DestructElements<KEY>(&pAssoc->key, 1);

	push	1
	mov	eax, DWORD PTR _pAssoc$76135[ebp]
	add	eax, 8
	push	eax
	call	?DestructElements@@YGXPAVCString@@H@Z	; DestructElements

; 1254 : 			}

	jmp	SHORT $L76137
$L76138:

; 1255 : 		}

	jmp	SHORT $L76133
$L76134:

; 1257 : 
; 1258 : 	// free hash table
; 1259 : 	delete[] m_pHashTable;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T77093[ebp], edx
	mov	eax, DWORD PTR $T77093[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1260 : 	m_pHashTable = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1261 : 
; 1262 : 	m_nCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1263 : 	m_pFreeList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1264 : 	m_pBlocks->FreeDataChain();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?FreeDataChain@CPlex@@QAEXXZ		; CPlex::FreeDataChain

; 1265 : 	m_pBlocks = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1266 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveAll
_TEXT	ENDS
PUBLIC	?data@CPlex@@QAEPAXXZ				; CPlex::data
PUBLIC	?ConstructElements@@YGXPAUINIENTRY@@H@Z		; ConstructElements
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:NEAR		; CPlex::Create
EXTRN	?ConstructElements@@YGXPAVCString@@H@Z:NEAR	; ConstructElements
;	COMDAT ?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT
_this$ = -20
_newBlock$76153 = -8
_pAssoc$76155 = -16
_i$76157 = -12
_pAssoc$ = -4
?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::NewAssoc, COMDAT

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1279 : 	if (m_pFreeList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L76160

; 1281 : 		// add another block
; 1282 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?Create@CPlex@@SGPAU1@AAPAU1@II@Z	; CPlex::Create
	mov	DWORD PTR _newBlock$76153[ebp], eax

; 1283 : 		// chain them into free list
; 1284 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();

	mov	ecx, DWORD PTR _newBlock$76153[ebp]
	call	?data@CPlex@@QAEPAXXZ			; CPlex::data
	mov	DWORD PTR _pAssoc$76155[ebp], eax

; 1285 : 		// free in reverse order to make it easier to debug
; 1286 : 		pAssoc += m_nBlockSize - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _pAssoc$76155[ebp]
	add	eax, edx
	mov	DWORD PTR _pAssoc$76155[ebp], eax

; 1287 : 		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	mov	DWORD PTR _i$76157[ebp], edx
	jmp	SHORT $L76158
$L76159:
	mov	eax, DWORD PTR _i$76157[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$76157[ebp], eax
	mov	ecx, DWORD PTR _pAssoc$76155[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR _pAssoc$76155[ebp], ecx
$L76158:
	cmp	DWORD PTR _i$76157[ebp], 0
	jl	SHORT $L76160

; 1289 : 			pAssoc->pNext = m_pFreeList;

	mov	edx, DWORD PTR _pAssoc$76155[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], ecx

; 1290 : 			m_pFreeList = pAssoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pAssoc$76155[ebp]
	mov	DWORD PTR [edx+16], eax

; 1291 : 		}

	jmp	SHORT $L76159
$L76160:

; 1293 : 	ASSERT(m_pFreeList != NULL);  // we must have something

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L76164
	push	1293					; 0000050dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76164
	int	3
$L76164:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76160

; 1294 : 
; 1295 : 	CMap::CAssoc* pAssoc = m_pFreeList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pAssoc$[ebp], ecx

; 1296 : 	m_pFreeList = m_pFreeList->pNext;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+16], edx

; 1297 : 	m_nCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$L76166:

; 1298 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jg	SHORT $L76169
	push	1298					; 00000512H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76169
	int	3
$L76169:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76166

; 1299 : 	ConstructElements<KEY>(&pAssoc->key, 1);

	push	1
	mov	edx, DWORD PTR _pAssoc$[ebp]
	add	edx, 8
	push	edx
	call	?ConstructElements@@YGXPAVCString@@H@Z	; ConstructElements

; 1300 : 	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values

	push	1
	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	?ConstructElements@@YGXPAUINIENTRY@@H@Z	; ConstructElements

; 1301 : 	return pAssoc;

	mov	eax, DWORD PTR _pAssoc$[ebp]

; 1302 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?NewAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEPAUCAssoc@1@XZ ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::NewAssoc
_TEXT	ENDS
;	COMDAT ?data@CPlex@@QAEPAXXZ
text$AFX_COL1	SEGMENT
_this$ = -4
?data@CPlex@@QAEPAXXZ PROC NEAR				; CPlex::data, COMDAT

; 34   : 	void* data() { return this+1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?data@CPlex@@QAEPAXXZ ENDP				; CPlex::data
text$AFX_COL1	ENDS
;	COMDAT ?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z
_TEXT	SEGMENT
_pAssoc$ = 8
_this$ = -4
?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::FreeAssoc, COMDAT

; 1306 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1307 : 	DestructElements<VALUE>(&pAssoc->value, 1);

	push	1
	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	?DestructElements@@YGXPAUINIENTRY@@H@Z	; DestructElements

; 1308 : 	DestructElements<KEY>(&pAssoc->key, 1);

	push	1
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	add	ecx, 8
	push	ecx
	call	?DestructElements@@YGXPAVCString@@H@Z	; DestructElements

; 1309 : 	pAssoc->pNext = m_pFreeList;

	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], ecx

; 1310 : 	m_pFreeList = pAssoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pAssoc$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1311 : 	m_nCount--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L76191:

; 1312 : 	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $L76194
	push	1312					; 00000520H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76194
	int	3
$L76194:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76191

; 1313 : 
; 1314 : 	// if no more elements, cleanup completely
; 1315 : 	if (m_nCount == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $L76195

; 1316 : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@QAEXXZ ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::RemoveAll
$L76195:

; 1317 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?FreeAssoc@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IAEXPAUCAssoc@1@@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::FreeAssoc
_TEXT	ENDS
;	COMDAT ?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z
_TEXT	SEGMENT
_key$ = 8
_nHash$ = 12
_this$ = -8
_pAssoc$ = -4
?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z PROC NEAR ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetAssocAt, COMDAT

; 1323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1324 : 	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?HashKey@@YGIPBG@Z			; HashKey
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _nHash$[ebp]
	mov	DWORD PTR [eax], edx

; 1325 : 
; 1326 : 	if (m_pHashTable == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L76204

; 1327 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L76200
$L76204:

; 1331 : 	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)

	mov	edx, DWORD PTR _nHash$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pAssoc$[ebp], eax
	jmp	SHORT $L76206
$L76207:
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pAssoc$[ebp], edx
$L76206:
	cmp	DWORD PTR _pAssoc$[ebp], 0
	je	SHORT $L76208

; 1333 : 		if (CompareElements(&pAssoc->key, &key))

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	add	ecx, 8
	push	ecx
	call	?CompareElements@@YGHPBVCString@@PBQBG@Z ; CompareElements
	test	eax, eax
	je	SHORT $L76214

; 1334 : 			return pAssoc;

	mov	eax, DWORD PTR _pAssoc$[ebp]
	jmp	SHORT $L76200
$L76214:

; 1335 : 	}

	jmp	SHORT $L76207
$L76208:

; 1336 : 	return NULL;

	xor	eax, eax
$L76200:

; 1337 : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAssocAt@?$CMap@VCString@@PBGUINIENTRY@@AAU2@@@IBEPAUCAssoc@1@PBGAAI@Z ENDP ; CMap<CString,unsigned short const *,INIENTRY,INIENTRY &>::GetAssocAt
_TEXT	ENDS
EXTRN	??8@YG_NABVCString@@PBG@Z:NEAR			; operator==
;	COMDAT ?CompareElements@@YGHPBVCString@@PBQBG@Z
_TEXT	SEGMENT
_pElement1$ = 8
_pElement2$ = 12
?CompareElements@@YGHPBVCString@@PBQBG@Z PROC NEAR	; CompareElements, COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76216:

; 119  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));

	push	0
	push	4
	mov	eax, DWORD PTR _pElement1$[ebp]
	push	eax
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76220
	push	119					; 00000077H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76220
	int	3
$L76220:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76216
$L76218:

; 120  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	push	0
	push	4
	mov	edx, DWORD PTR _pElement2$[ebp]
	push	edx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76225
	push	120					; 00000078H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76225
	int	3
$L76225:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L76218

; 121  : 
; 122  : 	return *pElement1 == *pElement2;

	mov	ecx, DWORD PTR _pElement2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pElement1$[ebp]
	push	eax
	call	??8@YG_NABVCString@@PBG@Z		; operator==
	and	eax, 255				; 000000ffH

; 123  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?CompareElements@@YGHPBVCString@@PBQBG@Z ENDP		; CompareElements
_TEXT	ENDS
EXTRN	?Read@CArchive@@QAEIPAXI@Z:NEAR			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:NEAR		; CArchive::Write
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z
_TEXT	SEGMENT
_ar$ = 8
_pElements$ = 12
_nCount$ = 16
?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z PROC NEAR ; SerializeElements, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76227:

; 92   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76231
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76231
	push	93					; 0000005dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76231
	int	3
$L76231:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76227

; 93   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 94   : 
; 95   : 	// default is bit-wise read/write
; 96   : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L76232

; 97   : 		ar.Write((void*)pElements, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Write@CArchive@@QAEXPBXI@Z		; CArchive::Write

; 98   : 	else

	jmp	SHORT $L76235
$L76232:

; 99   : 		ar.Read((void*)pElements, nCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nCount$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Read@CArchive@@QAEIPAXI@Z		; CArchive::Read
$L76235:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?SerializeElements@@YGXAAVCArchive@@PAUINIENTRY@@H@Z ENDP ; SerializeElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76239:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76243
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76243
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76243
	int	3
$L76243:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76239

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ENDP	; DumpElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76245:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76249
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76249
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76249
	int	3
$L76249:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76245

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBUINIENTRY@@H@Z ENDP ; DumpElements
_TEXT	ENDS
PUBLIC	?ConstructElements@@YGXPAPAUINISECTION@@H@Z	; ConstructElements
EXTRN	_memcpy:NEAR
;	COMDAT ?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z
_TEXT	SEGMENT
$T77112 = -16
$T77113 = -20
$T77118 = -24
$T77119 = -28
_nNewSize$ = 8
_nGrowBy$ = 12
_this$ = -32
_nGrowBy$76298 = -8
_nNewMax$76300 = -12
_pNewData$76312 = -4
?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::SetSize, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 	ASSERT_VALID(this);

	push	307					; 00000133H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L76255:

; 308  : 	ASSERT(nNewSize >= 0);

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jge	SHORT $L76258
	push	308					; 00000134H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76258
	int	3
$L76258:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76255

; 309  : 
; 310  : 	if (nGrowBy != -1)

	cmp	DWORD PTR _nGrowBy$[ebp], -1
	je	SHORT $L76259

; 311  : 		m_nGrowBy = nGrowBy;  // set new size

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nGrowBy$[ebp]
	mov	DWORD PTR [edx+16], eax
$L76259:

; 312  : 
; 313  : 	if (nNewSize == 0)

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jne	SHORT $L76260

; 315  : 		// shrink to nothing
; 316  : 		if (m_pData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L76261

; 318  : 			DestructElements<TYPE>(m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?DestructElements@@YGXPAPAUINISECTION@@H@Z ; DestructElements

; 319  : 			delete[] (BYTE*)m_pData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77112[ebp], ecx
	mov	edx, DWORD PTR $T77112[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 320  : 			m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$L76261:

; 322  : 		m_nSize = m_nMaxSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 324  : 	else if (m_pData == NULL)

	jmp	$L76297
$L76260:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L76269
$L76270:

; 326  : 		// create one with exact size
; 327  : #ifdef SIZE_T_MAX
; 328  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow

	cmp	DWORD PTR _nNewSize$[ebp], 1073741823	; 3fffffffH
	jbe	SHORT $L76274
	push	328					; 00000148H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76274
	int	3
$L76274:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76270

; 329  : #endif
; 330  : 		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];

	push	330					; 0000014aH
	push	OFFSET FLAT:__szAfxTempl
	mov	edx, DWORD PTR _nNewSize$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T77113[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T77113[ebp]
	mov	DWORD PTR [eax+4], ecx

; 331  : 		ConstructElements<TYPE>(m_pData, nNewSize);

	mov	edx, DWORD PTR _nNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ConstructElements@@YGXPAPAUINISECTION@@H@Z ; ConstructElements

; 332  : 		m_nSize = m_nMaxSize = nNewSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 334  : 	else if (nNewSize <= m_nMaxSize)

	jmp	$L76297
$L76269:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jg	SHORT $L76285

; 336  : 		// it fits
; 337  : 		if (nNewSize > m_nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $L76286

; 339  : 			// initialize the new elements
; 340  : 			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	call	?ConstructElements@@YGXPAPAUINISECTION@@H@Z ; ConstructElements

; 342  : 		else if (m_nSize > nNewSize)

	jmp	SHORT $L76292
$L76286:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jle	SHORT $L76292

; 344  : 			// destroy the old elements
; 345  : 			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _nNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?DestructElements@@YGXPAPAUINISECTION@@H@Z ; DestructElements
$L76292:

; 347  : 		m_nSize = nNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 349  : 	else

	jmp	$L76297
$L76285:

; 351  : 		// otherwise, grow array
; 352  : 		int nGrowBy = m_nGrowBy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nGrowBy$76298[ebp], ecx

; 353  : 		if (nGrowBy == 0)

	cmp	DWORD PTR _nGrowBy$76298[ebp], 0
	jne	SHORT $L76299

; 355  : 			// heuristically determine growth when nGrowBy == 0
; 356  : 			//  (this avoids heap fragmentation in many situations)
; 357  : 			nGrowBy = m_nSize / 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _nGrowBy$76298[ebp], eax

; 358  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

	cmp	DWORD PTR _nGrowBy$76298[ebp], 4
	jge	SHORT $L77116
	mov	DWORD PTR -36+[ebp], 4
	jmp	SHORT $L77117
$L77116:
	cmp	DWORD PTR _nGrowBy$76298[ebp], 1024	; 00000400H
	jle	SHORT $L77114
	mov	DWORD PTR -40+[ebp], 1024		; 00000400H
	jmp	SHORT $L77115
$L77114:
	mov	eax, DWORD PTR _nGrowBy$76298[ebp]
	mov	DWORD PTR -40+[ebp], eax
$L77115:
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
$L77117:
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR _nGrowBy$76298[ebp], edx
$L76299:

; 361  : 		if (nNewSize < m_nMaxSize + nGrowBy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _nGrowBy$76298[ebp]
	cmp	DWORD PTR _nNewSize$[ebp], ecx
	jge	SHORT $L76301

; 362  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _nGrowBy$76298[ebp]
	mov	DWORD PTR _nNewMax$76300[ebp], eax

; 363  : 		else

	jmp	SHORT $L76302
$L76301:

; 364  : 			nNewMax = nNewSize;  // no slush

	mov	ecx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR _nNewMax$76300[ebp], ecx
$L76302:

; 365  : 
; 366  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewMax$76300[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $L76306
	push	366					; 0000016eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76306
	int	3
$L76306:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76302
$L76305:

; 367  : #ifdef SIZE_T_MAX
; 368  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow

	cmp	DWORD PTR _nNewMax$76300[ebp], 1073741823 ; 3fffffffH
	jbe	SHORT $L76311
	push	368					; 00000170H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76311
	int	3
$L76311:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76305

; 369  : #endif
; 370  : 		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

	push	370					; 00000172H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _nNewMax$76300[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T77118[ebp], eax
	mov	ecx, DWORD PTR $T77118[ebp]
	mov	DWORD PTR _pNewData$76312[ebp], ecx

; 371  : 
; 372  : 		// copy new data from old
; 373  : 		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pNewData$76312[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L76318:

; 374  : 
; 375  : 		// construct remaining elements
; 376  : 		ASSERT(nNewSize > m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jg	SHORT $L76321
	push	376					; 00000178H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76321
	int	3
$L76321:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L76318

; 377  : 		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pNewData$76312[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?ConstructElements@@YGXPAPAUINISECTION@@H@Z ; ConstructElements

; 378  : 
; 379  : 		// get rid of old stuff (note: no destructors called)
; 380  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T77119[ebp], edx
	mov	eax, DWORD PTR $T77119[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 381  : 		m_pData = pNewData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pNewData$76312[ebp]
	mov	DWORD PTR [ecx+4], edx

; 382  : 		m_nSize = nNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 383  : 		m_nMaxSize = nNewMax;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewMax$76300[ebp]
	mov	DWORD PTR [edx+12], eax
$L76297:

; 385  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ENDP	; CArray<INISECTION *,INISECTION *>::SetSize
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::ElementAt, COMDAT

; 262  : 	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L76332:
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L76336
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L76335
$L76336:
	push	262					; 00000106H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76335
	int	3
$L76335:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76332

; 263  : 		return m_pData[nIndex]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?ElementAt@?$CArray@PAUINISECTION@@PAU1@@@QAEAAPAUINISECTION@@H@Z ENDP ; CArray<INISECTION *,INISECTION *>::ElementAt
_TEXT	ENDS
;	COMDAT ?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z
_TEXT	SEGMENT
_nIndex$ = 8
_newElement$ = 12
_this$ = -4
?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z PROC NEAR ; CArray<INISECTION *,INISECTION *>::SetAtGrow, COMDAT

; 437  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 	ASSERT_VALID(this);

	push	438					; 000001b6H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L76342:

; 439  : 	ASSERT(nIndex >= 0);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jge	SHORT $L76345
	push	439					; 000001b7H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76345
	int	3
$L76345:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L76342

; 440  : 
; 441  : 	if (nIndex >= m_nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nIndex$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $L76346

; 442  : 		SetSize(nIndex+1, -1);

	push	-1
	mov	ecx, DWORD PTR _nIndex$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@PAUINISECTION@@PAU1@@@QAEXHH@Z ; CArray<INISECTION *,INISECTION *>::SetSize
$L76346:

; 443  : 	m_pData[nIndex] = newElement;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	mov	edx, DWORD PTR _newElement$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAtGrow@?$CArray@PAUINISECTION@@PAU1@@@QAEXHPAUINISECTION@@@Z ENDP ; CArray<INISECTION *,INISECTION *>::SetAtGrow
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAPAUINISECTION@@H@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
?DestructElements@@YGXPAPAUINISECTION@@H@Z PROC NEAR	; DestructElements, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76348:

; 68   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76352
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76352
	push	69					; 00000045H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76352
	int	3
$L76352:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76348

; 69   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 70   : 
; 71   : 	// call the destructor(s)
; 72   : 	for (; nCount--; pElements++)

	jmp	SHORT $L76353
$L76354:
	mov	eax, DWORD PTR _pElements$[ebp]
	add	eax, 4
	mov	DWORD PTR _pElements$[ebp], eax
$L76353:
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L76355

; 73   : 		pElements->~TYPE();

	jmp	SHORT $L76354
$L76355:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?DestructElements@@YGXPAPAUINISECTION@@H@Z ENDP		; DestructElements
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z
_TEXT	SEGMENT
_ar$ = 8
_pElements$ = 12
_nCount$ = 16
?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z PROC NEAR ; SerializeElements, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76357:

; 92   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76361
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76361
	push	93					; 0000005dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76361
	int	3
$L76361:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76357

; 93   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 94   : 
; 95   : 	// default is bit-wise read/write
; 96   : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L76362

; 97   : 		ar.Write((void*)pElements, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Write@CArchive@@QAEXPBXI@Z		; CArchive::Write

; 98   : 	else

	jmp	SHORT $L76365
$L76362:

; 99   : 		ar.Read((void*)pElements, nCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nCount$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Read@CArchive@@QAEIPAXI@Z		; CArchive::Read
$L76365:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?SerializeElements@@YGXAAVCArchive@@PAPAUINISECTION@@H@Z ENDP ; SerializeElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76369:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76373
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76373
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76373
	int	3
$L76373:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76369

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBQAUINISECTION@@H@Z ENDP ; DumpElements
_TEXT	ENDS
PUBLIC	??_GINIENTRY@@QAEPAXI@Z				; INIENTRY::`scalar deleting destructor'
;	COMDAT ?DestructElements@@YGXPAUINIENTRY@@H@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
?DestructElements@@YGXPAUINIENTRY@@H@Z PROC NEAR	; DestructElements, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L76375:

; 68   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76379
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76379
	push	69					; 00000045H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76379
	int	3
$L76379:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76375

; 69   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 70   : 
; 71   : 	// call the destructor(s)
; 72   : 	for (; nCount--; pElements++)

	jmp	SHORT $L76380
$L76381:
	mov	eax, DWORD PTR _pElements$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pElements$[ebp], eax
$L76380:
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L76382

; 73   : 		pElements->~TYPE();

	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	call	??_GINIENTRY@@QAEPAXI@Z			; INIENTRY::`scalar deleting destructor'
	jmp	SHORT $L76381
$L76382:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?DestructElements@@YGXPAUINIENTRY@@H@Z ENDP		; DestructElements
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T77140	DD	019930520H
	DD	01H
	DD	FLAT:$T77142
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T77142	DD	0ffffffffH
	DD	FLAT:$L77138
xdata$x	ENDS
;	COMDAT ?ConstructElements@@YGXPAUINIENTRY@@H@Z
_TEXT	SEGMENT
$T77134 = -16
$T77135 = -20
__$EHRec$ = -12
_pElements$ = 8
_nCount$ = 12
?ConstructElements@@YGXPAUINIENTRY@@H@Z PROC NEAR	; ConstructElements, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L77141
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
$L76384:

; 54   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76388
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76388
	push	55					; 00000037H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76388
	int	3
$L76388:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76384

; 55   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 56   : 
; 57   : 	// first do bit-wise zero initialization
; 58   : 	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	// then call the constructor(s)
; 61   : 	for (; nCount--; pElements++)

	jmp	SHORT $L76391
$L76392:
	mov	edx, DWORD PTR _pElements$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pElements$[ebp], edx
$L76391:
	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L76393

; 62   : 		::new((void*)pElements) TYPE;

	mov	edx, DWORD PTR _pElements$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77135[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T77135[ebp], 0
	je	SHORT $L77136
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T77135[ebp]
	call	??0INIENTRY@@QAE@PBG0H@Z		; INIENTRY::INIENTRY
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L77137
$L77136:
	mov	DWORD PTR -24+[ebp], 0
$L77137:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T77134[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $L76392
$L76393:

; 63   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L77138:
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T77135[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L77141:
	mov	eax, OFFSET FLAT:$T77140
	jmp	___CxxFrameHandler
text$x	ENDS
?ConstructElements@@YGXPAUINIENTRY@@H@Z ENDP		; ConstructElements
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __P$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAPAUINISECTION@@H@Z
_TEXT	SEGMENT
$T77151 = -4
_pElements$ = 8
_nCount$ = 12
?ConstructElements@@YGXPAPAUINISECTION@@H@Z PROC NEAR	; ConstructElements, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
$L76401:

; 54   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L76405
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L76405
	push	55					; 00000037H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L76405
	int	3
$L76405:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L76401

; 55   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 56   : 
; 57   : 	// first do bit-wise zero initialization
; 58   : 	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	// then call the constructor(s)
; 61   : 	for (; nCount--; pElements++)

	jmp	SHORT $L76408
$L76409:
	mov	edx, DWORD PTR _pElements$[ebp]
	add	edx, 4
	mov	DWORD PTR _pElements$[ebp], edx
$L76408:
	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L76410

; 62   : 		::new((void*)pElements) TYPE;

	mov	edx, DWORD PTR _pElements$[ebp]
	push	edx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77151[ebp], eax
	jmp	SHORT $L76409
$L76410:

; 63   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?ConstructElements@@YGXPAPAUINISECTION@@H@Z ENDP	; ConstructElements
_TEXT	ENDS
;	COMDAT ??_GINIENTRY@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GINIENTRY@@QAEPAXI@Z PROC NEAR			; INIENTRY::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1INIENTRY@@QAE@XZ			; INIENTRY::~INIENTRY
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L76417
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L76417:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GINIENTRY@@QAEPAXI@Z ENDP				; INIENTRY::`scalar deleting destructor'
_TEXT	ENDS
END
