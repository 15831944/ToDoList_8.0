	TITLE	D:\_CODE\Shared\urlricheditctrl.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_1CC@LAMD@?$AAM?$AAa?$AAg?$AAe?$AAl?$AAl?$AAa?$AAn?$AA?5?$AAM?$AAS?$AAW?$AAH?$AAE?$AAE?$AAL?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1O@JDNM@?$AAM?$AAo?$AAu?$AAs?$AAe?$AAZ?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@JHCA@?$AAM?$AAS?$AAW?$AAH?$AAE?$AAE?$AAL?$AA_?$AAR?$AAO?$AAL?$AAL?$AAM?$AAS?$AAG?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@MMPP@?$AAM?$AAS?$AAH?$AA_?$AAW?$AAH?$AAE?$AAE?$AAL?$AAS?$AAU?$AAP?$AAP?$AAO?$AAR?$AAT?$AA_?$AAM?$AAS?$AAG@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CK@GMOB@?$AAM?$AAS?$AAH?$AA_?$AAS?$AAC?$AAR?$AAO?$AAL?$AAL?$AA_?$AAL?$AAI?$AAN?$AAE?$AAS?$AA_?$AAM?$AAS?$AAG@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@DBHF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@KPKN@D?3?2_CODE?2Shared?2Subclass?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MDCF@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KIFI@with?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LOPF@?5elements?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DANH@?6?7?$FL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MNLE@?$FN?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHwnd@CSubclassWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCWnd@CSubclassWnd@@QBEPAVCWnd@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExStyle@CSubclassWnd@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStyle@CSubclassWnd@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invalidate@CSubclassWnd@@QBEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScWindowProc@CSubclasser@@MAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTopSubclasser@CSubclasser@@MAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScPreDetachWindow@CSubclasser@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScPostDetachWindow@CSubclasser@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E270
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E271
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E273
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E274
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PROTOCOL@@QAE@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CPlex@@QAEPAXXZ
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CTypedPtrList@VCObList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CTypedPtrList@VCObList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypedPtrList@VCObList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CTypedPtrList@VCPtrList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CTypedPtrList@VCPtrList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTypedPtrList@VCPtrList@@PAV1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasFlag@Misc@@YAHKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E284
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E285
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Translate@CXmlCharMap@@KAHHPAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mapChar@?1??Translate@CXmlCharMap@@KAHHPAVCString@@@Z@$AV?$CMap@HHVCString@@PBG@@A
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E291
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E292
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E293
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E294
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CUrlRichEditCtrl@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUrlRichEditCtrl@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUrlRichEditCtrl@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PROTOCOL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeText@CUrlRichEditCtrl@@IAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0URLITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1URLITEM@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoToUrl@CUrlRichEditCtrl@@QBEHABVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_MailItem@OutlookAPI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSelection@OutlookAPI@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Selection@OutlookAPI@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Paste@CUrlRichEditCtrl@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindUrlEx@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTimer@CUrlRichEditCtrl@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAUIUnknown@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@ABU_GUID@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@PAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEAAV0@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInterfacePtr@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CTypedPtrList@VCObList@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CTypedPtrList@VCPtrList@@PAV1@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$_CTypedPtrList@VCObList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$_CTypedPtrList@VCPtrList@@PAV1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateObject@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEJABU_GUID@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateObject@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAEJPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIID@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@SAABU_GUID@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_CIP@UIUnknown@@$1?IID_IUnknown@@3U_GUID@@B@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CMap@VCString@@PBGHAAH@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CMap@HHVCString@@PBG@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@?$CMap@HHVCString@@PBG@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lookup@?$CMap@HHVCString@@PBG@@QBEHHAAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAt@?$CMap@HHVCString@@PBG@@QAEXHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CMap@HHVCString@@PBG@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CMap@HHVCString@@PBG@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CMap@HHVCString@@PBG@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CMap@HHVCString@@PBG@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4URLITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CMap@HHVCString@@PBG@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAt@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QAEXW4OUTLOOK_FIELDTYPE@@AAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextAssoc@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QBEXAAPAU__POSITION@@AAW4OUTLOOK_FIELDTYPE@@AAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAW4OUTLOOK_FIELDTYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBW4OUTLOOK_FIELDTYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CMap@HHVCString@@PBG@@QAEAAVCString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CMap@HHVCString@@PBG@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@HHVCString@@PBG@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextAssoc@?$CMap@HHVCString@@PBG@@QBEXAAPAU__POSITION@@AAHAAVCString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAssocAt@?$CMap@HHVCString@@PBG@@IBEPAUCAssoc@1@HAAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0URLITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GURLITEM@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PROTOCOL@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4PROTOCOL@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPROTOCOL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAUPROTOCOL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QAEAAVCString@@W4OUTLOOK_FIELDTYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAW4OUTLOOK_FIELDTYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructElements@@YGXPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareElements@@YGHPBVCString@@PBQBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHashTable@?$CMap@HHVCString@@PBG@@QAEXIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewAssoc@?$CMap@HHVCString@@PBG@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashKey@@YGIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareElements@@YGHPBH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHashTable@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@QAEXIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewAssoc@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAssocAt@?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@IBEPAUCAssoc@1@W4OUTLOOK_FIELDTYPE@@AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAW4OUTLOOK_FIELDTYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HashKey@@YGIW4OUTLOOK_FIELDTYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareElements@@YGHPBW4OUTLOOK_FIELDTYPE@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCNoTrackObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CNoTrackObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CMap@HHVCString@@PBG@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CMap@VCString@@PBGHAAH@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CMap@W4OUTLOOK_FIELDTYPE@@W41@VCString@@AAV2@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CArray@UPROTOCOL@@AAU1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CArray@UURLITEM@@AAU1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$_CTypedPtrList@VCPtrList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$_CTypedPtrList@VCObList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CUrlRichEditCtrl@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrList@VCPtrList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CTypedPtrList@VCObList@@PAV1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSubclasser@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?FILEPREFIX@@3PBGB				; FILEPREFIX
PUBLIC	?OnChangeText@CUrlRichEditCtrl@@IAEHXZ		; CUrlRichEditCtrl::OnChangeText
PUBLIC	?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z	; CUrlRichEditCtrl::OnRButtonUp
PUBLIC	?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z		; CUrlRichEditCtrl::OnKeyUp
PUBLIC	?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z ; CUrlRichEditCtrl::OnRButtonDown
PUBLIC	?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z	; CUrlRichEditCtrl::OnShowWindow
PUBLIC	?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z ; CUrlRichEditCtrl::OnCreate
PUBLIC	?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z ; CUrlRichEditCtrl::OnContextMenu
PUBLIC	?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z	; CUrlRichEditCtrl::OnSysKeyDown
PUBLIC	?OnTimer@CUrlRichEditCtrl@@IAEXI@Z		; CUrlRichEditCtrl::OnTimer
PUBLIC	?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z	; CUrlRichEditCtrl::OnLButtonUp
PUBLIC	?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z		; CUrlRichEditCtrl::OnSetFont
PUBLIC	?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z		; CUrlRichEditCtrl::OnSetText
PUBLIC	?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z		; CUrlRichEditCtrl::OnDropFiles
PUBLIC	?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z ; CUrlRichEditCtrl::OnNotifyLink
PUBLIC	?_messageEntries@CUrlRichEditCtrl@@0QBUAFX_MSGMAP_ENTRY@@B ; CUrlRichEditCtrl::_messageEntries
PUBLIC	?messageMap@CUrlRichEditCtrl@@1UAFX_MSGMAP@@B	; CUrlRichEditCtrl::messageMap
PUBLIC	?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ ; CUrlRichEditCtrl::_GetBaseMessageMap
_BSS	SEGMENT
_?bAFInHere@?1??ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z@4HA DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_$S272	DD	FLAT:_$E271
_$S275	DD	FLAT:_$E274
CRT$XCU	ENDS
_DATA	SEGMENT
__szAfxTempl DB	'afxtempl.h', 00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S286	DD	FLAT:_$E285
CRT$XCU	ENDS
_DATA	SEGMENT
	ORG $+5
_XMLCHARARRAY DD 03cH
	DD	FLAT:$SG76114
	DD	03eH
	DD	FLAT:$SG76115
	DD	022H
	DD	FLAT:$SG76116
	DD	026H
	DD	FLAT:$SG76117
	DD	091H
	DD	FLAT:$SG76118
	DD	092H
	DD	FLAT:$SG76119
	DD	093H
	DD	FLAT:$SG76120
	DD	094H
	DD	FLAT:$SG76121
	DD	085H
	DD	FLAT:$SG76122
_THIS_FILE DB	'D:\_CODE\Shared\urlricheditctrl.cpp', 00H
_URLDELIMS DD	FLAT:$SG77221
	DD	FLAT:$SG77222
	DD	FLAT:$SG77223
	DD	FLAT:$SG77224
	DD	FLAT:$SG77225
	DD	FLAT:$SG77226
?FILEPREFIX@@3PBGB DD FLAT:$SG77228			; FILEPREFIX
_DATA	ENDS
CRT$XCU	SEGMENT
_$S295	DD	FLAT:_$E294
CRT$XCU	ENDS
CONST	SEGMENT
?messageMap@CUrlRichEditCtrl@@1UAFX_MSGMAP@@B DD FLAT:?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ ; CUrlRichEditCtrl::messageMap
	DD	FLAT:?_messageEntries@CUrlRichEditCtrl@@0QBUAFX_MSGMAP_ENTRY@@B
?_messageEntries@CUrlRichEditCtrl@@0QBUAFX_MSGMAP_ENTRY@@B DD 0bd11H ; CUrlRichEditCtrl::_messageEntries
	DD	0300H
	DD	00H
	DD	00H
	DD	023H
	DD	FLAT:?OnChangeText@CUrlRichEditCtrl@@IAEHXZ
	DD	0205H
	DD	00H
	DD	00H
	DD	00H
	DD	031H
	DD	FLAT:?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
	DD	0101H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z
	DD	0204H
	DD	00H
	DD	00H
	DD	00H
	DD	031H
	DD	FLAT:?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	09H
	DD	FLAT:?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z
	DD	07bH
	DD	00H
	DD	00H
	DD	00H
	DD	019H
	DD	FLAT:?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z
	DD	0104H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	FLAT:?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z
	DD	0113H
	DD	00H
	DD	00H
	DD	00H
	DD	0dH
	DD	FLAT:?OnTimer@CUrlRichEditCtrl@@IAEXI@Z
	DD	0202H
	DD	00H
	DD	00H
	DD	00H
	DD	031H
	DD	FLAT:?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
	DD	0cH
	DD	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z
	DD	030H
	DD	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z
	DD	0233H
	DD	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z
	DD	0bc4eH
	DD	070bH
	DD	00H
	DD	00H
	DD	027H
	DD	FLAT:?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
_DATA	SEGMENT
$SG73669 DB	'W', 00H, 'M', 00H, '_', 00H, 'U', 00H, 'R', 00H, 'E', 00H
	DB	'N', 00H, '_', 00H, 'C', 00H, 'U', 00H, 'S', 00H, 'T', 00H, 'O'
	DB	00H, 'M', 00H, 'U', 00H, 'R', 00H, 'L', 00H, 00H, 00H
$SG73681 DB	'W', 00H, 'M', 00H, '_', 00H, 'U', 00H, 'R', 00H, 'E', 00H
	DB	'N', 00H, '_', 00H, 'F', 00H, 'A', 00H, 'I', 00H, 'L', 00H, 'E'
	DB	00H, 'D', 00H, 'U', 00H, 'R', 00H, 'L', 00H, 00H, 00H
$SG76004 DB	'H', 00H, 'T', 00H, 'M', 00H, 'L', 00H, ' ', 00H, 'F', 00H
	DB	'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, 00H, 00H
$SG76114 DB	'&', 00H, 'l', 00H, 't', 00H, ';', 00H, 00H, 00H
	ORG $+2
$SG76115 DB	'&', 00H, 'g', 00H, 't', 00H, ';', 00H, 00H, 00H
	ORG $+2
$SG76116 DB	'&', 00H, 'q', 00H, 'u', 00H, 'o', 00H, 't', 00H, ';', 00H
	DB	00H, 00H
	ORG $+2
$SG76117 DB	'&', 00H, 'a', 00H, 'm', 00H, 'p', 00H, ';', 00H, 00H, 00H
$SG76118 DB	'&', 00H, '#', 00H, '8', 00H, '2', 00H, '1', 00H, '6', 00H
	DB	';', 00H, 00H, 00H
$SG76119 DB	'&', 00H, '#', 00H, '8', 00H, '2', 00H, '1', 00H, '7', 00H
	DB	';', 00H, 00H, 00H
$SG76120 DB	'&', 00H, '#', 00H, '8', 00H, '2', 00H, '2', 00H, '0', 00H
	DB	';', 00H, 00H, 00H
$SG76121 DB	'&', 00H, '#', 00H, '8', 00H, '2', 00H, '2', 00H, '1', 00H
	DB	';', 00H, 00H, 00H
$SG76122 DB	'.', 00H, '.', 00H, '.', 00H, 00H, 00H
$SG77221 DB	' ', 00H, 00H, 00H
$SG77222 DB	0aH, 00H, 00H, 00H
$SG77223 DB	09H, 00H, 00H, 00H
$SG77224 DB	',', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG77225 DB	'.', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG77226 DB	'<', 00H, 00H, 00H
$SG77228 DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 00H, 00H
$SG77232 DB	'.', 00H, ',', 00H, ';', 00H, ':', 00H, '(', 00H, ')', 00H
	DB	'{', 00H, '}', 00H, '[', 00H, ']', 00H, '<', 00H, '>', 00H, '&'
	DB	00H, '*', 00H, '~', 00H, '?', 00H, '\', 00H, '"', 00H, '''', 00H
	DB	00H, 00H
_DATA	ENDS
EXTRN	__chkesp:NEAR
;	COMDAT _$E271
_TEXT	SEGMENT
_$E271	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E270
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E271	ENDP
_TEXT	ENDS
EXTRN	__imp__RegisterWindowMessageW@4:NEAR
_BSS	SEGMENT
_WM_UREN_CUSTOMURL DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E270
_TEXT	SEGMENT
_$E270	PROC NEAR					; COMDAT

; 16   : const UINT WM_UREN_CUSTOMURL = ::RegisterWindowMessage(_T("WM_UREN_CUSTOMURL")); // lParam == full url

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	push	OFFSET FLAT:$SG73669
	call	DWORD PTR __imp__RegisterWindowMessageW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _WM_UREN_CUSTOMURL, eax
	pop	esi
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E270	ENDP
_TEXT	ENDS
;	COMDAT _$E274
_TEXT	SEGMENT
_$E274	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E273
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E274	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_WM_UREN_FAILEDURL DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E273
_TEXT	SEGMENT
_$E273	PROC NEAR					; COMDAT

; 17   : const UINT WM_UREN_FAILEDURL = ::RegisterWindowMessage(_T("WM_UREN_FAILEDURL")); // lParam == full url

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	push	OFFSET FLAT:$SG73681
	call	DWORD PTR __imp__RegisterWindowMessageW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _WM_UREN_FAILEDURL, eax
	pop	esi
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E273	ENDP
_TEXT	ENDS
;	COMDAT _$E285
_TEXT	SEGMENT
_$E285	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E284
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E285	ENDP
_TEXT	ENDS
EXTRN	__imp__RegisterClipboardFormatW@4:NEAR
_BSS	SEGMENT
_CF_HTML DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _$E284
_TEXT	SEGMENT
_$E284	PROC NEAR					; COMDAT

; 42   : static UINT CF_HTML = ::RegisterClipboardFormat(_T("HTML Format"));

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	push	OFFSET FLAT:$SG76004
	call	DWORD PTR __imp__RegisterClipboardFormatW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _CF_HTML, eax
	pop	esi
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E284	ENDP
_TEXT	ENDS
;	COMDAT _$E294
_TEXT	SEGMENT
_$E294	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	call	_$E291
	call	_$E293
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E294	ENDP
_TEXT	ENDS
EXTRN	??0CString@@QAE@PBG@Z:NEAR			; CString::CString
_BSS	SEGMENT
_ENDPUNCTUATION DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E291
_TEXT	SEGMENT
_$E291	PROC NEAR					; COMDAT

; 45   : const CString ENDPUNCTUATION(_T(".,;:(){}[]<>&*~?\\\"'"));

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG77232
	mov	ecx, OFFSET FLAT:_ENDPUNCTUATION
	call	??0CString@@QAE@PBG@Z			; CString::CString
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E291	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E293
_TEXT	SEGMENT
_$E293	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:_$E292
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E293	ENDP
_TEXT	ENDS
EXTRN	??1CString@@QAE@XZ:NEAR				; CString::~CString
;	COMDAT _$E292
_TEXT	SEGMENT
_$E292	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:_ENDPUNCTUATION
	call	??1CString@@QAE@XZ			; CString::~CString
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
_$E292	ENDP
_TEXT	ENDS
PUBLIC	?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z ; CRichEditBaseCtrl::GetNewStorage
PUBLIC	?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z ; CRichEditBaseCtrl::GetInPlaceContext
PUBLIC	?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z	; CRichEditBaseCtrl::ShowContainerUI
PUBLIC	?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z ; CRichEditBaseCtrl::QueryInsertObject
PUBLIC	?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z ; CRichEditBaseCtrl::DeleteObject
PUBLIC	?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z ; CRichEditBaseCtrl::ContextSensitiveHelp
PUBLIC	?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z ; CRichEditBaseCtrl::GetClipboardData
PUBLIC	?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ ; CRichEditBaseCtrl::NewFindReplaceDlg
PUBLIC	??0CUrlRichEditCtrl@@QAE@XZ			; CUrlRichEditCtrl::CUrlRichEditCtrl
PUBLIC	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z	; CUrlRichEditCtrl::AddProtocol
PUBLIC	??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ		; CArray<URLITEM,URLITEM &>::CArray<URLITEM,URLITEM &>
PUBLIC	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ		; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
PUBLIC	??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ		; CArray<PROTOCOL,PROTOCOL &>::CArray<PROTOCOL,PROTOCOL &>
PUBLIC	??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ		; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
PUBLIC	?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ	; CUrlRichEditCtrl::PreSubclassWindow
PUBLIC	?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z ; CUrlRichEditCtrl::SendNotifyCustomUrl
PUBLIC	?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z ; CUrlRichEditCtrl::SendNotifyFailedUrl
PUBLIC	?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ ; CUrlRichEditCtrl::GetMessageMap
PUBLIC	?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z ; CUrlRichEditCtrl::QueryAcceptData
PUBLIC	?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z ; CUrlRichEditCtrl::GetDragDropEffect
PUBLIC	?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z ; CUrlRichEditCtrl::GetContextMenu
PUBLIC	?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z ; CUrlRichEditCtrl::GetAcceptableClipFormat
PUBLIC	??_7CUrlRichEditCtrl@@6B@			; CUrlRichEditCtrl::`vftable'
PUBLIC	??_GCUrlRichEditCtrl@@UAEPAXI@Z			; CUrlRichEditCtrl::`scalar deleting destructor'
PUBLIC	??_ECUrlRichEditCtrl@@UAEPAXI@Z			; CUrlRichEditCtrl::`vector deleting destructor'
EXTRN	?Create@CWnd@@UAEHPBG0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z:NEAR ; CWnd::Create
EXTRN	?Serialize@CObject@@UAEXAAVCArchive@@@Z:NEAR	; CObject::Serialize
EXTRN	?DestroyWindow@CWnd@@UAEHXZ:NEAR		; CWnd::DestroyWindow
EXTRN	?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTW@@@Z:NEAR ; CWnd::PreCreateWindow
EXTRN	?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z:NEAR	; CWnd::CalcWindowRect
EXTRN	?GetRuntimeClass@CRichEditCtrl@@UBEPAUCRuntimeClass@@XZ:NEAR ; CRichEditCtrl::GetRuntimeClass
EXTRN	?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOW@@@Z:NEAR ; CWnd::OnToolHitTest
EXTRN	??0CRichEditBaseCtrl@@QAE@H@Z:NEAR		; CRichEditBaseCtrl::CRichEditBaseCtrl
EXTRN	??1CRichEditBaseCtrl@@UAE@XZ:NEAR		; CRichEditBaseCtrl::~CRichEditBaseCtrl
EXTRN	?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z:NEAR ; CWnd::GetScrollBarCtrl
EXTRN	?WinHelpW@CWnd@@UAEXKI@Z:NEAR			; CWnd::WinHelpW
EXTRN	?ContinueModal@CWnd@@UAEHXZ:NEAR		; CWnd::ContinueModal
EXTRN	?EndModalLoop@CWnd@@UAEXH@Z:NEAR		; CWnd::EndModalLoop
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:NEAR			; CWnd::OnCommand
EXTRN	?OnNotify@CWnd@@MAEHIJPAJ@Z:NEAR		; CWnd::OnNotify
EXTRN	?OnFindNext@CRichEditBaseCtrl@@MAEXPBGHHH@Z:NEAR ; CRichEditBaseCtrl::OnFindNext
EXTRN	?OnReplaceSel@CRichEditBaseCtrl@@MAEXPBGHHH0@Z:NEAR ; CRichEditBaseCtrl::OnReplaceSel
EXTRN	?OnReplaceAll@CRichEditBaseCtrl@@MAEXPBG0HH@Z:NEAR ; CRichEditBaseCtrl::OnReplaceAll
EXTRN	??0CPoint@@QAE@XZ:NEAR				; CPoint::CPoint
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:NEAR ; CCmdTarget::OnCmdMsg
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:NEAR	; CCmdTarget::IsInvokeAllowed
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:NEAR ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:NEAR	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:NEAR ; CCmdTarget::GetTypeLibCache
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:NEAR ; CCmdTarget::GetTypeLib
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:NEAR ; CCmdTarget::GetCommandMap
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:NEAR ; CCmdTarget::GetDispatchMap
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:NEAR ; CCmdTarget::GetConnectionMap
EXTRN	?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ:NEAR ; CCmdTarget::GetInterfaceMap
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:NEAR ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:NEAR	; CCmdTarget::OnCreateAggregates
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:NEAR ; CCmdTarget::GetInterfaceHook
EXTRN	?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ:NEAR ; CWnd::GetSuperWndProcAddr
EXTRN	?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z:NEAR ; CWnd::DoDataExchange
EXTRN	?BeginModalState@CWnd@@UAEXXZ:NEAR		; CWnd::BeginModalState
EXTRN	?EndModalState@CWnd@@UAEXXZ:NEAR		; CWnd::EndModalState
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:NEAR ; CWnd::PreTranslateMessage
EXTRN	?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z:NEAR ; CWnd::OnAmbientProperty
EXTRN	?WindowProc@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::WindowProc
EXTRN	?OnWndMsg@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnWndMsg
EXTRN	?DefWindowProcW@CWnd@@MAEJIIJ@Z:NEAR		; CWnd::DefWindowProcW
EXTRN	?PostNcDestroy@CWnd@@MAEXXZ:NEAR		; CWnd::PostNcDestroy
EXTRN	?OnChildNotify@CWnd@@MAEHIIJPAJ@Z:NEAR		; CWnd::OnChildNotify
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:NEAR		; CWnd::CheckAutoCenter
EXTRN	?AssertValid@CWnd@@UBEXXZ:NEAR			; CWnd::AssertValid
EXTRN	?Dump@CWnd@@UBEXAAVCDumpContext@@@Z:NEAR	; CWnd::Dump
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:NEAR ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:NEAR ; CCmdTarget::GetConnectionHook
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?IsFrameWnd@CWnd@@UBEHXZ:NEAR			; CWnd::IsFrameWnd
EXTRN	?OnFinalRelease@CWnd@@UAEXXZ:NEAR		; CWnd::OnFinalRelease
EXTRN	??0CRichEditNcBorder@@QAE@XZ:NEAR		; CRichEditNcBorder::CRichEditNcBorder
EXTRN	??1CRichEditNcBorder@@UAE@XZ:NEAR		; CRichEditNcBorder::~CRichEditNcBorder
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:NEAR ; CWnd::SetOccDialogInfo
;	COMDAT ??_7CUrlRichEditCtrl@@6B@
; File D:\_CODE\Shared\urlricheditctrl.cpp
CONST	SEGMENT
??_7CUrlRichEditCtrl@@6B@ DD FLAT:?GetRuntimeClass@CRichEditCtrl@@UBEPAUCRuntimeClass@@XZ ; CUrlRichEditCtrl::`vftable'
	DD	FLAT:??_ECUrlRichEditCtrl@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CWnd@@UBEXXZ
	DD	FLAT:?Dump@CWnd@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBG0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTW@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOW@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpW@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcW@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z
	DD	FLAT:?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z
	DD	FLAT:?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z
	DD	FLAT:?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z
	DD	FLAT:?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z
	DD	FLAT:?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z
	DD	FLAT:?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z
	DD	FLAT:?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z
	DD	FLAT:?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z
	DD	FLAT:?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z
	DD	FLAT:?OnFindNext@CRichEditBaseCtrl@@MAEXPBGHHH@Z
	DD	FLAT:?OnReplaceSel@CRichEditBaseCtrl@@MAEXPBGHHH0@Z
	DD	FLAT:?OnReplaceAll@CRichEditBaseCtrl@@MAEXPBG0HH@Z
	DD	FLAT:?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ
	DD	FLAT:?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z
	DD	FLAT:?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z
	DD	FLAT:?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z
CONST	ENDS
;	COMDAT data
data	SEGMENT
$SG77246 DB	'w', 00H, 'w', 00H, 'w', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG77247 DB	'h', 00H, 't', 00H, 't', 00H, 'p', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 00H, 00H
$SG77248 DB	'h', 00H, 't', 00H, 't', 00H, 'p', 00H, 's', 00H, ':', 00H
	DB	'/', 00H, '/', 00H, 00H, 00H
	ORG $+2
$SG77249 DB	'f', 00H, 't', 00H, 'p', 00H, ':', 00H, '/', 00H, '/', 00H
	DB	00H, 00H
	ORG $+2
$SG77250 DB	'o', 00H, 'u', 00H, 't', 00H, 'l', 00H, 'o', 00H, 'o', 00H
	DB	'k', 00H, ':', 00H, 00H, 00H
	ORG $+2
$SG77251 DB	'm', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'o', 00H
	DB	':', 00H, 00H, 00H
$SG77252 DB	'N', 00H, 'o', 00H, 't', 00H, 'e', 00H, 's', 00H, ':', 00H
	DB	'/', 00H, '/', 00H, 00H, 00H
	ORG $+2
$SG77253 DB	'e', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, 'e', 00H, ':', 00H, '/', 00H, '/', 00H, 00H, 00H
$SG77254 DB	'o', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	'e', 00H, ':', 00H, '/', 00H, '/', 00H, '/', 00H, 00H, 00H
$SG77255 DB	'e', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'l', 00H, ':', 00H
	DB	00H, 00H
	ORG $+2
$SG77256 DB	'w', 00H, 'i', 00H, 'n', 00H, 'w', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, ':', 00H, 00H, 00H
	ORG $+2
$SG77257 DB	't', 00H, 'h', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ':', 00H, '/'
	DB	00H, '/', 00H, 00H, 00H
	ORG $+2
$SG77258 DB	'w', 00H, 'i', 00H, 'k', 00H, 'i', 00H, ':', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T79754	DD	019930520H
	DD	04H
	DD	FLAT:$T79757
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79757	DD	0ffffffffH
	DD	FLAT:$L79747
	DD	00H
	DD	FLAT:$L79748
	DD	01H
	DD	FLAT:$L79749
	DD	02H
	DD	FLAT:$L79750
xdata$x	ENDS
;	COMDAT ??0CUrlRichEditCtrl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CUrlRichEditCtrl@@QAE@XZ PROC NEAR			; CUrlRichEditCtrl::CUrlRichEditCtrl, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79755
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CRichEditBaseCtrl@@QAE@H@Z		; CRichEditBaseCtrl::CRichEditBaseCtrl
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ	; CArray<URLITEM,URLITEM &>::CArray<URLITEM,URLITEM &>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ	; CArray<PROTOCOL,PROTOCOL &>::CArray<PROTOCOL,PROTOCOL &>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0CRichEditNcBorder@@QAE@XZ		; CRichEditNcBorder::CRichEditNcBorder
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	call	??0CPoint@@QAE@XZ			; CPoint::CPoint
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+224], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CUrlRichEditCtrl@@6B@ ; CUrlRichEditCtrl::`vftable'

; 59   : 	AddProtocol(_T("www."), FALSE);

	push	0
	push	OFFSET FLAT:$SG77246
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 60   : 	AddProtocol(_T("http://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77247
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 61   : 	AddProtocol(_T("https://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77248
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 62   : 	AddProtocol(_T("ftp://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77249
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 63   : 	AddProtocol(_T("outlook:"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77250
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 64   : 	AddProtocol(_T("mailto:"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77251
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 65   : 	AddProtocol(_T("Notes://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77252
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 66   : 	AddProtocol(_T("evernote://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77253
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 67   : 	AddProtocol(_T("onenote:///"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77254
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 68   : 	AddProtocol(_T("excel:"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77255
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 69   : 	AddProtocol(_T("winword:"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77256
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 70   : 	AddProtocol(_T("thunderlink://"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77257
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 71   : 	AddProtocol(_T("wiki:"), FALSE);

	push	0
	push	OFFSET FLAT:$SG77258
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 72   : 
; 73   : 	// file protocol is a bit special
; 74   : 	AddProtocol(FILEPREFIX, FALSE);

	push	0
	mov	eax, DWORD PTR ?FILEPREFIX@@3PBGB	; FILEPREFIX
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ; CUrlRichEditCtrl::AddProtocol

; 75   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79747:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRichEditBaseCtrl@@UAE@XZ		; CRichEditBaseCtrl::~CRichEditBaseCtrl
	ret	0
$L79748:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	ret	0
$L79749:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ	; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
	ret	0
$L79750:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??1CRichEditNcBorder@@UAE@XZ		; CRichEditNcBorder::~CRichEditNcBorder
	ret	0
$L79755:
	mov	eax, OFFSET FLAT:$T79754
	jmp	___CxxFrameHandler
text$x	ENDS
??0CUrlRichEditCtrl@@QAE@XZ ENDP			; CUrlRichEditCtrl::CUrlRichEditCtrl
;	COMDAT ?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z
_TEXT	SEGMENT
_this$ = -4
?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z PROC NEAR ; CRichEditBaseCtrl::GetNewStorage, COMDAT

; 181  : 	virtual HRESULT GetNewStorage(LPSTORAGE* /*lplpstg*/) { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNewStorage@CRichEditBaseCtrl@@MAEJPAPAUIStorage@@@Z ENDP ; CRichEditBaseCtrl::GetNewStorage
_TEXT	ENDS
;	COMDAT ?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z
_TEXT	SEGMENT
_this$ = -4
?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z PROC NEAR ; CRichEditBaseCtrl::GetInPlaceContext, COMDAT

; 183  : 		LPOLEINPLACEUIWINDOW FAR* /*lplpDoc*/, LPOLEINPLACEFRAMEINFO /*lpFrameInfo*/) { return S_FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetInPlaceContext@CRichEditBaseCtrl@@MAEJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagOIFI@@@Z ENDP ; CRichEditBaseCtrl::GetInPlaceContext
_TEXT	ENDS
;	COMDAT ?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z
_TEXT	SEGMENT
_this$ = -4
?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z PROC NEAR	; CRichEditBaseCtrl::ShowContainerUI, COMDAT

; 184  : 	virtual HRESULT ShowContainerUI(BOOL /*fShow*/) { return S_FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?ShowContainerUI@CRichEditBaseCtrl@@MAEJH@Z ENDP	; CRichEditBaseCtrl::ShowContainerUI
_TEXT	ENDS
;	COMDAT ?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z
_TEXT	SEGMENT
_this$ = -4
?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z PROC NEAR ; CRichEditBaseCtrl::QueryInsertObject, COMDAT

; 185  : 	virtual HRESULT QueryInsertObject(LPCLSID /*lpclsid*/, LPSTORAGE /*lpstg*/, LONG /*cp*/) { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?QueryInsertObject@CRichEditBaseCtrl@@MAEJPAU_GUID@@PAUIStorage@@J@Z ENDP ; CRichEditBaseCtrl::QueryInsertObject
_TEXT	ENDS
;	COMDAT ?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z PROC NEAR ; CRichEditBaseCtrl::DeleteObject, COMDAT

; 186  : 	virtual HRESULT DeleteObject(LPOLEOBJECT /*lpoleobj*/) { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteObject@CRichEditBaseCtrl@@MAEJPAUIOleObject@@@Z ENDP ; CRichEditBaseCtrl::DeleteObject
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z
_TEXT	SEGMENT
_this$ = -4
?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z PROC NEAR ; CRichEditBaseCtrl::ContextSensitiveHelp, COMDAT

; 189  : 	virtual HRESULT ContextSensitiveHelp(BOOL /*fEnterMode*/) { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ContextSensitiveHelp@CRichEditBaseCtrl@@MAEJH@Z ENDP	; CRichEditBaseCtrl::ContextSensitiveHelp
_TEXT	ENDS
;	COMDAT ?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z
_TEXT	SEGMENT
_this$ = -4
?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z PROC NEAR ; CRichEditBaseCtrl::GetClipboardData, COMDAT

; 190  : 	virtual HRESULT GetClipboardData(CHARRANGE FAR* /*lpchrg*/, DWORD /*reco*/, LPDATAOBJECT FAR* /*lplpdataobj*/) { return E_NOTIMPL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, -2147467263			; 80004001H
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetClipboardData@CRichEditBaseCtrl@@MAEJPAU_charrange@@KPAPAUIDataObject@@@Z ENDP ; CRichEditBaseCtrl::GetClipboardData
_TEXT	ENDS
EXTRN	??2CObject@@SGPAXI@Z:NEAR			; CObject::operator new
EXTRN	??3CObject@@SGXPAX@Z:NEAR			; CObject::operator delete
EXTRN	??0CFindReplaceDialog@@QAE@XZ:NEAR		; CFindReplaceDialog::CFindReplaceDialog
;	COMDAT xdata$x
; File D:\_CODE\Shared\richeditbasectrl.h
xdata$x	SEGMENT
$T79784	DD	019930520H
	DD	01H
	DD	FLAT:$T79786
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79786	DD	0ffffffffH
	DD	FLAT:$L79782
xdata$x	ENDS
;	COMDAT ?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ
_TEXT	SEGMENT
_this$ = -24
$T79778 = -16
$T79779 = -20
__$EHRec$ = -12
?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ PROC NEAR ; CRichEditBaseCtrl::NewFindReplaceDlg, COMDAT

; 200  : 	virtual CFindReplaceDialog* NewFindReplaceDlg() { return new CFindReplaceDialog; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79785
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	push	648					; 00000288H
	call	??2CObject@@SGPAXI@Z			; CObject::operator new
	mov	DWORD PTR $T79779[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T79779[ebp], 0
	je	SHORT $L79780
	mov	ecx, DWORD PTR $T79779[ebp]
	call	??0CFindReplaceDialog@@QAE@XZ		; CFindReplaceDialog::CFindReplaceDialog
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L79781
$L79780:
	mov	DWORD PTR -28+[ebp], 0
$L79781:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T79778[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T79778[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79782:
	mov	eax, DWORD PTR $T79779[ebp]
	push	eax
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
	ret	0
$L79785:
	mov	eax, OFFSET FLAT:$T79784
	jmp	___CxxFrameHandler
text$x	ENDS
?NewFindReplaceDlg@CRichEditBaseCtrl@@MAEPAVCFindReplaceDialog@@XZ ENDP ; CRichEditBaseCtrl::NewFindReplaceDlg
PUBLIC	??1CUrlRichEditCtrl@@UAE@XZ			; CUrlRichEditCtrl::~CUrlRichEditCtrl
;	COMDAT ??_GCUrlRichEditCtrl@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GCUrlRichEditCtrl@@UAEPAXI@Z PROC NEAR		; CUrlRichEditCtrl::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CUrlRichEditCtrl@@UAE@XZ		; CUrlRichEditCtrl::~CUrlRichEditCtrl
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L77262
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L77262:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCUrlRichEditCtrl@@UAEPAXI@Z ENDP			; CUrlRichEditCtrl::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79798	DD	019930520H
	DD	03H
	DD	FLAT:$T79800
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79800	DD	0ffffffffH
	DD	FLAT:$L79793
	DD	00H
	DD	FLAT:$L79794
	DD	01H
	DD	FLAT:$L79795
xdata$x	ENDS
;	COMDAT ??1CUrlRichEditCtrl@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1CUrlRichEditCtrl@@UAE@XZ PROC NEAR			; CUrlRichEditCtrl::~CUrlRichEditCtrl, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79799
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CUrlRichEditCtrl@@6B@ ; CUrlRichEditCtrl::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 79   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??1CRichEditNcBorder@@UAE@XZ		; CRichEditNcBorder::~CRichEditNcBorder
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ	; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRichEditBaseCtrl@@UAE@XZ		; CRichEditBaseCtrl::~CRichEditBaseCtrl
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79793:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRichEditBaseCtrl@@UAE@XZ		; CRichEditBaseCtrl::~CRichEditBaseCtrl
	ret	0
$L79794:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	ret	0
$L79795:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ	; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
	ret	0
$L79799:
	mov	eax, OFFSET FLAT:$T79798
	jmp	___CxxFrameHandler
text$x	ENDS
??1CUrlRichEditCtrl@@UAE@XZ ENDP			; CUrlRichEditCtrl::~CUrlRichEditCtrl
EXTRN	?messageMap@CRichEditBaseCtrl@@1UAFX_MSGMAP@@B:QWORD ; CRichEditBaseCtrl::messageMap
;	COMDAT ?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ PROC NEAR ; CUrlRichEditCtrl::_GetBaseMessageMap, COMDAT

; 81   : BEGIN_MESSAGE_MAP(CUrlRichEditCtrl, CRichEditBaseCtrl)

	push	ebp
	mov	ebp, esp
	mov	eax, OFFSET FLAT:?messageMap@CRichEditBaseCtrl@@1UAFX_MSGMAP@@B ; CRichEditBaseCtrl::messageMap
	pop	ebp
	ret	0
?_GetBaseMessageMap@CUrlRichEditCtrl@@KGPBUAFX_MSGMAP@@XZ ENDP ; CUrlRichEditCtrl::_GetBaseMessageMap
_TEXT	ENDS
;	COMDAT ?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ PROC NEAR ; CUrlRichEditCtrl::GetMessageMap, COMDAT

; 81   : BEGIN_MESSAGE_MAP(CUrlRichEditCtrl, CRichEditBaseCtrl)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?messageMap@CUrlRichEditCtrl@@1UAFX_MSGMAP@@B ; CUrlRichEditCtrl::messageMap
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMessageMap@CUrlRichEditCtrl@@MBEPBUAFX_MSGMAP@@XZ ENDP ; CUrlRichEditCtrl::GetMessageMap
_TEXT	ENDS
PUBLIC	?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z ; CArray<PROTOCOL,PROTOCOL &>::Add
PUBLIC	?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z	; CUrlRichEditCtrl::MatchProtocol
PUBLIC	??0PROTOCOL@@QAE@PBGH@Z				; PROTOCOL::PROTOCOL
PUBLIC	??1PROTOCOL@@QAE@XZ				; PROTOCOL::~PROTOCOL
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79812	DD	019930520H
	DD	01H
	DD	FLAT:$T79814
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79814	DD	0ffffffffH
	DD	FLAT:$L79810
xdata$x	ENDS
;	COMDAT ?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z
_TEXT	SEGMENT
_szProtocol$ = 8
_bWantNotify$ = 12
_this$ = -32
_nExist$ = -16
_prot$77348 = -24
$T79809 = -28
__$EHRec$ = -12
?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z PROC NEAR	; CUrlRichEditCtrl::AddProtocol, COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79813
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	int nExist = MatchProtocol(szProtocol);

	mov	eax, DWORD PTR _szProtocol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z ; CUrlRichEditCtrl::MatchProtocol
	mov	DWORD PTR _nExist$[ebp], eax

; 106  : 	
; 107  : 	if (nExist == -1)

	cmp	DWORD PTR _nExist$[ebp], -1
	jne	SHORT $L77347

; 109  : 		PROTOCOL prot(szProtocol, bWantNotify);

	mov	ecx, DWORD PTR _bWantNotify$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szProtocol$[ebp]
	push	edx
	lea	ecx, DWORD PTR _prot$77348[ebp]
	call	??0PROTOCOL@@QAE@PBGH@Z			; PROTOCOL::PROTOCOL
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		return m_aProtocols.Add(prot);

	lea	eax, DWORD PTR _prot$77348[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z ; CArray<PROTOCOL,PROTOCOL &>::Add
	mov	DWORD PTR $T79809[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _prot$77348[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	mov	eax, DWORD PTR $T79809[ebp]
	jmp	SHORT $L77345
$L77347:

; 112  : 	
; 113  : 	return nExist;

	mov	eax, DWORD PTR _nExist$[ebp]
$L77345:

; 114  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79810:
	lea	ecx, DWORD PTR _prot$77348[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	ret	0
$L79813:
	mov	eax, OFFSET FLAT:$T79812
	jmp	___CxxFrameHandler
text$x	ENDS
?AddProtocol@CUrlRichEditCtrl@@QAEHPBGH@Z ENDP		; CUrlRichEditCtrl::AddProtocol
;	COMDAT ??0PROTOCOL@@QAE@PBGH@Z
_TEXT	SEGMENT
_szProtocol$ = 8
_bNotify$ = 12
_this$ = -4
??0PROTOCOL@@QAE@PBGH@Z PROC NEAR			; PROTOCOL::PROTOCOL, COMDAT

; 28   :    PROTOCOL(LPCTSTR szProtocol = NULL, BOOL bNotify = FALSE) : sProtocol(szProtocol), bWantNotify(bNotify) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _szProtocol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _bNotify$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
??0PROTOCOL@@QAE@PBGH@Z ENDP				; PROTOCOL::PROTOCOL
_TEXT	ENDS
;	COMDAT ??1PROTOCOL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1PROTOCOL@@QAE@XZ PROC NEAR				; PROTOCOL::~PROTOCOL, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??1PROTOCOL@@QAE@XZ ENDP				; PROTOCOL::~PROTOCOL
_TEXT	ENDS
PUBLIC	?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ	; CArray<PROTOCOL,PROTOCOL &>::GetSize
PUBLIC	??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::operator[]
EXTRN	?GetLength@CString@@QBEHXZ:NEAR			; CString::GetLength
EXTRN	??BCString@@QBEPBGXZ:NEAR			; CString::operator unsigned short const *
EXTRN	__imp___wcsnicmp:NEAR
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79828	DD	019930520H
	DD	01H
	DD	FLAT:$T79830
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79830	DD	0ffffffffH
	DD	FLAT:$L79826
xdata$x	ENDS
;	COMDAT ?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z
_TEXT	SEGMENT
_szText$ = 8
_this$ = -36
_nProt$ = -16
_prot$77360 = -20
_$S296$77362 = -28
$T79825 = -32
__$EHRec$ = -12
?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z PROC NEAR	; CUrlRichEditCtrl::MatchProtocol, COMDAT

; 117  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79829
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 118  :    int nProt = m_aProtocols.GetSize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ ; CArray<PROTOCOL,PROTOCOL &>::GetSize
	mov	DWORD PTR _nProt$[ebp], eax
$L77358:

; 119  : 
; 120  :    while (nProt--)

	mov	eax, DWORD PTR _nProt$[ebp]
	mov	ecx, DWORD PTR _nProt$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nProt$[ebp], ecx
	test	eax, eax
	je	SHORT $L77359

; 122  :       const PROTOCOL& prot = m_aProtocols[nProt];

	mov	edx, DWORD PTR _nProt$[ebp]
	push	edx
	lea	eax, DWORD PTR _$S296$77362[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::operator[]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _$S296$77362[ebp]
	mov	DWORD PTR _prot$77360[ebp], ecx

; 123  : 
; 124  :       if (_tcsnicmp(szText, prot.sProtocol, prot.sProtocol.GetLength()) == 0)

	mov	ecx, DWORD PTR _prot$77360[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _prot$77360[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	edx, DWORD PTR _szText$[ebp]
	push	edx
	call	DWORD PTR __imp___wcsnicmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__chkesp
	test	eax, eax
	jne	SHORT $L77363

; 125  :          return nProt;

	mov	eax, DWORD PTR _nProt$[ebp]
	mov	DWORD PTR $T79825[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S296$77362[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	mov	eax, DWORD PTR $T79825[ebp]
	jmp	SHORT $L77355
$L77363:

; 126  :    }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S296$77362[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	jmp	$L77358
$L77359:

; 127  : 
; 128  :    return -1;

	or	eax, -1
$L77355:

; 129  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79826:
	lea	ecx, DWORD PTR _$S296$77362[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	ret	0
$L79829:
	mov	eax, OFFSET FLAT:$T79828
	jmp	___CxxFrameHandler
text$x	ENDS
?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z ENDP		; CUrlRichEditCtrl::MatchProtocol
EXTRN	?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z:NEAR ; CWnd::SetTimer
EXTRN	?KillTimer@CWnd@@QAEHH@Z:NEAR			; CWnd::KillTimer
;	COMDAT ?OnChangeText@CUrlRichEditCtrl@@IAEHXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeText@CUrlRichEditCtrl@@IAEHXZ PROC NEAR	; CUrlRichEditCtrl::OnChangeText, COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 	// kill any existing timer
; 134  : 	KillTimer(TIMER_REPARSE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillTimer@CWnd@@QAEHH@Z		; CWnd::KillTimer

; 135  : 
; 136  : 	// and start a new one
; 137  : 	SetTimer(TIMER_REPARSE, PAUSE, NULL);

	push	0
	push	1000					; 000003e8H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTimer@CWnd@@QAEIIIP6GXPAUHWND__@@IIK@Z@Z ; CWnd::SetTimer

; 138  : 	
; 139  : 	return FALSE;

	xor	eax, eax

; 140  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeText@CUrlRichEditCtrl@@IAEHXZ ENDP		; CUrlRichEditCtrl::OnChangeText
_TEXT	ENDS
EXTRN	?PasteFiles@CRichEditHelper@@SAHPAUHWND__@@ABVCStringArray@@W4RE_PASTE@@@Z:NEAR ; CRichEditHelper::PasteFiles
EXTRN	__imp__DragFinish@4:NEAR
EXTRN	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z:NEAR ; CRichEditCtrl::GetSel
EXTRN	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z:NEAR ; CRichEditCtrl::SetSel
EXTRN	?IsWindowEnabled@CWnd@@QBEHXZ:NEAR		; CWnd::IsWindowEnabled
EXTRN	??0CStringArray@@QAE@XZ:NEAR			; CStringArray::CStringArray
EXTRN	??1CStringArray@@UAE@XZ:NEAR			; CStringArray::~CStringArray
EXTRN	??0CString@@QAE@XZ:NEAR				; CString::CString
EXTRN	?GetDropFilePaths@FileMisc@@YAHPAUHDROP__@@AAVCStringArray@@@Z:NEAR ; FileMisc::GetDropFilePaths
EXTRN	__imp__CloseClipboard@0:NEAR
EXTRN	??BCWnd@@QBEPAUHWND__@@XZ:NEAR			; CWnd::operator HWND__ *
EXTRN	?GetStyle@CWnd@@QBEKXZ:NEAR			; CWnd::GetStyle
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79844	DD	019930520H
	DD	02H
	DD	FLAT:$T79846
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79846	DD	0ffffffffH
	DD	FLAT:$L79841
	DD	00H
	DD	FLAT:$L79842
xdata$x	ENDS
;	COMDAT ?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT
_wp$ = 8
_this$ = -64
_crSelOrg$ = -20
_bEnable$ = -32
_aFiles$ = -52
_sText$ = -24
_nNumFiles$ = -28
$T79839 = -56
$T79840 = -60
__$EHRec$ = -12
?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z PROC NEAR	; CUrlRichEditCtrl::OnDropFiles, COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79845
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	CHARRANGE crSelOrg;
; 145  : 	GetSel(crSelOrg); // save this off

	lea	eax, DWORD PTR _crSelOrg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 146  : 	BOOL bEnable = !(GetStyle() & ES_READONLY) && IsWindowEnabled();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStyle@CWnd@@QBEKXZ			; CWnd::GetStyle
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	SHORT $L79837
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWindowEnabled@CWnd@@QBEHXZ		; CWnd::IsWindowEnabled
	test	eax, eax
	je	SHORT $L79837
	mov	DWORD PTR -68+[ebp], 1
	jmp	SHORT $L79838
$L79837:
	mov	DWORD PTR -68+[ebp], 0
$L79838:
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR _bEnable$[ebp], ecx

; 147  : 	
; 148  : 	if (!bEnable)

	cmp	DWORD PTR _bEnable$[ebp], 0
	jne	SHORT $L77375

; 149  : 		return 0;

	xor	eax, eax
	jmp	$L77372
$L77375:

; 150  : 	
; 151  : 	CStringArray aFiles;

	lea	ecx, DWORD PTR _aFiles$[ebp]
	call	??0CStringArray@@QAE@XZ			; CStringArray::CStringArray
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 152  : 	CString sText;

	lea	ecx, DWORD PTR _sText$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 153  : 	
; 154  : 	SetSel(m_crDropSel);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 228				; 000000e4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 155  : 	
; 156  : 	int nNumFiles = FileMisc::GetDropFilePaths((HDROP)wp, aFiles);

	lea	eax, DWORD PTR _aFiles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wp$[ebp]
	push	ecx
	call	?GetDropFilePaths@FileMisc@@YAHPAUHDROP__@@AAVCStringArray@@@Z ; FileMisc::GetDropFilePaths
	add	esp, 8
	mov	DWORD PTR _nNumFiles$[ebp], eax

; 157  : 
; 158  : 	::DragFinish((HDROP)wp);

	mov	esi, esp
	mov	edx, DWORD PTR _wp$[ebp]
	push	edx
	call	DWORD PTR __imp__DragFinish@4
	cmp	esi, esp
	call	__chkesp

; 159  : 	::CloseClipboard();

	mov	esi, esp
	call	DWORD PTR __imp__CloseClipboard@0
	cmp	esi, esp
	call	__chkesp

; 160  : 
; 161  : 	if (nNumFiles > 0)

	cmp	DWORD PTR _nNumFiles$[ebp], 0
	jle	SHORT $L77381

; 162  : 		return CRichEditHelper::PasteFiles(*this, aFiles, REP_ASFILEURL);

	push	0
	lea	eax, DWORD PTR _aFiles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	call	?PasteFiles@CRichEditHelper@@SAHPAUHWND__@@ABVCStringArray@@W4RE_PASTE@@@Z ; CRichEditHelper::PasteFiles
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T79839[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aFiles$[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	mov	eax, DWORD PTR $T79839[ebp]
	jmp	SHORT $L77372
$L77381:

; 163  : 
; 164  : 	// else 
; 165  : 	return nNumFiles;

	mov	ecx, DWORD PTR _nNumFiles$[ebp]
	mov	DWORD PTR $T79840[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aFiles$[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	mov	eax, DWORD PTR $T79840[ebp]
$L77372:

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79841:
	lea	ecx, DWORD PTR _aFiles$[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	ret	0
$L79842:
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79845:
	mov	eax, OFFSET FLAT:$T79844
	jmp	___CxxFrameHandler
text$x	ENDS
?OnDropFiles@CUrlRichEditCtrl@@IAEJIJ@Z ENDP		; CUrlRichEditCtrl::OnDropFiles
EXTRN	?SendMessageW@CWnd@@QAEJIIJ@Z:NEAR		; CWnd::SendMessageW
EXTRN	?GetEventMask@CRichEditCtrl@@QBEJXZ:NEAR	; CRichEditCtrl::GetEventMask
EXTRN	?SetEventMask@CRichEditCtrl@@QAEKK@Z:NEAR	; CRichEditCtrl::SetEventMask
EXTRN	?DragAcceptFiles@CWnd@@QAEXH@Z:NEAR		; CWnd::DragAcceptFiles
EXTRN	?PreSubclassWindow@CRichEditBaseCtrl@@MAEXXZ:NEAR ; CRichEditBaseCtrl::PreSubclassWindow
EXTRN	?Initialize@CRichEditNcBorder@@QAEHPAUHWND__@@@Z:NEAR ; CRichEditNcBorder::Initialize
EXTRN	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ:NEAR	; CWnd::GetSafeHwnd
;	COMDAT ?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ PROC NEAR	; CUrlRichEditCtrl::PreSubclassWindow, COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 	SetEventMask(GetEventMask() | ENM_CHANGE | ENM_DROPFILES | ENM_DRAGDROPDONE );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEventMask@CRichEditCtrl@@QBEJXZ	; CRichEditCtrl::GetEventMask
	or	al, 1
	or	eax, 1048576				; 00100000H
	or	al, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEventMask@CRichEditCtrl@@QAEKK@Z	; CRichEditCtrl::SetEventMask

; 171  : 	DragAcceptFiles();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DragAcceptFiles@CWnd@@QAEXH@Z		; CWnd::DragAcceptFiles

; 172  : 	
; 173  : 	// enable multilevel undo
; 174  : 	SendMessage(EM_SETTEXTMODE, TM_MULTILEVELUNDO);

	push	0
	push	8
	push	1113					; 00000459H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 175  : 
; 176  : 	m_ncBorder.Initialize(GetSafeHwnd());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ	; CWnd::GetSafeHwnd
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?Initialize@CRichEditNcBorder@@QAEHPAUHWND__@@@Z ; CRichEditNcBorder::Initialize

; 177  : 
; 178  : 	CRichEditBaseCtrl::PreSubclassWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreSubclassWindow@CRichEditBaseCtrl@@MAEXXZ ; CRichEditBaseCtrl::PreSubclassWindow

; 179  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?PreSubclassWindow@CUrlRichEditCtrl@@MAEXXZ ENDP	; CUrlRichEditCtrl::PreSubclassWindow
_TEXT	ENDS
PUBLIC	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z	; CUrlRichEditCtrl::ParseAndFormatText
EXTRN	?ClearUndo@CRichEditHelper@@SAXPAUHWND__@@@Z:NEAR ; CRichEditHelper::ClearUndo
EXTRN	?GetWindowTextW@CWnd@@QBEXAAVCString@@@Z:NEAR	; CWnd::GetWindowTextW
EXTRN	?Default@CWnd@@IAEJXZ:NEAR			; CWnd::Default
EXTRN	??9@YG_NABVCString@@PBG@Z:NEAR			; operator!=
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79856	DD	019930520H
	DD	01H
	DD	FLAT:$T79858
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79858	DD	0ffffffffH
	DD	FLAT:$L79854
xdata$x	ENDS
;	COMDAT ?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT
_lp$ = 12
_this$ = -32
_sText$ = -16
_bChange$ = -24
_lr$ = -20
$T79853 = -28
__$EHRec$ = -12
?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z PROC NEAR		; CUrlRichEditCtrl::OnSetText, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79857
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	// eat duplicate messages
; 184  : 	CString sText;

	lea	ecx, DWORD PTR _sText$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 185  : 	GetWindowText(sText);

	lea	eax, DWORD PTR _sText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWindowTextW@CWnd@@QBEXAAVCString@@@Z ; CWnd::GetWindowTextW

; 186  : 	
; 187  : 	BOOL bChange = (sText != (LPCTSTR)lp);

	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sText$[ebp]
	push	edx
	call	??9@YG_NABVCString@@PBG@Z		; operator!=
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _bChange$[ebp], eax

; 188  : 	LRESULT lr = 0;

	mov	DWORD PTR _lr$[ebp], 0

; 189  : 	
; 190  : 	if (bChange)

	cmp	DWORD PTR _bChange$[ebp], 0
	je	SHORT $L77396

; 192  : 		CRichEditHelper::ClearUndo(GetSafeHwnd());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ	; CWnd::GetSafeHwnd
	push	eax
	call	?ClearUndo@CRichEditHelper@@SAXPAUHWND__@@@Z ; CRichEditHelper::ClearUndo
	add	esp, 4

; 193  : 		
; 194  : 		lr = Default();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Default@CWnd@@IAEJXZ			; CWnd::Default
	mov	DWORD PTR _lr$[ebp], eax

; 195  : 		ParseAndFormatText(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ; CUrlRichEditCtrl::ParseAndFormatText
$L77396:

; 197  : 	
; 198  : 	return lr;

	mov	eax, DWORD PTR _lr$[ebp]
	mov	DWORD PTR $T79853[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T79853[ebp]

; 199  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79854:
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79857:
	mov	eax, OFFSET FLAT:$T79856
	jmp	___CxxFrameHandler
text$x	ENDS
?OnSetText@CUrlRichEditCtrl@@IAEJIJ@Z ENDP		; CUrlRichEditCtrl::OnSetText
;	COMDAT ?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z
_TEXT	SEGMENT
_this$ = -8
_lr$ = -4
?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z PROC NEAR		; CUrlRichEditCtrl::OnSetFont, COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	LRESULT lr = Default();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Default@CWnd@@IAEJXZ			; CWnd::Default
	mov	DWORD PTR _lr$[ebp], eax

; 204  : 	ParseAndFormatText(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ; CUrlRichEditCtrl::ParseAndFormatText

; 205  : 	
; 206  : 	return lr;

	mov	eax, DWORD PTR _lr$[ebp]

; 207  : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?OnSetFont@CUrlRichEditCtrl@@IAEJIJ@Z ENDP		; CUrlRichEditCtrl::OnSetFont
_TEXT	ENDS
PUBLIC	?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z		; CUrlRichEditCtrl::IsDelim
;	COMDAT ?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z
_TEXT	SEGMENT
_szText$ = 8
_nDelims$ = -12
_ch$ = -4
_nDelim$ = -8
_szDelim$77416 = -16
?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z PROC NEAR		; CUrlRichEditCtrl::IsDelim, COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 211  : 	if (!szText || !*szText)

	cmp	DWORD PTR _szText$[ebp], 0
	je	SHORT $L77408
	mov	eax, DWORD PTR _szText$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $L77407
$L77408:

; 212  : 		return TRUE; // end of string

	mov	eax, 1
	jmp	SHORT $L77406
$L77407:

; 213  : 	
; 214  : 	int nDelims = sizeof(URLDELIMS) / sizeof(LPCTSTR);

	mov	DWORD PTR _nDelims$[ebp], 6

; 215  : 	TCHAR ch = *szText;

	mov	edx, DWORD PTR _szText$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _ch$[ebp], ax

; 216  : 				
; 217  : 	for (int nDelim = 0; nDelim < nDelims; nDelim++)

	mov	DWORD PTR _nDelim$[ebp], 0
	jmp	SHORT $L77413
$L77414:
	mov	ecx, DWORD PTR _nDelim$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nDelim$[ebp], ecx
$L77413:
	mov	edx, DWORD PTR _nDelim$[ebp]
	cmp	edx, DWORD PTR _nDelims$[ebp]
	jge	SHORT $L77415

; 219  : 		LPCTSTR szDelim = URLDELIMS[nDelim];

	mov	eax, DWORD PTR _nDelim$[ebp]
	mov	ecx, DWORD PTR _URLDELIMS[eax*4]
	mov	DWORD PTR _szDelim$77416[ebp], ecx

; 220  : 		
; 221  : 		if (ch == szDelim[0])

	mov	edx, DWORD PTR _ch$[ebp]
	and	edx, 65535				; 0000ffffH
	mov	eax, DWORD PTR _szDelim$77416[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	cmp	edx, ecx
	jne	SHORT $L77418

; 223  : 			// test char after ch if 2 char delim
; 224  : 			if (szDelim[1] == 0 || *(szText + 1) == szDelim[1])

	mov	edx, DWORD PTR _szDelim$77416[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+2]
	test	eax, eax
	je	SHORT $L77419
	mov	ecx, DWORD PTR _szText$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+2]
	mov	eax, DWORD PTR _szDelim$77416[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+2]
	cmp	edx, ecx
	jne	SHORT $L77418
$L77419:

; 225  : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L77406
$L77418:

; 227  : 	}

	jmp	SHORT $L77414
$L77415:

; 228  : 	
; 229  : 	return FALSE;

	xor	eax, eax
$L77406:

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z ENDP		; CUrlRichEditCtrl::IsDelim
_TEXT	ENDS
PUBLIC	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ	; CArray<URLITEM,URLITEM &>::GetSize
PUBLIC	?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z	; CArray<URLITEM,URLITEM &>::Copy
PUBLIC	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z	; CArray<URLITEM,URLITEM &>::operator[]
PUBLIC	??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::operator[]
PUBLIC	?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z ; CUrlRichEditCtrl::UrlsMatch
PUBLIC	?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z ; CUrlRichEditCtrl::InsertInOrder
PUBLIC	??0URLITEM@@QAE@XZ				; URLITEM::URLITEM
PUBLIC	??1URLITEM@@QAE@XZ				; URLITEM::~URLITEM
EXTRN	??0CRePauseUndo@@QAE@PAUHWND__@@@Z:NEAR		; CRePauseUndo::CRePauseUndo
EXTRN	??1CRePauseUndo@@UAE@XZ:NEAR			; CRePauseUndo::~CRePauseUndo
EXTRN	?IsClass@CWinClasses@@SAHPAUHWND__@@PBG@Z:NEAR	; CWinClasses::IsClass
EXTRN	?SetRedraw@CWnd@@QAEXH@Z:NEAR			; CWnd::SetRedraw
EXTRN	?Invalidate@CWnd@@QAEXH@Z:NEAR			; CWnd::Invalidate
EXTRN	?GetFirstVisibleLine@CRichEditCtrl@@QBEHXZ:NEAR	; CRichEditCtrl::GetFirstVisibleLine
EXTRN	?IsWindowVisible@CWnd@@QBEHXZ:NEAR		; CWnd::IsWindowVisible
EXTRN	?SetSelectionCharFormat@CRichEditBaseCtrl@@QAEHAAU_charformat@@@Z:NEAR ; CRichEditBaseCtrl::SetSelectionCharFormat
EXTRN	?SetFirstVisibleLine@CRichEditBaseCtrl@@QAEXH@Z:NEAR ; CRichEditBaseCtrl::SetFirstVisibleLine
EXTRN	??0CString@@QAE@PBGH@Z:NEAR			; CString::CString
EXTRN	?IsEmpty@CString@@QBEHXZ:NEAR			; CString::IsEmpty
EXTRN	??4CString@@QAEABV0@ABV0@@Z:NEAR		; CString::operator=
EXTRN	?Replace@CString@@QAEHPBG0@Z:NEAR		; CString::Replace
EXTRN	?Find@CString@@QBEHG@Z:NEAR			; CString::Find
EXTRN	??0CAutoFlag@@QAE@AAHH@Z:NEAR			; CAutoFlag::CAutoFlag
EXTRN	??1CAutoFlag@@UAE@XZ:NEAR			; CAutoFlag::~CAutoFlag
;	COMDAT data
; File D:\_CODE\Shared\urlricheditctrl.cpp
data	SEGMENT
$SG77430 DB	'R', 00H, 'i', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'd', 00H
	DB	'i', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG77431 DB	0aH, 00H, 00H, 00H
$SG77432 DB	0dH, 00H, 0aH, 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T79878	DD	019930520H
	DD	06H
	DD	FLAT:$T79880
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79880	DD	0ffffffffH
	DD	FLAT:$L79871
	DD	00H
	DD	FLAT:$L79872
	DD	01H
	DD	FLAT:$L79873
	DD	02H
	DD	FLAT:$L79874
	DD	03H
	DD	FLAT:$L79875
	DD	02H
	DD	FLAT:$L79876
xdata$x	ENDS
;	COMDAT ?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_bForceReformat$ = 8
_this$ = -216
_af$ = -24
_sText$ = -52
_aUrls$ = -48
_szText$ = -28
_bPrevDelim$ = -64
_nPos$ = -68
_bBracedFile$ = -60
_nProt$77444 = -72
_nLen$77448 = -92
_szStart$77449 = -96
_urli$77458 = -88
_bReformat$ = -56
_bVisible$77465 = -208
_rep$77466 = -120
_crSel$77468 = -204
_nFirstLine$77469 = -104
_dwEventMask$77470 = -100
_cf$77471 = -192
_nUrls$77472 = -196
_cr$77473 = -128
_nUrl$77474 = -132
$T79867 = -212
?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z PROC NEAR	; CUrlRichEditCtrl::ParseAndFormatText, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79879
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 216				; 000000d8H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 	KillTimer(TIMER_REPARSE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KillTimer@CWnd@@QAEHH@Z		; CWnd::KillTimer

; 235  : 	AF_NOREENTRANT // prevent reentrancy

	cmp	DWORD PTR _?bAFInHere@?1??ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z@4HA, 0
	je	SHORT $L77426
	jmp	$L77423
$L77426:
	push	1
	push	OFFSET FLAT:_?bAFInHere@?1??ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z@4HA
	lea	ecx, DWORD PTR _af$[ebp]
	call	??0CAutoFlag@@QAE@AAHH@Z		; CAutoFlag::CAutoFlag
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 236  : 		
; 237  : 	// parse the control content
; 238  : 	CString sText;

	lea	ecx, DWORD PTR _sText$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 239  : 	GetWindowText(sText);

	lea	eax, DWORD PTR _sText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWindowTextW@CWnd@@QBEXAAVCString@@@Z ; CWnd::GetWindowTextW

; 240  : 	
; 241  : 	// richedit2 uses '\r\n' whereas richedit uses just '\n'
; 242  : 	if (!CWinClasses::IsClass(*this, WC_RICHEDIT))

	push	OFFSET FLAT:$SG77430
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	call	?IsClass@CWinClasses@@SAHPAUHWND__@@PBG@Z ; CWinClasses::IsClass
	add	esp, 8
	test	eax, eax
	jne	SHORT $L77429

; 243  : 		sText.Replace(_T("\r\n"), _T("\n"));

	push	OFFSET FLAT:$SG77431
	push	OFFSET FLAT:$SG77432
	lea	ecx, DWORD PTR _sText$[ebp]
	call	?Replace@CString@@QAEHPBG0@Z		; CString::Replace
$L77429:

; 244  : 	
; 245  : 	// parse the text into an array of URLPOS
; 246  : 	CUrlArray aUrls;

	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ	; CArray<URLITEM,URLITEM &>::CArray<URLITEM,URLITEM &>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 247  : 	LPCTSTR szText = sText;

	lea	ecx, DWORD PTR _sText$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	DWORD PTR _szText$[ebp], eax

; 248  : 	BOOL bPrevDelim = TRUE;

	mov	DWORD PTR _bPrevDelim$[ebp], 1

; 249  : 	int nPos = 0;

	mov	DWORD PTR _nPos$[ebp], 0

; 250  : 	BOOL bBracedFile = FALSE;

	mov	DWORD PTR _bBracedFile$[ebp], 0
$L77439:

; 251  : 	
; 252  : 	while (*szText) 

	mov	ecx, DWORD PTR _szText$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	test	edx, edx
	je	$L77440

; 254  : 		// if nChar < 0 then its a multibyte char and can't be part
; 255  : 		// of a url, so we bump the text buffer by 2 but the pos by 1
; 256  : #ifndef _UNICODE
; 257  : 		TCHAR nChar = *szText;
; 258  : 		
; 259  : 		if (IsDBCSLeadByte(nChar))
; 260  : 		{
; 261  : 			szText++; 
; 262  : 			szText++;
; 263  : 			nPos++;
; 264  : 			continue;
; 265  : 		}
; 266  : #endif
; 267  : 		// if the previous item was not a delimiter then there's no
; 268  : 		// point checking for a protocol match so we just update the
; 269  : 		// value of bPrevDelim for the current char
; 270  : 		if (!bPrevDelim)

	cmp	DWORD PTR _bPrevDelim$[ebp], 0
	jne	SHORT $L77441

; 272  : 			bPrevDelim = IsDelim(szText);

	mov	eax, DWORD PTR _szText$[ebp]
	push	eax
	call	?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z	; CUrlRichEditCtrl::IsDelim
	add	esp, 4
	mov	DWORD PTR _bPrevDelim$[ebp], eax

; 273  : 			szText++;

	mov	ecx, DWORD PTR _szText$[ebp]
	add	ecx, 2
	mov	DWORD PTR _szText$[ebp], ecx

; 274  : 			nPos++;

	mov	edx, DWORD PTR _nPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _nPos$[ebp], edx

; 275  : 			continue;

	jmp	SHORT $L77439
$L77441:

; 277  : 		// if the current char is a delim then this can't be the start
; 278  : 		// of a url either
; 279  : 		else if (IsDelim(szText))

	mov	eax, DWORD PTR _szText$[ebp]
	push	eax
	call	?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z	; CUrlRichEditCtrl::IsDelim
	add	esp, 4
	test	eax, eax
	je	SHORT $L77443

; 281  : 			bPrevDelim = TRUE;

	mov	DWORD PTR _bPrevDelim$[ebp], 1

; 282  : 			szText++;

	mov	ecx, DWORD PTR _szText$[ebp]
	add	ecx, 2
	mov	DWORD PTR _szText$[ebp], ecx

; 283  : 			nPos++;

	mov	edx, DWORD PTR _nPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _nPos$[ebp], edx

; 284  : 			continue;

	jmp	SHORT $L77439
$L77443:

; 286  : 		
; 287  : 		// now check for a protocol
; 288  : 		int nProt = MatchProtocol(szText);

	mov	eax, DWORD PTR _szText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MatchProtocol@CUrlRichEditCtrl@@IBEHPBG@Z ; CUrlRichEditCtrl::MatchProtocol
	mov	DWORD PTR _nProt$77444[ebp], eax

; 289  : 		
; 290  : 		// if no match then increment pos and go to next char
; 291  : 		if (nProt == -1)

	cmp	DWORD PTR _nProt$77444[ebp], -1
	jne	SHORT $L77445

; 293  : 			bPrevDelim = FALSE;

	mov	DWORD PTR _bPrevDelim$[ebp], 0

; 294  : 			szText++;

	mov	ecx, DWORD PTR _szText$[ebp]
	add	ecx, 2
	mov	DWORD PTR _szText$[ebp], ecx

; 295  : 			nPos++;

	mov	edx, DWORD PTR _nPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _nPos$[ebp], edx

; 296  : 			continue;

	jmp	$L77439
$L77445:

; 298  : 		
; 299  : 		// check for braces (<...>)
; 300  : 		if (nPos > 0)

	cmp	DWORD PTR _nPos$[ebp], 0
	jle	SHORT $L77446

; 301  : 			bBracedFile = (szText[-1] == '<');

	mov	eax, DWORD PTR _szText$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax-2]
	xor	edx, edx
	cmp	ecx, 60					; 0000003cH
	sete	dl
	mov	DWORD PTR _bBracedFile$[ebp], edx

; 302  : 		else

	jmp	SHORT $L77447
$L77446:

; 303  : 			bBracedFile = FALSE;

	mov	DWORD PTR _bBracedFile$[ebp], 0
$L77447:

; 304  : 		
; 305  : 		// find the end of the url (URLDELIMS)
; 306  : 		int nLen = 0;

	mov	DWORD PTR _nLen$77448[ebp], 0

; 307  : 		LPCTSTR szStart = szText;

	mov	eax, DWORD PTR _szText$[ebp]
	mov	DWORD PTR _szStart$77449[ebp], eax

; 308  : 		
; 309  : 		if (bBracedFile)

	cmp	DWORD PTR _bBracedFile$[ebp], 0
	je	SHORT $L77450
$L77452:

; 311  : 			while (*szText && *szText != '>')

	mov	ecx, DWORD PTR _szText$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $L77453
	mov	eax, DWORD PTR _szText$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax]
	cmp	ecx, 62					; 0000003eH
	je	SHORT $L77453

; 313  : 				szText++;

	mov	edx, DWORD PTR _szText$[ebp]
	add	edx, 2
	mov	DWORD PTR _szText$[ebp], edx

; 314  : 				nLen++;

	mov	eax, DWORD PTR _nLen$77448[ebp]
	add	eax, 1
	mov	DWORD PTR _nLen$77448[ebp], eax

; 315  : 			}

	jmp	SHORT $L77452
$L77453:

; 317  : 		else

	jmp	SHORT $L77457
$L77450:

; 319  : 			while (!IsDelim(szText))

	mov	ecx, DWORD PTR _szText$[ebp]
	push	ecx
	call	?IsDelim@CUrlRichEditCtrl@@KAHPBG@Z	; CUrlRichEditCtrl::IsDelim
	add	esp, 4
	test	eax, eax
	jne	SHORT $L77457

; 321  : 				szText++;

	mov	edx, DWORD PTR _szText$[ebp]
	add	edx, 2
	mov	DWORD PTR _szText$[ebp], edx

; 322  : 				nLen++;

	mov	eax, DWORD PTR _nLen$77448[ebp]
	add	eax, 1
	mov	DWORD PTR _nLen$77448[ebp], eax

; 323  : 			}

	jmp	SHORT $L77450
$L77457:

; 325  : 		
; 326  : 		bPrevDelim = TRUE;

	mov	DWORD PTR _bPrevDelim$[ebp], 1

; 327  : 		
; 328  : 		// save the result
; 329  : 		URLITEM urli;

	lea	ecx, DWORD PTR _urli$77458[ebp]
	call	??0URLITEM@@QAE@XZ			; URLITEM::URLITEM
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 330  : 		urli.cr.cpMin = nPos;

	mov	ecx, DWORD PTR _nPos$[ebp]
	mov	DWORD PTR _urli$77458[ebp], ecx

; 331  : 		urli.cr.cpMax = urli.cr.cpMin + nLen;

	mov	edx, DWORD PTR _urli$77458[ebp]
	add	edx, DWORD PTR _nLen$77448[ebp]
	mov	DWORD PTR _urli$77458[ebp+4], edx

; 332  : 		nPos += nLen;

	mov	eax, DWORD PTR _nPos$[ebp]
	add	eax, DWORD PTR _nLen$77448[ebp]
	mov	DWORD PTR _nPos$[ebp], eax
$L77460:

; 333  : 		
; 334  : 		// make sure the url does not end in a punctuation mark
; 335  : 		while (ENDPUNCTUATION.Find(szStart[nLen - 1]) != -1)

	mov	ecx, DWORD PTR _nLen$77448[ebp]
	mov	edx, DWORD PTR _szStart$77449[ebp]
	mov	ax, WORD PTR [edx+ecx*2-2]
	push	eax
	mov	ecx, OFFSET FLAT:_ENDPUNCTUATION
	call	?Find@CString@@QBEHG@Z			; CString::Find
	cmp	eax, -1
	je	SHORT $L77461

; 337  : 			nLen--;

	mov	ecx, DWORD PTR _nLen$77448[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nLen$77448[ebp], ecx

; 338  : 			urli.cr.cpMax--;

	mov	edx, DWORD PTR _urli$77458[ebp+4]
	sub	edx, 1
	mov	DWORD PTR _urli$77458[ebp+4], edx

; 339  : 		}

	jmp	SHORT $L77460
$L77461:

; 340  : 		
; 341  : 		urli.sUrl = CString(szStart, nLen);

	mov	eax, DWORD PTR _nLen$77448[ebp]
	push	eax
	mov	ecx, DWORD PTR _szStart$77449[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T79867[ebp]
	call	??0CString@@QAE@PBGH@Z			; CString::CString
	mov	DWORD PTR -220+[ebp], eax
	mov	edx, DWORD PTR -220+[ebp]
	mov	DWORD PTR -224+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR -224+[ebp]
	push	eax
	lea	ecx, DWORD PTR _urli$77458[ebp+8]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T79867[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 342  : 		urli.bWantNotify = m_aProtocols[nProt].bWantNotify;

	mov	ecx, DWORD PTR _nProt$77444[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 160				; 000000a0H
	call	??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::operator[]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _urli$77458[ebp+12], edx

; 343  : 		
; 344  : 		InsertInOrder(urli, aUrls);

	lea	eax, DWORD PTR _aUrls$[ebp]
	push	eax
	lea	ecx, DWORD PTR _urli$77458[ebp]
	push	ecx
	call	?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z ; CUrlRichEditCtrl::InsertInOrder
	add	esp, 8

; 345  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _urli$77458[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	jmp	$L77439
$L77440:

; 346  : 	
; 347  : 	// compare aUrls with m_aUrls to see if anything has changed
; 348  : 	BOOL bReformat = !sText.IsEmpty() && (bForceReformat || !UrlsMatch(aUrls));

	lea	ecx, DWORD PTR _sText$[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	SHORT $L79869
	cmp	DWORD PTR _bForceReformat$[ebp], 0
	jne	SHORT $L79868
	lea	edx, DWORD PTR _aUrls$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z ; CUrlRichEditCtrl::UrlsMatch
	test	eax, eax
	jne	SHORT $L79869
$L79868:
	mov	DWORD PTR -228+[ebp], 1
	jmp	SHORT $L79870
$L79869:
	mov	DWORD PTR -228+[ebp], 0
$L79870:
	mov	eax, DWORD PTR -228+[ebp]
	mov	DWORD PTR _bReformat$[ebp], eax

; 349  : 	
; 350  : 	// then overwrite (always)	
; 351  : 	m_aUrls.Copy(aUrls);

	lea	ecx, DWORD PTR _aUrls$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z ; CArray<URLITEM,URLITEM &>::Copy

; 352  : 	
; 353  : 	if (bReformat)

	cmp	DWORD PTR _bReformat$[ebp], 0
	je	$L77464

; 355  : 		BOOL bVisible = IsWindowVisible();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWindowVisible@CWnd@@QBEHXZ		; CWnd::IsWindowVisible
	mov	DWORD PTR _bVisible$77465[ebp], eax

; 356  : 		CRePauseUndo rep(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	lea	ecx, DWORD PTR _rep$77466[ebp]
	call	??0CRePauseUndo@@QAE@PAUHWND__@@@Z	; CRePauseUndo::CRePauseUndo
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 357  : 		
; 358  : 		if (bVisible)

	cmp	DWORD PTR _bVisible$77465[ebp], 0
	je	SHORT $L77467

; 359  : 			SetRedraw(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRedraw@CWnd@@QAEXH@Z		; CWnd::SetRedraw
$L77467:

; 363  : 		GetSel(crSel);

	lea	edx, DWORD PTR _crSel$77468[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 364  : 		
; 365  : 		// and first line
; 366  : 		int nFirstLine = GetFirstVisibleLine();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstVisibleLine@CRichEditCtrl@@QBEHXZ ; CRichEditCtrl::GetFirstVisibleLine
	mov	DWORD PTR _nFirstLine$77469[ebp], eax

; 367  : 		
; 368  : 		// save/reset event mask
; 369  : 		DWORD dwEventMask = SetEventMask(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEventMask@CRichEditCtrl@@QAEKK@Z	; CRichEditCtrl::SetEventMask
	mov	DWORD PTR _dwEventMask$77470[ebp], eax

; 370  : 		
; 371  : 		// retrieve default character attribs
; 372  : 		CHARFORMAT cf;
; 373  : 		cf.cbSize = sizeof(cf);

	mov	DWORD PTR _cf$77471[ebp], 60		; 0000003cH

; 374  : 		cf.dwMask = CFM_LINK;

	mov	DWORD PTR _cf$77471[ebp+4], 32		; 00000020H

; 375  : 		
; 376  : 		// format urls
; 377  : 		int nUrls = aUrls.GetSize();

	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrls$77472[ebp], eax

; 378  : 		CHARRANGE cr = { 0, 0 };

	mov	DWORD PTR _cr$77473[ebp], 0
	mov	DWORD PTR _cr$77473[ebp+4], 0

; 379  : 		
; 380  : 		for (int nUrl = 0; nUrl < nUrls; nUrl++)

	mov	DWORD PTR _nUrl$77474[ebp], 0
	jmp	SHORT $L77475
$L77476:
	mov	eax, DWORD PTR _nUrl$77474[ebp]
	add	eax, 1
	mov	DWORD PTR _nUrl$77474[ebp], eax
$L77475:
	mov	ecx, DWORD PTR _nUrl$77474[ebp]
	cmp	ecx, DWORD PTR _nUrls$77472[ebp]
	jge	$L77477

; 382  : 			// clear formatting from the end of the previous
; 383  : 			// url to the start of this url
; 384  : 			cr.cpMax = aUrls[nUrl].cr.cpMin;

	mov	edx, DWORD PTR _nUrl$77474[ebp]
	push	edx
	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _cr$77473[ebp+4], eax

; 385  : 			cf.dwEffects = 0;

	mov	DWORD PTR _cf$77471[ebp+8], 0

; 386  : 			
; 387  : 			SetSel(cr);

	lea	ecx, DWORD PTR _cr$77473[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 388  : 			SetSelectionCharFormat(cf);

	lea	edx, DWORD PTR _cf$77471[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSelectionCharFormat@CRichEditBaseCtrl@@QAEHAAU_charformat@@@Z ; CRichEditBaseCtrl::SetSelectionCharFormat

; 389  : 			
; 390  : 			// update for next url
; 391  : 			cr.cpMin = aUrls[nUrl].cr.cpMax;

	mov	eax, DWORD PTR _nUrl$77474[ebp]
	push	eax
	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _cr$77473[ebp], ecx

; 392  : 			
; 393  : 			// then format url
; 394  : 			cf.dwEffects = CFM_LINK;

	mov	DWORD PTR _cf$77471[ebp+8], 32		; 00000020H

; 395  : 			
; 396  : 			SetSel(aUrls[nUrl].cr);

	mov	edx, DWORD PTR _nUrl$77474[ebp]
	push	edx
	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 397  : 			SetSelectionCharFormat(cf);

	lea	eax, DWORD PTR _cf$77471[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSelectionCharFormat@CRichEditBaseCtrl@@QAEHAAU_charformat@@@Z ; CRichEditBaseCtrl::SetSelectionCharFormat

; 398  : 		}	

	jmp	$L77476
$L77477:

; 399  : 		
; 400  : 		// clear formatting for whatever's left
; 401  : 		cr.cpMax = -1;

	mov	DWORD PTR _cr$77473[ebp+4], -1

; 402  : 		cf.dwEffects = 0;

	mov	DWORD PTR _cf$77471[ebp+8], 0

; 403  : 		
; 404  : 		SetSel(cr);

	lea	ecx, DWORD PTR _cr$77473[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 405  : 		SetSelectionCharFormat(cf);

	lea	edx, DWORD PTR _cf$77471[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSelectionCharFormat@CRichEditBaseCtrl@@QAEHAAU_charformat@@@Z ; CRichEditBaseCtrl::SetSelectionCharFormat

; 406  : 		
; 407  : 		// restore selection
; 408  : 		SetSel(crSel);

	lea	eax, DWORD PTR _crSel$77468[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 409  : 		
; 410  : 		// and first line
; 411  : 		SetFirstVisibleLine(nFirstLine);

	mov	ecx, DWORD PTR _nFirstLine$77469[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFirstVisibleLine@CRichEditBaseCtrl@@QAEXH@Z ; CRichEditBaseCtrl::SetFirstVisibleLine

; 412  : 		
; 413  : 		// restore event mask
; 414  : 		SetEventMask(dwEventMask);

	mov	edx, DWORD PTR _dwEventMask$77470[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEventMask@CRichEditCtrl@@QAEKK@Z	; CRichEditCtrl::SetEventMask

; 415  : 
; 416  : 		if (bVisible)

	cmp	DWORD PTR _bVisible$77465[ebp], 0
	je	SHORT $L77478

; 418  : 			SetRedraw(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRedraw@CWnd@@QAEXH@Z		; CWnd::SetRedraw

; 419  : 			Invalidate(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Invalidate@CWnd@@QAEXH@Z		; CWnd::Invalidate
$L77478:

; 421  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _rep$77466[ebp]
	call	??1CRePauseUndo@@UAE@XZ			; CRePauseUndo::~CRePauseUndo
$L77464:

; 422  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _af$[ebp]
	call	??1CAutoFlag@@UAE@XZ			; CAutoFlag::~CAutoFlag
$L77423:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79871:
	lea	ecx, DWORD PTR _af$[ebp]
	call	??1CAutoFlag@@UAE@XZ			; CAutoFlag::~CAutoFlag
	ret	0
$L79872:
	lea	ecx, DWORD PTR _sText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79873:
	lea	ecx, DWORD PTR _aUrls$[ebp]
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	ret	0
$L79874:
	lea	ecx, DWORD PTR _urli$77458[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L79875:
	lea	ecx, DWORD PTR $T79867[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79876:
	lea	ecx, DWORD PTR _rep$77466[ebp]
	call	??1CRePauseUndo@@UAE@XZ			; CRePauseUndo::~CRePauseUndo
	ret	0
$L79879:
	mov	eax, OFFSET FLAT:$T79878
	jmp	___CxxFrameHandler
text$x	ENDS
?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ENDP	; CUrlRichEditCtrl::ParseAndFormatText
;	COMDAT ??0URLITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0URLITEM@@QAE@XZ PROC NEAR				; URLITEM::URLITEM, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0CString@@QAE@XZ			; CString::CString
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??0URLITEM@@QAE@XZ ENDP					; URLITEM::URLITEM
_TEXT	ENDS
;	COMDAT ??1URLITEM@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1URLITEM@@QAE@XZ PROC NEAR				; URLITEM::~URLITEM, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1CString@@QAE@XZ			; CString::~CString
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??1URLITEM@@QAE@XZ ENDP					; URLITEM::~URLITEM
_TEXT	ENDS
PUBLIC	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z	; CArray<URLITEM,URLITEM &>::operator[]
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79901	DD	019930520H
	DD	02H
	DD	FLAT:$T79903
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79903	DD	0ffffffffH
	DD	FLAT:$L79898
	DD	00H
	DD	FLAT:$L79899
xdata$x	ENDS
;	COMDAT ?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z
_TEXT	SEGMENT
$T79892 = -24
$T79893 = -40
$T79894 = -44
$T79895 = -60
__$EHRec$ = -12
_aUrls$ = 8
_this$ = -64
_nUrls$ = -20
_nUrl$ = -16
?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z PROC NEAR ; CUrlRichEditCtrl::UrlsMatch, COMDAT

; 425  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79902
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 426  : 	int nUrls = aUrls.GetSize();

	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrls$[ebp], eax

; 427  : 
; 428  : 	if (nUrls !=  m_aUrls.GetSize())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	cmp	DWORD PTR _nUrls$[ebp], eax
	je	SHORT $L77488

; 429  : 		return FALSE;

	xor	eax, eax
	jmp	$L77486
$L77488:

; 430  : 
; 431  : 	// compare aUrls with m_aUrls to see if anything has changed
; 432  : 	for (int nUrl = 0; nUrl < nUrls; nUrl++)

	mov	DWORD PTR _nUrl$[ebp], 0
	jmp	SHORT $L77490
$L77491:
	mov	eax, DWORD PTR _nUrl$[ebp]
	add	eax, 1
	mov	DWORD PTR _nUrl$[ebp], eax
$L77490:
	mov	ecx, DWORD PTR _nUrl$[ebp]
	cmp	ecx, DWORD PTR _nUrls$[ebp]
	jge	$L77492

; 435  : 			aUrls[nUrl].cr.cpMax != m_aUrls[nUrl].cr.cpMax)

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	lea	eax, DWORD PTR $T79893[ebp]
	push	eax
	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR -68+[ebp], eax
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR -72+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	ecx, DWORD PTR -72+[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $L79896
	mov	eax, DWORD PTR _nUrl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79895[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR -76+[ebp], eax
	mov	edx, DWORD PTR -76+[ebp]
	mov	DWORD PTR -80+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _nUrl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	ecx, DWORD PTR -80+[ebp]
	mov	edx, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	edx, DWORD PTR [eax+4]
	setne	cl
	mov	BYTE PTR $T79894[ebp], cl
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79895[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	edx, DWORD PTR $T79894[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L79896
	mov	DWORD PTR -84+[ebp], 0
	jmp	SHORT $L79897
$L79896:
	mov	DWORD PTR -84+[ebp], 1
$L79897:
	mov	al, BYTE PTR -84+[ebp]
	mov	BYTE PTR $T79892[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79893[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	ecx, DWORD PTR $T79892[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L77496

; 437  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L77486
$L77496:

; 439  : 	}

	jmp	$L77491
$L77492:

; 440  : 
; 441  : 	// no change
; 442  : 	return TRUE;

	mov	eax, 1
$L77486:

; 443  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79898:
	lea	ecx, DWORD PTR $T79893[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L79899:
	lea	ecx, DWORD PTR $T79895[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L79902:
	mov	eax, OFFSET FLAT:$T79901
	jmp	___CxxFrameHandler
text$x	ENDS
?UrlsMatch@CUrlRichEditCtrl@@IAEHABV?$CArray@UURLITEM@@AAU1@@@@Z ENDP ; CUrlRichEditCtrl::UrlsMatch
PUBLIC	?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::InsertAt
;	COMDAT ?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z
_TEXT	SEGMENT
_urli$ = 8
_aUrls$ = 12
_nUrl$ = -4
?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z PROC NEAR ; CUrlRichEditCtrl::InsertInOrder, COMDAT

; 446  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 447  : 	// work backwards looking for first item that comes before us
; 448  : 	int nUrl = aUrls.GetSize();

	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrl$[ebp], eax
$L77504:

; 449  : 
; 450  : 	while (nUrl--)

	mov	eax, DWORD PTR _nUrl$[ebp]
	mov	ecx, DWORD PTR _nUrl$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nUrl$[ebp], ecx
	test	eax, eax
	je	SHORT $L77505

; 452  : 		if (aUrls[nUrl].cr.cpMin < urli.cr.cpMin)

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	ecx, DWORD PTR _urli$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $L77506

; 454  : 			aUrls.InsertAt(nUrl + 1, urli);

	push	1
	mov	eax, DWORD PTR _urli$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nUrl$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::InsertAt

; 455  : 			return;

	jmp	SHORT $L77501
$L77506:

; 457  : 	}

	jmp	SHORT $L77504
$L77505:

; 458  : 
; 459  : 	// else insert at start
; 460  : 	aUrls.InsertAt(0, urli);

	push	1
	mov	edx, DWORD PTR _urli$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _aUrls$[ebp]
	call	?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::InsertAt
$L77501:

; 461  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?InsertInOrder@CUrlRichEditCtrl@@KAXAAUURLITEM@@AAV?$CArray@UURLITEM@@AAU1@@@@Z ENDP ; CUrlRichEditCtrl::InsertInOrder
_TEXT	ENDS
PUBLIC	?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z	; CUrlRichEditCtrl::GetUrl
PUBLIC	?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z		; CUrlRichEditCtrl::GoToUrl
EXTRN	?Run@FileMisc@@YAKPAUHWND__@@PBG1H11@Z:NEAR	; FileMisc::Run
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79916	DD	019930520H
	DD	02H
	DD	FLAT:$T79918
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79918	DD	0ffffffffH
	DD	FLAT:$L79913
	DD	00H
	DD	FLAT:$L79914
xdata$x	ENDS
;	COMDAT ?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z
_TEXT	SEGMENT
$T79910 = -40
$T79911 = -44
$T79912 = -48
__$EHRec$ = -12
_nUrl$ = 8
_this$ = -52
_urli$ = -16
_$S297$ = -32
_sUrl$77517 = -36
?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z PROC NEAR		; CUrlRichEditCtrl::GoToUrl, COMDAT

; 464  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79917
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 	if (nUrl < 0 || nUrl >= m_aUrls.GetSize())

	cmp	DWORD PTR _nUrl$[ebp], 0
	jl	SHORT $L77512
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	cmp	DWORD PTR _nUrl$[ebp], eax
	jl	SHORT $L77511
$L77512:

; 466  : 		return FALSE;

	xor	eax, eax
	jmp	$L77510
$L77511:

; 467  : 	
; 468  : 	const URLITEM& urli = m_aUrls[nUrl];

	mov	eax, DWORD PTR _nUrl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S297$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR _$S297$[ebp]
	mov	DWORD PTR _urli$[ebp], edx

; 469  : 		
; 470  : 	if (!urli.bWantNotify)

	mov	eax, DWORD PTR _urli$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$L77516

; 472  : 		CString sUrl = GetUrl(nUrl, TRUE);

	push	1
	mov	ecx, DWORD PTR _nUrl$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sUrl$77517[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z ; CUrlRichEditCtrl::GetUrl
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 473  : 
; 474  : 		// if it fails to run then forward on to parent
; 475  : 		if (FileMisc::Run(*this, sUrl) > 32)

	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR _sUrl$77517[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	call	?Run@FileMisc@@YAKPAUHWND__@@PBG1H11@Z	; FileMisc::Run
	add	esp, 24					; 00000018H
	cmp	eax, 32					; 00000020H
	jbe	SHORT $L77519

; 476  : 			return TRUE;

	mov	DWORD PTR $T79910[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sUrl$77517[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S297$[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	eax, DWORD PTR $T79910[ebp]
	jmp	$L77510
$L77519:

; 477  : 
; 478  : 		// else
; 479  : 		SendNotifyFailedUrl(sUrl);

	lea	ecx, DWORD PTR _sUrl$77517[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+252]
	cmp	esi, esp
	call	__chkesp

; 480  : 		return FALSE;

	mov	DWORD PTR $T79911[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sUrl$77517[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S297$[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	eax, DWORD PTR $T79911[ebp]
	jmp	SHORT $L77510
$L77516:

; 482  : 
; 483  : 	// else
; 484  : 	SendNotifyCustomUrl(urli.sUrl);

	mov	ecx, DWORD PTR _urli$[ebp]
	add	ecx, 8
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+248]
	cmp	esi, esp
	call	__chkesp

; 485  : 	return TRUE;

	mov	DWORD PTR $T79912[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S297$[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	eax, DWORD PTR $T79912[ebp]
$L77510:

; 486  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79913:
	lea	ecx, DWORD PTR _$S297$[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L79914:
	lea	ecx, DWORD PTR _sUrl$77517[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79917:
	mov	eax, OFFSET FLAT:$T79916
	jmp	___CxxFrameHandler
text$x	ENDS
?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z ENDP			; CUrlRichEditCtrl::GoToUrl
PUBLIC	?GoToUrl@CUrlRichEditCtrl@@QBEHABVCString@@@Z	; CUrlRichEditCtrl::GoToUrl
EXTRN	?FileExists@FileMisc@@YAHPBG@Z:NEAR		; FileMisc::FileExists
EXTRN	?CompareNoCase@CString@@QBEHPBG@Z:NEAR		; CString::CompareNoCase
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79926	DD	019930520H
	DD	01H
	DD	FLAT:$T79928
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79928	DD	0ffffffffH
	DD	FLAT:$L79924
xdata$x	ENDS
;	COMDAT ?GoToUrl@CUrlRichEditCtrl@@QBEHABVCString@@@Z
_TEXT	SEGMENT
$T79923 = -40
__$EHRec$ = -12
_sUrl$ = 8
_this$ = -44
_nUrl$ = -16
_urli$77531 = -20
_$S298$77533 = -36
?GoToUrl@CUrlRichEditCtrl@@QBEHABVCString@@@Z PROC NEAR	; CUrlRichEditCtrl::GoToUrl, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79927
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 490  : 	int nUrl = m_aUrls.GetSize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrl$[ebp], eax
$L77529:

; 491  : 	
; 492  : 	while (nUrl--)

	mov	eax, DWORD PTR _nUrl$[ebp]
	mov	ecx, DWORD PTR _nUrl$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nUrl$[ebp], ecx
	test	eax, eax
	je	SHORT $L77530

; 494  : 		const URLITEM& urli = m_aUrls[nUrl];

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	lea	eax, DWORD PTR _$S298$77533[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _$S298$77533[ebp]
	mov	DWORD PTR _urli$77531[ebp], ecx

; 495  : 
; 496  : 		if (urli.sUrl.CompareNoCase(sUrl) == 0)

	mov	ecx, DWORD PTR _sUrl$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _urli$77531[ebp]
	add	ecx, 8
	call	?CompareNoCase@CString@@QBEHPBG@Z	; CString::CompareNoCase
	test	eax, eax
	jne	SHORT $L77534

; 497  : 			return GoToUrl(nUrl);

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z	; CUrlRichEditCtrl::GoToUrl
	mov	DWORD PTR $T79923[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S298$77533[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	eax, DWORD PTR $T79923[ebp]
	jmp	SHORT $L77526
$L77534:

; 498  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S298$77533[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	jmp	SHORT $L77529
$L77530:

; 499  : 
; 500  : 	// didn't match then it might be a file
; 501  : 	if (FileMisc::FileExists(sUrl))

	mov	ecx, DWORD PTR _sUrl$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?FileExists@FileMisc@@YAHPBG@Z		; FileMisc::FileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $L77537

; 503  : 		if (FileMisc::Run(*this, sUrl) > 32)

	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _sUrl$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	call	?Run@FileMisc@@YAKPAUHWND__@@PBG1H11@Z	; FileMisc::Run
	add	esp, 24					; 00000018H
	cmp	eax, 32					; 00000020H
	jbe	SHORT $L77537

; 504  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L77526
$L77537:

; 506  : 	
; 507  : 	// else
; 508  : 	SendNotifyFailedUrl(sUrl);

	mov	ecx, DWORD PTR _sUrl$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+252]
	cmp	esi, esp
	call	__chkesp

; 509  : 	return FALSE;

	xor	eax, eax
$L77526:

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79924:
	lea	ecx, DWORD PTR _$S298$77533[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L79927:
	mov	eax, OFFSET FLAT:$T79926
	jmp	___CxxFrameHandler
text$x	ENDS
?GoToUrl@CUrlRichEditCtrl@@QBEHABVCString@@@Z ENDP	; CUrlRichEditCtrl::GoToUrl
EXTRN	?GetDlgCtrlID@CWnd@@QBEHXZ:NEAR			; CWnd::GetDlgCtrlID
EXTRN	?GetParent@CWnd@@QBEPAV1@XZ:NEAR		; CWnd::GetParent
;	COMDAT ?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z
_TEXT	SEGMENT
_szUrl$ = 8
_this$ = -4
?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z PROC NEAR ; CUrlRichEditCtrl::SendNotifyCustomUrl, COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 514  : 	return GetParent()->SendMessage(WM_UREN_CUSTOMURL, GetDlgCtrlID(), (LPARAM)szUrl);

	mov	eax, DWORD PTR _szUrl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDlgCtrlID@CWnd@@QBEHXZ		; CWnd::GetDlgCtrlID
	push	eax
	mov	ecx, DWORD PTR _WM_UREN_CUSTOMURL
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParent@CWnd@@QBEPAV1@XZ		; CWnd::GetParent
	mov	ecx, eax
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 515  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?SendNotifyCustomUrl@CUrlRichEditCtrl@@MBEJPBG@Z ENDP	; CUrlRichEditCtrl::SendNotifyCustomUrl
_TEXT	ENDS
;	COMDAT ?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z
_TEXT	SEGMENT
_szUrl$ = 8
_this$ = -4
?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z PROC NEAR ; CUrlRichEditCtrl::SendNotifyFailedUrl, COMDAT

; 518  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 519  : 	return GetParent()->SendMessage(WM_UREN_FAILEDURL, GetDlgCtrlID(), (LPARAM)szUrl);

	mov	eax, DWORD PTR _szUrl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDlgCtrlID@CWnd@@QBEHXZ		; CWnd::GetDlgCtrlID
	push	eax
	mov	ecx, DWORD PTR _WM_UREN_FAILEDURL
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParent@CWnd@@QBEPAV1@XZ		; CWnd::GetParent
	mov	ecx, eax
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 520  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?SendNotifyFailedUrl@CUrlRichEditCtrl@@MBEJPBG@Z ENDP	; CUrlRichEditCtrl::SendNotifyFailedUrl
_TEXT	ENDS
PUBLIC	??_GSelection@OutlookAPI@@QAEPAXI@Z		; OutlookAPI::Selection::`scalar deleting destructor'
PUBLIC	??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z	; OutlookAPI::_MailItem::_MailItem
PUBLIC	??1_MailItem@OutlookAPI@@QAE@XZ			; OutlookAPI::_MailItem::~_MailItem
EXTRN	??0COutlookHelper@@QAE@XZ:NEAR			; COutlookHelper::COutlookHelper
EXTRN	??1COutlookHelper@@UAE@XZ:NEAR			; COutlookHelper::~COutlookHelper
EXTRN	?IsOutlookObject@COutlookHelper@@SAHPAVCOleDataObject@@@Z:NEAR ; COutlookHelper::IsOutlookObject
EXTRN	?GetSelection@COutlookHelper@@QAEPAVSelection@OutlookAPI@@XZ:NEAR ; COutlookHelper::GetSelection
EXTRN	?FormatItemAsUrl@COutlookHelper@@SA?AVCString@@AAV_MailItem@OutlookAPI@@K@Z:NEAR ; COutlookHelper::FormatItemAsUrl
EXTRN	?CF_OUTLOOK@COutlookHelper@@2GB:WORD		; COutlookHelper::CF_OUTLOOK
EXTRN	?ReplaceSel@CRichEditCtrl@@QAEXPBGH@Z:NEAR	; CRichEditCtrl::ReplaceSel
EXTRN	?SetFocus@CWnd@@QAEPAV1@XZ:NEAR			; CWnd::SetFocus
EXTRN	??0COleDataObject@@QAE@XZ:NEAR			; COleDataObject::COleDataObject
EXTRN	?Attach@COleDataObject@@QAEXPAUIDataObject@@H@Z:NEAR ; COleDataObject::Attach
EXTRN	??1COleDataObject@@QAE@XZ:NEAR			; COleDataObject::~COleDataObject
EXTRN	??0COleVariant@@QAE@FG@Z:NEAR			; COleVariant::COleVariant
EXTRN	??1COleVariant@@QAE@XZ:NEAR			; COleVariant::~COleVariant
EXTRN	?AfxAssertFailedLine@@YGHPBDH@Z:NEAR		; AfxAssertFailedLine
EXTRN	??YCString@@QAEABV0@ABV0@@Z:NEAR		; CString::operator+=
EXTRN	??YCString@@QAEABV0@D@Z:NEAR			; CString::operator+=
EXTRN	??H@YG?AVCString@@ABV0@D@Z:NEAR			; operator+
EXTRN	??H@YG?AVCString@@DABV0@@Z:NEAR			; operator+
EXTRN	?GetCount@Selection@OutlookAPI@@QAEJXZ:NEAR	; OutlookAPI::Selection::GetCount
EXTRN	?Item@Selection@OutlookAPI@@QAEPAUIDispatch@@ABUtagVARIANT@@@Z:NEAR ; OutlookAPI::Selection::Item
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79962	DD	019930520H
	DD	0aH
	DD	FLAT:$T79964
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79964	DD	0ffffffffH
	DD	FLAT:$L79952
	DD	00H
	DD	FLAT:$L79953
	DD	01H
	DD	FLAT:$L79954
	DD	02H
	DD	FLAT:$L79955
	DD	03H
	DD	FLAT:$L79956
	DD	02H
	DD	FLAT:$L79956
	DD	05H
	DD	FLAT:$L79957
	DD	02H
	DD	FLAT:$L79958
	DD	07H
	DD	FLAT:$L79959
	DD	02H
	DD	FLAT:$L79960
xdata$x	ENDS
;	COMDAT ?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z
_TEXT	SEGMENT
$T79941 = -80
$T79942 = -84
$T79943 = -88
$T79944 = -92
$T79947 = -96
$T79948 = -100
$T79949 = -104
$T79950 = -108
$T79951 = -112
__$EHRec$ = -12
_lpdataobj$ = 8
_lpcfFormat$ = 12
_fReally$ = 20
_this$ = -116
_bEnable$ = -16
_bEnable$77560 = -36
_dataobj$77567 = -56
_outlook$77572 = -40
_pSelection$77573 = -32
_sLinks$77574 = -28
_nNumSel$77575 = -24
_nSel$77576 = -20
_item$77581 = -64
?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z PROC NEAR ; CUrlRichEditCtrl::QueryAcceptData, COMDAT

; 527  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79963
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 39					; 00000027H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 528  : 	BOOL bEnable = !(GetStyle() & ES_READONLY) && IsWindowEnabled();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStyle@CWnd@@QBEKXZ			; CWnd::GetStyle
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	SHORT $L79937
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWindowEnabled@CWnd@@QBEHXZ		; CWnd::IsWindowEnabled
	test	eax, eax
	je	SHORT $L79937
	mov	DWORD PTR -120+[ebp], 1
	jmp	SHORT $L79938
$L79937:
	mov	DWORD PTR -120+[ebp], 0
$L79938:
	mov	eax, DWORD PTR -120+[ebp]
	mov	DWORD PTR _bEnable$[ebp], eax

; 529  : 		
; 530  : 	// always clear drag object
; 531  : 	m_lpDragObject = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0

; 532  : 
; 533  : 	if (bEnable)

	cmp	DWORD PTR _bEnable$[ebp], 0
	je	$L77557

; 535  : 		// snap-shot drag object when dragging
; 536  : 		if (!fReally)

	cmp	DWORD PTR _fReally$[ebp], 0
	jne	SHORT $L77558

; 537  : 			m_lpDragObject = lpdataobj;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpdataobj$[ebp]
	mov	DWORD PTR [edx+236], eax
$L77558:

; 538  : 
; 539  :    		*lpcfFormat = GetAcceptableClipFormat(lpdataobj, *lpcfFormat);

	mov	esi, esp
	mov	ecx, DWORD PTR _lpcfFormat$[ebp]
	mov	dx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpdataobj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+256]
	cmp	esi, esp
	call	__chkesp
	mov	ecx, DWORD PTR _lpcfFormat$[ebp]
	mov	WORD PTR [ecx], ax

; 540  : 
; 541  : 		// is this an outlook drop actually happening?
; 542  : 		if (fReally && (*lpcfFormat == COutlookHelper::CF_OUTLOOK))

	cmp	DWORD PTR _fReally$[ebp], 0
	je	$L77559
	mov	edx, DWORD PTR _lpcfFormat$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx]
	xor	ecx, ecx
	mov	cx, WORD PTR ?CF_OUTLOOK@COutlookHelper@@2GB ; COutlookHelper::CF_OUTLOOK
	cmp	eax, ecx
	jne	$L77559

; 544  : 			BOOL bEnable = !(GetStyle() & ES_READONLY) && IsWindowEnabled();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStyle@CWnd@@QBEKXZ			; CWnd::GetStyle
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	SHORT $L79939
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWindowEnabled@CWnd@@QBEHXZ		; CWnd::IsWindowEnabled
	test	eax, eax
	je	SHORT $L79939
	mov	DWORD PTR -124+[ebp], 1
	jmp	SHORT $L79940
$L79939:
	mov	DWORD PTR -124+[ebp], 0
$L79940:
	mov	edx, DWORD PTR -124+[ebp]
	mov	DWORD PTR _bEnable$77560[ebp], edx
$L77561:

; 545  : 			ASSERT(bEnable);

	cmp	DWORD PTR _bEnable$77560[ebp], 0
	jne	SHORT $L77564
	push	545					; 00000221H
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L77564
	int	3
$L77564:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L77561

; 546  : 
; 547  : 			if (!bEnable)

	cmp	DWORD PTR _bEnable$77560[ebp], 0
	jne	SHORT $L77565

; 548  : 				return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	$L77555
$L77565:

; 549  : 
; 550  : 			// insert outlook links at the cursor position
; 551  : 			SetSel(m_crDropSel);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 228				; 000000e4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 552  : 
; 553  : 			COleDataObject dataobj;

	lea	ecx, DWORD PTR _dataobj$77567[ebp]
	call	??0COleDataObject@@QAE@XZ		; COleDataObject::COleDataObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 554  : 			dataobj.Attach(lpdataobj, FALSE);

	push	0
	mov	edx, DWORD PTR _lpdataobj$[ebp]
	push	edx
	lea	ecx, DWORD PTR _dataobj$77567[ebp]
	call	?Attach@COleDataObject@@QAEXPAUIDataObject@@H@Z ; COleDataObject::Attach
$L77568:

; 555  : 
; 556  : 			ASSERT(COutlookHelper::IsOutlookObject(&dataobj));

	lea	eax, DWORD PTR _dataobj$77567[ebp]
	push	eax
	call	?IsOutlookObject@COutlookHelper@@SAHPAVCOleDataObject@@@Z ; COutlookHelper::IsOutlookObject
	add	esp, 4
	test	eax, eax
	jne	SHORT $L77571
	push	556					; 0000022cH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L77571
	int	3
$L77571:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L77568

; 557  : 
; 558  : 			COutlookHelper outlook;

	lea	ecx, DWORD PTR _outlook$77572[ebp]
	call	??0COutlookHelper@@QAE@XZ		; COutlookHelper::COutlookHelper
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 559  : 			OutlookAPI::Selection* pSelection = outlook.GetSelection();

	lea	ecx, DWORD PTR _outlook$77572[ebp]
	call	?GetSelection@COutlookHelper@@QAEPAVSelection@OutlookAPI@@XZ ; COutlookHelper::GetSelection
	mov	DWORD PTR _pSelection$77573[ebp], eax

; 560  : 			
; 561  : 			CString sLinks;

	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 562  : 			int nNumSel = pSelection->GetCount();

	mov	ecx, DWORD PTR _pSelection$77573[ebp]
	call	?GetCount@Selection@OutlookAPI@@QAEJXZ	; OutlookAPI::Selection::GetCount
	mov	DWORD PTR _nNumSel$77575[ebp], eax

; 563  : 
; 564  : 			// 1-based indexing
; 565  : 			for (short nSel = 1; nSel <= nNumSel; nSel++)

	mov	WORD PTR _nSel$77576[ebp], 1
	jmp	SHORT $L77577
$L77578:
	mov	dx, WORD PTR _nSel$77576[ebp]
	add	dx, 1
	mov	WORD PTR _nSel$77576[ebp], dx
$L77577:
	movsx	eax, WORD PTR _nSel$77576[ebp]
	cmp	eax, DWORD PTR _nNumSel$77575[ebp]
	jg	$L77579

; 567  : 				OutlookAPI::_MailItem item(pSelection->Item(COleVariant(nSel)));

	push	2
	mov	cx, WORD PTR _nSel$77576[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T79941[ebp]
	call	??0COleVariant@@QAE@FG@Z		; COleVariant::COleVariant
	mov	DWORD PTR -128+[ebp], eax
	mov	edx, DWORD PTR -128+[ebp]
	mov	DWORD PTR -132+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR -132+[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSelection$77573[ebp]
	call	?Item@Selection@OutlookAPI@@QAEPAUIDispatch@@ABUtagVARIANT@@@Z ; OutlookAPI::Selection::Item
	push	eax
	lea	ecx, DWORD PTR _item$77581[ebp]
	call	??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z ; OutlookAPI::_MailItem::_MailItem
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T79941[ebp]
	call	??1COleVariant@@QAE@XZ			; COleVariant::~COleVariant

; 568  : 
; 569  : 				sLinks += COutlookHelper::FormatItemAsUrl(item, (OAFMT_NICE | OAFMT_BRACED));

	push	3
	lea	ecx, DWORD PTR _item$77581[ebp]
	push	ecx
	lea	edx, DWORD PTR $T79942[ebp]
	push	edx
	call	?FormatItemAsUrl@COutlookHelper@@SA?AVCString@@AAV_MailItem@OutlookAPI@@K@Z ; COutlookHelper::FormatItemAsUrl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR -136+[ebp], eax
	mov	eax, DWORD PTR -136+[ebp]
	mov	DWORD PTR -140+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR -140+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??YCString@@QAEABV0@ABV0@@Z		; CString::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T79942[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 570  : 				
; 571  : 				if ((nSel < nNumSel) || (nNumSel > 1))

	movsx	edx, WORD PTR _nSel$77576[ebp]
	cmp	edx, DWORD PTR _nNumSel$77575[ebp]
	jl	SHORT $L77584
	cmp	DWORD PTR _nNumSel$77575[ebp], 1
	jle	SHORT $L77583
$L77584:

; 572  : 					sLinks += '\n';

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??YCString@@QAEABV0@D@Z			; CString::operator+=
$L77583:

; 573  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _item$77581[ebp]
	call	??1_MailItem@OutlookAPI@@QAE@XZ		; OutlookAPI::_MailItem::~_MailItem
	jmp	$L77578
$L77579:

; 574  : 
; 575  : 			// cleanup
; 576  : 			delete pSelection;

	mov	eax, DWORD PTR _pSelection$77573[ebp]
	mov	DWORD PTR $T79944[ebp], eax
	mov	ecx, DWORD PTR $T79944[ebp]
	mov	DWORD PTR $T79943[ebp], ecx
	cmp	DWORD PTR $T79943[ebp], 0
	je	SHORT $L79945
	push	1
	mov	ecx, DWORD PTR $T79943[ebp]
	call	??_GSelection@OutlookAPI@@QAEPAXI@Z	; OutlookAPI::Selection::`scalar deleting destructor'
	mov	DWORD PTR -144+[ebp], eax
	jmp	SHORT $L79946
$L79945:
	mov	DWORD PTR -144+[ebp], 0
$L79946:

; 577  : 
; 578  : 			// trailing newline
; 579  : 			if (!sLinks.IsEmpty())

	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	$L77587

; 581  : 				// leading and trailing spaces
; 582  : 				if (m_crDropSel.cpMin > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+228], 0
	jle	$L77592

; 584  : 					if (nNumSel == 1)

	cmp	DWORD PTR _nNumSel$77575[ebp], 1
	jne	SHORT $L77589

; 585  : 						sLinks = ' ' + sLinks + ' ';

	push	32					; 00000020H
	lea	eax, DWORD PTR _sLinks$77574[ebp]
	push	eax
	push	32					; 00000020H
	lea	ecx, DWORD PTR $T79947[ebp]
	push	ecx
	call	??H@YG?AVCString@@DABV0@@Z		; operator+
	mov	DWORD PTR -148+[ebp], eax
	mov	edx, DWORD PTR -148+[ebp]
	mov	DWORD PTR -152+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR -152+[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79948[ebp]
	push	ecx
	call	??H@YG?AVCString@@ABV0@D@Z		; operator+
	mov	DWORD PTR -156+[ebp], eax
	mov	edx, DWORD PTR -156+[ebp]
	mov	DWORD PTR -160+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR -160+[ebp]
	push	eax
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T79948[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T79947[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 586  : 					else

	jmp	SHORT $L77592
$L77589:

; 587  : 						sLinks = '\n' + sLinks;

	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	push	ecx
	push	10					; 0000000aH
	lea	edx, DWORD PTR $T79949[ebp]
	push	edx
	call	??H@YG?AVCString@@DABV0@@Z		; operator+
	mov	DWORD PTR -164+[ebp], eax
	mov	eax, DWORD PTR -164+[ebp]
	mov	DWORD PTR -168+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR -168+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T79949[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77592:

; 589  : 
; 590  : 				ReplaceSel(sLinks, TRUE);

	push	1
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReplaceSel@CRichEditCtrl@@QAEXPBGH@Z	; CRichEditCtrl::ReplaceSel

; 591  : 				ParseAndFormatText();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ; CUrlRichEditCtrl::ParseAndFormatText

; 592  : 				SetFocus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFocus@CWnd@@QAEPAV1@XZ		; CWnd::SetFocus

; 593  : 
; 594  : 				return S_OK;

	mov	DWORD PTR $T79950[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _outlook$77572[ebp]
	call	??1COutlookHelper@@UAE@XZ		; COutlookHelper::~COutlookHelper
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataobj$77567[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	mov	eax, DWORD PTR $T79950[ebp]
	jmp	SHORT $L77555
$L77587:

; 597  : 				return E_FAIL;

	mov	DWORD PTR $T79951[ebp], -2147467259	; 80004005H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _outlook$77572[ebp]
	call	??1COutlookHelper@@UAE@XZ		; COutlookHelper::~COutlookHelper
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataobj$77567[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	mov	eax, DWORD PTR $T79951[ebp]
	jmp	SHORT $L77555
$L77559:

; 599  : 
; 600  : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L77555
$L77557:

; 602  : 	
; 603  :    // else
; 604  :    return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$L77555:

; 605  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79952:
	lea	ecx, DWORD PTR _dataobj$77567[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	ret	0
$L79953:
	lea	ecx, DWORD PTR _outlook$77572[ebp]
	call	??1COutlookHelper@@UAE@XZ		; COutlookHelper::~COutlookHelper
	ret	0
$L79954:
	lea	ecx, DWORD PTR _sLinks$77574[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79955:
	lea	ecx, DWORD PTR $T79941[ebp]
	call	??1COleVariant@@QAE@XZ			; COleVariant::~COleVariant
	ret	0
$L79956:
	lea	ecx, DWORD PTR _item$77581[ebp]
	call	??1_MailItem@OutlookAPI@@QAE@XZ		; OutlookAPI::_MailItem::~_MailItem
	ret	0
$L79957:
	lea	ecx, DWORD PTR $T79942[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79958:
	lea	ecx, DWORD PTR $T79947[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79959:
	lea	ecx, DWORD PTR $T79948[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79960:
	lea	ecx, DWORD PTR $T79949[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L79963:
	mov	eax, OFFSET FLAT:$T79962
	jmp	___CxxFrameHandler
text$x	ENDS
?QueryAcceptData@CUrlRichEditCtrl@@MAEJPAUIDataObject@@PAGKHPAX@Z ENDP ; CUrlRichEditCtrl::QueryAcceptData
EXTRN	??0COleDispatchDriver@@QAE@PAUIDispatch@@H@Z:NEAR ; COleDispatchDriver::COleDispatchDriver
;	COMDAT ??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z
_TEXT	SEGMENT
_pDispatch$ = 8
_this$ = -4
??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z PROC NEAR	; OutlookAPI::_MailItem::_MailItem, COMDAT

; 3250 : 	_MailItem(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _pDispatch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0COleDispatchDriver@@QAE@PAUIDispatch@@H@Z ; COleDispatchDriver::COleDispatchDriver
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_MailItem@OutlookAPI@@QAE@PAUIDispatch@@@Z ENDP	; OutlookAPI::_MailItem::_MailItem
_TEXT	ENDS
EXTRN	??1COleDispatchDriver@@QAE@XZ:NEAR		; COleDispatchDriver::~COleDispatchDriver
;	COMDAT ??1_MailItem@OutlookAPI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1_MailItem@OutlookAPI@@QAE@XZ PROC NEAR		; OutlookAPI::_MailItem::~_MailItem, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1COleDispatchDriver@@QAE@XZ		; COleDispatchDriver::~COleDispatchDriver
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_MailItem@OutlookAPI@@QAE@XZ ENDP			; OutlookAPI::_MailItem::~_MailItem
_TEXT	ENDS
PUBLIC	??1Selection@OutlookAPI@@QAE@XZ			; OutlookAPI::Selection::~Selection
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GSelection@OutlookAPI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GSelection@OutlookAPI@@QAEPAXI@Z PROC NEAR		; OutlookAPI::Selection::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Selection@OutlookAPI@@QAE@XZ		; OutlookAPI::Selection::~Selection
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L77606
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L77606:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSelection@OutlookAPI@@QAEPAXI@Z ENDP		; OutlookAPI::Selection::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1Selection@OutlookAPI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1Selection@OutlookAPI@@QAE@XZ PROC NEAR		; OutlookAPI::Selection::~Selection, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1COleDispatchDriver@@QAE@XZ		; COleDispatchDriver::~COleDispatchDriver
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Selection@OutlookAPI@@QAE@XZ ENDP			; OutlookAPI::Selection::~Selection
_TEXT	ENDS
EXTRN	?IsOutlookObject@COutlookHelper@@SAHPAUIDataObject@@@Z:NEAR ; COutlookHelper::IsOutlookObject
EXTRN	?IsDataAvailable@COleDataObject@@QAEHGPAUtagFORMATETC@@@Z:NEAR ; COleDataObject::IsDataAvailable
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T79985	DD	019930520H
	DD	01H
	DD	FLAT:$T79987
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T79987	DD	0ffffffffH
	DD	FLAT:$L79983
xdata$x	ENDS
;	COMDAT ?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z
_TEXT	SEGMENT
$T79980 = -44
$T79981 = -48
$T79982 = -52
__$EHRec$ = -12
_lpDataOb$ = 8
_format$ = 12
_this$ = -56
_formats$ = -20
_nNumFmts$ = -24
_dataobj$ = -40
_nFmt$ = -16
?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z PROC NEAR ; CUrlRichEditCtrl::GetAcceptableClipFormat, COMDAT

; 608  : { 

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L79986
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 44					; 0000002cH
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 	CLIPFORMAT formats[] = 
; 610  : 	{ 
; 611  : 		CF_HDROP,

	mov	WORD PTR _formats$[ebp], 15		; 0000000fH

; 612  : 			
; 613  : #ifndef _UNICODE
; 614  : 		CF_TEXT,
; 615  : #else
; 616  : 		CF_UNICODETEXT,

	mov	WORD PTR _formats$[ebp+2], 13		; 0000000dH

; 617  : #endif
; 618  : 	};
; 619  : 	
; 620  : 	const long nNumFmts = sizeof(formats) / sizeof(CLIPFORMAT);

	mov	DWORD PTR _nNumFmts$[ebp], 2

; 621  : 	
; 622  : 	// check for outlook first
; 623  : 	if (COutlookHelper::IsOutlookObject(lpDataOb))

	mov	eax, DWORD PTR _lpDataOb$[ebp]
	push	eax
	call	?IsOutlookObject@COutlookHelper@@SAHPAUIDataObject@@@Z ; COutlookHelper::IsOutlookObject
	add	esp, 4
	test	eax, eax
	je	SHORT $L77617

; 624  : 		return COutlookHelper::CF_OUTLOOK;

	mov	ax, WORD PTR ?CF_OUTLOOK@COutlookHelper@@2GB ; COutlookHelper::CF_OUTLOOK
	jmp	$L77613
$L77617:

; 625  :     
; 626  : 	// else
; 627  : 	COleDataObject dataobj;

	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	??0COleDataObject@@QAE@XZ		; COleDataObject::COleDataObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 628  :     dataobj.Attach(lpDataOb, FALSE);

	push	0
	mov	ecx, DWORD PTR _lpDataOb$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	?Attach@COleDataObject@@QAEXPAUIDataObject@@H@Z ; COleDataObject::Attach

; 629  : 
; 630  : 	for (int nFmt = 0; nFmt < nNumFmts; nFmt++)

	mov	DWORD PTR _nFmt$[ebp], 0
	jmp	SHORT $L77620
$L77621:
	mov	edx, DWORD PTR _nFmt$[ebp]
	add	edx, 1
	mov	DWORD PTR _nFmt$[ebp], edx
$L77620:
	cmp	DWORD PTR _nFmt$[ebp], 2
	jge	SHORT $L77622

; 632  : 		if (format && format == formats[nFmt])

	mov	eax, DWORD PTR _format$[ebp]
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	je	SHORT $L77623
	mov	ecx, DWORD PTR _format$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _nFmt$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR _formats$[ebp+edx*2]
	cmp	ecx, eax
	jne	SHORT $L77623

; 633  : 			return format;

	mov	cx, WORD PTR _format$[ebp]
	mov	WORD PTR $T79980[ebp], cx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	mov	ax, WORD PTR $T79980[ebp]
	jmp	SHORT $L77613
$L77623:

; 634  : 		
; 635  : 		if (dataobj.IsDataAvailable(formats[nFmt]))

	push	0
	mov	edx, DWORD PTR _nFmt$[ebp]
	mov	ax, WORD PTR _formats$[ebp+edx*2]
	push	eax
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	?IsDataAvailable@COleDataObject@@QAEHGPAUtagFORMATETC@@@Z ; COleDataObject::IsDataAvailable
	test	eax, eax
	je	SHORT $L77625

; 636  : 			return formats[nFmt];

	mov	ecx, DWORD PTR _nFmt$[ebp]
	mov	dx, WORD PTR _formats$[ebp+ecx*2]
	mov	WORD PTR $T79981[ebp], dx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	mov	ax, WORD PTR $T79981[ebp]
	jmp	SHORT $L77613
$L77625:

; 637  : 	}

	jmp	$L77621
$L77622:

; 638  : 	
; 639  : #ifndef _UNICODE
; 640  : 	return CF_TEXT;
; 641  : #else
; 642  : 	return CF_UNICODETEXT;

	mov	WORD PTR $T79982[ebp], 13		; 0000000dH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	mov	ax, WORD PTR $T79982[ebp]
$L77613:

; 643  : #endif
; 644  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L79983:
	lea	ecx, DWORD PTR _dataobj$[ebp]
	call	??1COleDataObject@@QAE@XZ		; COleDataObject::~COleDataObject
	ret	0
$L79986:
	mov	eax, OFFSET FLAT:$T79985
	jmp	___CxxFrameHandler
text$x	ENDS
?GetAcceptableClipFormat@CUrlRichEditCtrl@@MAEGPAUIDataObject@@G@Z ENDP ; CUrlRichEditCtrl::GetAcceptableClipFormat
PUBLIC	?HasFlag@Misc@@YAHKK@Z				; Misc::HasFlag
PUBLIC	?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ	; CUrlRichEditCtrl::TrackDragCursor
;	COMDAT ?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z
_TEXT	SEGMENT
_fDrag$ = 8
_grfKeyState$ = 12
_pdwEffect$ = 16
_this$ = -20
_bEnable$77635 = -4
_dwEffect$77638 = -8
_bFileDrop$77641 = -12
_bCtrl$77644 = -16
?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z PROC NEAR ; CUrlRichEditCtrl::GetDragDropEffect, COMDAT

; 647  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 	if (!fDrag) // allowable dest effects 

	cmp	DWORD PTR _fDrag$[ebp], 0
	jne	$L77647

; 650  : 		BOOL bEnable = !(GetStyle() & ES_READONLY) && IsWindowEnabled();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStyle@CWnd@@QBEKXZ			; CWnd::GetStyle
	and	eax, 2048				; 00000800H
	test	eax, eax
	jne	SHORT $L79992
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsWindowEnabled@CWnd@@QBEHXZ		; CWnd::IsWindowEnabled
	test	eax, eax
	je	SHORT $L79992
	mov	DWORD PTR -24+[ebp], 1
	jmp	SHORT $L79993
$L79992:
	mov	DWORD PTR -24+[ebp], 0
$L79993:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR _bEnable$77635[ebp], eax

; 651  : 		
; 652  : 		if (!bEnable)

	cmp	DWORD PTR _bEnable$77635[ebp], 0
	jne	SHORT $L77636

; 654  : 			*pdwEffect = DROPEFFECT_NONE;

	mov	ecx, DWORD PTR _pdwEffect$[ebp]
	mov	DWORD PTR [ecx], 0

; 656  : 		else

	jmp	SHORT $L77645
$L77636:

; 658  : 			DWORD dwEffect = DROPEFFECT_NONE;

	mov	DWORD PTR _dwEffect$77638[ebp], 0

; 659  : 
; 660  : 			// test for outlook object first
; 661  : 			if (COutlookHelper::IsOutlookObject(m_lpDragObject))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	push	eax
	call	?IsOutlookObject@COutlookHelper@@SAHPAUIDataObject@@@Z ; COutlookHelper::IsOutlookObject
	add	esp, 4
	test	eax, eax
	je	SHORT $L77639

; 663  : 				dwEffect = DROPEFFECT_LINK;

	mov	DWORD PTR _dwEffect$77638[ebp], 4

; 665  : 			else

	jmp	SHORT $L77643
$L77639:

; 667  : 				// we can deduce (I think) that what's being dragged is a file
; 668  : 				// by whether pdwEffect include the LINK effect.
; 669  : 				BOOL bFileDrop = Misc::HasFlag(*pdwEffect, DROPEFFECT_LINK);

	push	4
	mov	ecx, DWORD PTR _pdwEffect$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?HasFlag@Misc@@YAHKK@Z			; Misc::HasFlag
	add	esp, 8
	mov	DWORD PTR _bFileDrop$77641[ebp], eax

; 670  : 
; 671  : 				// if so save off the current selection pos (for now) because it gets reset
; 672  : 				// when the files are dropped
; 673  : 				if (bFileDrop)

	cmp	DWORD PTR _bFileDrop$77641[ebp], 0
	je	SHORT $L77642

; 675  : 					// can't return DROPEFFECT_LINK else we don't
; 676  : 					// get notified of the file drop (go figure)
; 677  : 					dwEffect = DROPEFFECT_MOVE;

	mov	DWORD PTR _dwEffect$77638[ebp], 2

; 682  : 				else // it's text

	jmp	SHORT $L77643
$L77642:

; 684  : 					BOOL bCtrl = Misc::HasFlag(grfKeyState, MK_CONTROL);

	push	8
	mov	eax, DWORD PTR _grfKeyState$[ebp]
	push	eax
	call	?HasFlag@Misc@@YAHKK@Z			; Misc::HasFlag
	add	esp, 8
	mov	DWORD PTR _bCtrl$77644[ebp], eax

; 685  : 
; 686  : 					dwEffect = (bCtrl ? DROPEFFECT_COPY : DROPEFFECT_MOVE);

	mov	ecx, DWORD PTR _bCtrl$77644[ebp]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 2
	mov	DWORD PTR _dwEffect$77638[ebp], ecx
$L77643:

; 689  : 			
; 690  : 			if (dwEffect & *pdwEffect) // make sure allowed type

	mov	edx, DWORD PTR _pdwEffect$[ebp]
	mov	eax, DWORD PTR _dwEffect$77638[ebp]
	and	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $L77645

; 691  : 				*pdwEffect = dwEffect;

	mov	ecx, DWORD PTR _pdwEffect$[ebp]
	mov	edx, DWORD PTR _dwEffect$77638[ebp]
	mov	DWORD PTR [ecx], edx
$L77645:

; 693  : 		
; 694  : 		// keep track of cursor
; 695  : 		if (*pdwEffect != DROPEFFECT_NONE)

	mov	eax, DWORD PTR _pdwEffect$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L77646

; 696  : 			TrackDragCursor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ ; CUrlRichEditCtrl::TrackDragCursor

; 697  : 		else

	jmp	SHORT $L77647
$L77646:

; 698  : 			m_crDropSel.cpMin = m_crDropSel.cpMax = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+232], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+228], 0
$L77647:

; 700  : 
; 701  : 	return S_OK;

	xor	eax, eax

; 702  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetDragDropEffect@CUrlRichEditCtrl@@MAEJHKPAK@Z ENDP	; CUrlRichEditCtrl::GetDragDropEffect
_TEXT	ENDS
;	COMDAT ?HasFlag@Misc@@YAHKK@Z
_TEXT	SEGMENT
_dwFlags$ = 8
_dwFlag$ = 12
?HasFlag@Misc@@YAHKK@Z PROC NEAR			; Misc::HasFlag, COMDAT

; 215  : 	inline BOOL HasFlag(DWORD dwFlags, DWORD dwFlag) { return (((dwFlags & dwFlag) == dwFlag) ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, DWORD PTR _dwFlag$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _dwFlag$[ebp]
	sete	cl
	mov	eax, ecx
	pop	ebp
	ret	0
?HasFlag@Misc@@YAHKK@Z ENDP				; Misc::HasFlag
_TEXT	ENDS
EXTRN	?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z:NEAR	; CWnd::ScreenToClient
EXTRN	__imp__GetMessagePos@0:NEAR
EXTRN	?CharFromPoint@CRichEditBaseCtrl@@QBEHABVCPoint@@@Z:NEAR ; CRichEditBaseCtrl::CharFromPoint
EXTRN	?ShowCaret@CWnd@@QAEXXZ:NEAR			; CWnd::ShowCaret
EXTRN	??0CPoint@@QAE@K@Z:NEAR				; CPoint::CPoint
;	COMDAT ?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ
_TEXT	SEGMENT
_this$ = -16
_ptCursor$ = -12
_nChar$ = -4
?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ PROC NEAR	; CUrlRichEditCtrl::TrackDragCursor, COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 706  : 	// also track the cursor for the drop position
; 707  : 	CPoint ptCursor(::GetMessagePos());

	mov	esi, esp
	call	DWORD PTR __imp__GetMessagePos@0
	cmp	esi, esp
	call	__chkesp
	push	eax
	lea	ecx, DWORD PTR _ptCursor$[ebp]
	call	??0CPoint@@QAE@K@Z			; CPoint::CPoint

; 708  : 				
; 709  : 	ScreenToClient(&ptCursor);

	lea	eax, DWORD PTR _ptCursor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ScreenToClient

; 710  : 	int nChar = CharFromPoint(ptCursor);

	lea	ecx, DWORD PTR _ptCursor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CharFromPoint@CRichEditBaseCtrl@@QBEHABVCPoint@@@Z ; CRichEditBaseCtrl::CharFromPoint
	mov	DWORD PTR _nChar$[ebp], eax

; 711  : 	m_crDropSel.cpMin = m_crDropSel.cpMax = nChar;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nChar$[ebp]
	mov	DWORD PTR [edx+232], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nChar$[ebp]
	mov	DWORD PTR [ecx+228], edx

; 712  : 
; 713  : 	SetFocus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFocus@CWnd@@QAEPAV1@XZ		; CWnd::SetFocus

; 714  : 	SetSel(m_crDropSel);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 715  : 	ShowCaret();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowCaret@CWnd@@QAEXXZ			; CWnd::ShowCaret

; 716  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?TrackDragCursor@CUrlRichEditCtrl@@IAEXXZ ENDP		; CUrlRichEditCtrl::TrackDragCursor
_TEXT	ENDS
;	COMDAT ?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z
_TEXT	SEGMENT
_this$ = -12
_point$ = -8
?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z PROC NEAR ; CUrlRichEditCtrl::GetContextMenu, COMDAT

; 720  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 	CPoint point = m_ptContextMenu;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	mov	edx, DWORD PTR [eax+220]
	mov	DWORD PTR _point$[ebp], ecx
	mov	DWORD PTR _point$[ebp+4], edx

; 722  : 	
; 723  : 	// send on as a simple context menu message
; 724  : 	SendMessage(WM_CONTEXTMENU, (WPARAM)GetSafeHwnd(), MAKELPARAM(point.x, point.y));

	mov	eax, DWORD PTR _point$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _point$[ebp+4]
	and	ecx, 65535				; 0000ffffH
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ	; CWnd::GetSafeHwnd
	push	eax
	push	123					; 0000007bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 725  : 	return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 726  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetContextMenu@CUrlRichEditCtrl@@MAEJGPAUIOleObject@@PAU_charrange@@PAPAUHMENU__@@@Z ENDP ; CUrlRichEditCtrl::GetContextMenu
_TEXT	ENDS
EXTRN	??0CString@@QAE@ABV0@@Z:NEAR			; CString::CString
EXTRN	??0CString@@QAE@PBD@Z:NEAR			; CString::CString
EXTRN	?Mid@CString@@QBE?AV1@H@Z:NEAR			; CString::Mid
EXTRN	?MakeLower@CString@@QAEXXZ:NEAR			; CString::MakeLower
EXTRN	?Replace@CString@@QAEHGG@Z:NEAR			; CString::Replace
EXTRN	?Find@CString@@QBEHPBG@Z:NEAR			; CString::Find
EXTRN	__imp__lstrlenW@4:NEAR
_BSS	SEGMENT
$SG77690 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT data
; File D:\_CODE\Shared\urlricheditctrl.cpp
data	SEGMENT
$SG77688 DB	' ', 00H, 00H, 00H
$SG77689 DB	'%', 00H, '2', 00H, '0', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80012	DD	019930520H
	DD	05H
	DD	FLAT:$T80014
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80014	DD	0ffffffffH
	DD	FLAT:$L80004
	DD	00H
	DD	FLAT:$L80005
	DD	0ffffffffH
	DD	FLAT:$L80005
	DD	02H
	DD	FLAT:$L80006
	DD	03H
	DD	FLAT:$L80010
xdata$x	ENDS
;	COMDAT ?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z
_TEXT	SEGMENT
$T80002 = -36
$T80003 = -40
$T80008 = -44
__$EHRec$ = -12
_nURL$ = 12
_bAsFile$ = 16
___$ReturnUdt$ = 8
_this$ = -48
_sUrl$77682 = -20
_sUrlLower$77683 = -16
?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z PROC NEAR	; CUrlRichEditCtrl::GetUrl, COMDAT

; 731  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80013
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T80008[ebp], 0
$L77675:

; 732  : 	ASSERT (nURL >= 0 && nURL < m_aUrls.GetSize());

	cmp	DWORD PTR _nURL$[ebp], 0
	jl	SHORT $L77679
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	cmp	DWORD PTR _nURL$[ebp], eax
	jl	SHORT $L77678
$L77679:
	push	732					; 000002dcH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L77678
	int	3
$L77678:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L77675

; 733  : 	
; 734  : 	if (nURL >= 0 && nURL < m_aUrls.GetSize())

	cmp	DWORD PTR _nURL$[ebp], 0
	jl	$L77680
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	cmp	DWORD PTR _nURL$[ebp], eax
	jge	$L77680

; 736  : 		CString sUrl(m_aUrls[nURL].sUrl);

	mov	ecx, DWORD PTR _nURL$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T80002[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR -52+[ebp], eax
	mov	eax, DWORD PTR -52+[ebp]
	mov	DWORD PTR -56+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -56+[ebp]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T80002[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM

; 737  : 		CString sUrlLower(sUrl);

	lea	edx, DWORD PTR _sUrl$77682[ebp]
	push	edx
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 738  : 		sUrlLower.MakeLower();

	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	?MakeLower@CString@@QAEXXZ		; CString::MakeLower

; 739  : 		
; 740  : 		if (!bAsFile || sUrlLower.Find(FILEPREFIX) == -1)

	cmp	DWORD PTR _bAsFile$[ebp], 0
	je	SHORT $L77685
	mov	eax, DWORD PTR ?FILEPREFIX@@3PBGB	; FILEPREFIX
	push	eax
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	?Find@CString@@QBEHPBG@Z		; CString::Find
	cmp	eax, -1
	jne	SHORT $L77684
$L77685:

; 741  : 			return sUrl;

	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	edx, DWORD PTR $T80008[ebp]
	or	edx, 1
	mov	DWORD PTR $T80008[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L77674
$L77684:

; 742  : 		
; 743  : 		// else
; 744  : 		if (sUrl.Find('#') ==  -1)

	push	35					; 00000023H
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	?Find@CString@@QBEHG@Z			; CString::Find
	cmp	eax, -1
	jne	SHORT $L77686

; 746  : 			sUrl = sUrl.Mid(sUrlLower.Find(FILEPREFIX) + lstrlen(FILEPREFIX));

	mov	eax, DWORD PTR ?FILEPREFIX@@3PBGB	; FILEPREFIX
	push	eax
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	?Find@CString@@QBEHPBG@Z		; CString::Find
	mov	esi, eax
	mov	edi, esp
	mov	ecx, DWORD PTR ?FILEPREFIX@@3PBGB	; FILEPREFIX
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	edi, esp
	call	__chkesp
	add	esi, eax
	push	esi
	lea	edx, DWORD PTR $T80003[ebp]
	push	edx
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	?Mid@CString@@QBE?AV1@H@Z		; CString::Mid
	mov	DWORD PTR -60+[ebp], eax
	mov	eax, DWORD PTR -60+[ebp]
	mov	DWORD PTR -64+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR -64+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T80003[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 747  : 			sUrl.Replace(_T("%20"), _T(" "));

	push	OFFSET FLAT:$SG77688
	push	OFFSET FLAT:$SG77689
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	?Replace@CString@@QAEHPBG0@Z		; CString::Replace

; 748  : 			sUrl.Replace('/', '\\');

	push	92					; 0000005cH
	push	47					; 0000002fH
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	?Replace@CString@@QAEHGG@Z		; CString::Replace
$L77686:

; 750  : 		
; 751  : 		return sUrl;

	lea	edx, DWORD PTR _sUrl$77682[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	eax, DWORD PTR $T80008[ebp]
	or	al, 1
	mov	DWORD PTR $T80008[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L77674
$L77680:

; 753  : 	
; 754  : 	// else
; 755  : 	return "";

	push	OFFSET FLAT:$SG77690
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@PBD@Z			; CString::CString
	mov	ecx, DWORD PTR $T80008[ebp]
	or	ecx, 1
	mov	DWORD PTR $T80008[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L77674:

; 756  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80004:
	lea	ecx, DWORD PTR $T80002[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	ret	0
$L80005:
	lea	ecx, DWORD PTR _sUrl$77682[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80006:
	lea	ecx, DWORD PTR _sUrlLower$77683[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80010:
	lea	ecx, DWORD PTR $T80003[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80013:
	mov	eax, OFFSET FLAT:$T80012
	jmp	___CxxFrameHandler
text$x	ENDS
?GetUrl@CUrlRichEditCtrl@@QBE?AVCString@@HH@Z ENDP	; CUrlRichEditCtrl::GetUrl
PUBLIC	?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z ; CUrlRichEditCtrl::CreateFileLink
EXTRN	??H@YG?AVCString@@ABV0@0@Z:NEAR			; operator+
EXTRN	??H@YG?AVCString@@PBGABV0@@Z:NEAR		; operator+
;	COMDAT data
; File D:\_CODE\Shared\urlricheditctrl.cpp
data	SEGMENT
$SG77702 DB	'>', 00H
	ORG $+2
$SG77703 DB	'<', 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80035	DD	019930520H
	DD	07H
	DD	FLAT:$T80037
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80037	DD	0ffffffffH
	DD	FLAT:$L80031
	DD	00H
	DD	FLAT:$L80025
	DD	01H
	DD	FLAT:$L80026
	DD	01H
	DD	FLAT:$L80027
	DD	03H
	DD	FLAT:$L80028
	DD	04H
	DD	FLAT:$L80029
	DD	05H
	DD	FLAT:$L80030
xdata$x	ENDS
;	COMDAT ?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z
_TEXT	SEGMENT
$T80020 = -20
$T80021 = -24
$T80022 = -28
$T80023 = -32
$T80024 = -36
$T80032 = -40
__$EHRec$ = -12
_szFile$ = 12
___$ReturnUdt$ = 8
_sLink$ = -16
?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z PROC NEAR ; CUrlRichEditCtrl::CreateFileLink, COMDAT

; 759  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80036
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T80032[ebp], 0

; 760  : 	CString sLink(szFile);

	mov	eax, DWORD PTR _szFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 761  : 	
; 762  : 	sLink = FILEPREFIX + sLink;

	lea	ecx, DWORD PTR _sLink$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?FILEPREFIX@@3PBGB	; FILEPREFIX
	push	edx
	lea	eax, DWORD PTR $T80020[ebp]
	push	eax
	call	??H@YG?AVCString@@PBGABV0@@Z		; operator+
	mov	DWORD PTR -44+[ebp], eax
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR -48+[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR -48+[ebp]
	push	edx
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T80020[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 763  : 	sLink.Replace('\\', '/');

	push	47					; 0000002fH
	push	92					; 0000005cH
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	?Replace@CString@@QAEHGG@Z		; CString::Replace

; 764  : 	
; 765  : 	// if the path contains spaces then brace it
; 766  : 	if (sLink.Find(' ') != -1)

	push	32					; 00000020H
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	?Find@CString@@QBEHG@Z			; CString::Find
	cmp	eax, -1
	je	$L77697

; 767  : 		sLink = "<" + sLink + ">";

	push	OFFSET FLAT:$SG77702
	lea	ecx, DWORD PTR $T80021[ebp]
	call	??0CString@@QAE@PBD@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET FLAT:$SG77703
	lea	ecx, DWORD PTR $T80022[ebp]
	call	??0CString@@QAE@PBD@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR $T80021[ebp]
	push	eax
	lea	ecx, DWORD PTR _sLink$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T80022[ebp]
	push	edx
	lea	eax, DWORD PTR $T80023[ebp]
	push	eax
	call	??H@YG?AVCString@@ABV0@0@Z		; operator+
	mov	DWORD PTR -52+[ebp], eax
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR -56+[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR -56+[ebp]
	push	edx
	lea	eax, DWORD PTR $T80024[ebp]
	push	eax
	call	??H@YG?AVCString@@ABV0@0@Z		; operator+
	mov	DWORD PTR -60+[ebp], eax
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR -64+[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR -64+[ebp]
	push	edx
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T80024[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T80023[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T80022[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T80021[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77697:

; 768  : 	
; 769  : 	return sLink;

	lea	eax, DWORD PTR _sLink$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	ecx, DWORD PTR $T80032[ebp]
	or	ecx, 1
	mov	DWORD PTR $T80032[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 770  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80025:
	lea	ecx, DWORD PTR _sLink$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80026:
	lea	ecx, DWORD PTR $T80020[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80027:
	lea	ecx, DWORD PTR $T80021[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80028:
	lea	ecx, DWORD PTR $T80022[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80029:
	lea	ecx, DWORD PTR $T80023[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80030:
	lea	ecx, DWORD PTR $T80024[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80031:
	mov	eax, DWORD PTR $T80032[ebp]
	and	eax, 1
	test	eax, eax
	je	$L80033
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L80033:
	ret	0
$L80036:
	mov	eax, OFFSET FLAT:$T80035
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z ENDP ; CUrlRichEditCtrl::CreateFileLink
PUBLIC	?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z	; CUrlRichEditCtrl::PathReplaceSel
PUBLIC	?Paste@CUrlRichEditCtrl@@QAEXXZ			; CUrlRichEditCtrl::Paste
PUBLIC	?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z ; CUrlRichEditCtrl::ExtractLinks
EXTRN	??0CClipboard@@QAE@XZ:NEAR			; CClipboard::CClipboard
EXTRN	??1CClipboard@@QAE@XZ:NEAR			; CClipboard::~CClipboard
EXTRN	?Close@CClipboard@@QAEHXZ:NEAR			; CClipboard::Close
EXTRN	?GetText@CClipboard@@QBEHAAVCString@@I@Z:NEAR	; CClipboard::GetText
EXTRN	?Paste@CRichEditCtrl@@QAEXXZ:NEAR		; CRichEditCtrl::Paste
EXTRN	?IsPath@FileMisc@@YAHPBG@Z:NEAR			; FileMisc::IsPath
EXTRN	??ACStringArray@@QAEAAVCString@@H@Z:NEAR	; CStringArray::operator[]
EXTRN	?Empty@CString@@QAEXXZ:NEAR			; CString::Empty
EXTRN	?EncodeAsUnicode@Misc@@YAAAVCString@@AAV2@I@Z:NEAR ; Misc::EncodeAsUnicode
EXTRN	__imp__RegisterClipboardFormatA@4:NEAR
EXTRN	?Format@CString@@QAAXPBGZZ:NEAR			; CString::Format
_BSS	SEGMENT
	ALIGN	4

_?CF_MSURL@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA DD 01H DUP (?)
_?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA DB 01H DUP (?)
	ALIGN	4

_?CF_MZURLA@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA DD 01H DUP (?)
_?CF_MZURLW@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT data
; File D:\_CODE\Shared\urlricheditctrl.cpp
data	SEGMENT
$SG77717 DB	'm', 00H, 's', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 'r', 00H, 'l', 00H, 00H, 00H
$SG77720 DB	'%', 00H, 's', 00H, ' ', 00H, '(', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ' ', 00H, ')', 00H, 00H, 00H
$SG77725 DB	'text/html', 00H
	ORG $+2
$SG77729 DB	't', 00H, 'e', 00H, 'x', 00H, 't', 00H, '/', 00H, 'h', 00H
	DB	't', 00H, 'm', 00H, 'l', 00H, 00H, 00H
$SG77740 DB	'%', 00H, 's', 00H, ' ', 00H, '(', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ' ', 00H, ')', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80051	DD	019930520H
	DD	07H
	DD	FLAT:$T80053
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80053	DD	0ffffffffH
	DD	FLAT:$L80043
	DD	00H
	DD	FLAT:$L80044
	DD	01H
	DD	FLAT:$L80045
	DD	02H
	DD	FLAT:$L80046
	DD	02H
	DD	FLAT:$L80047
	DD	04H
	DD	FLAT:$L80048
	DD	05H
	DD	FLAT:$L80049
xdata$x	ENDS
;	COMDAT ?Paste@CUrlRichEditCtrl@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -84
_sClipText$ = -24
_cb$ = -20
_sClipURL$77711 = -28
_sTemp$77719 = -32
_aLinks$77733 = -52
_aLinkText$77734 = -76
_nLink$77735 = -56
_sLinkAndText$77739 = -80
?Paste@CUrlRichEditCtrl@@QAEXXZ PROC NEAR		; CUrlRichEditCtrl::Paste, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80052
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 774  : 	CString sClipText;

	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 775  : 	CClipboard cb;

	lea	ecx, DWORD PTR _cb$[ebp]
	call	??0CClipboard@@QAE@XZ			; CClipboard::CClipboard
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 776  : 	
; 777  : 	// try pasting a file path
; 778  : 	if (cb.GetText(sClipText) && FileMisc::IsPath(sClipText))

	push	0
	lea	eax, DWORD PTR _sClipText$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cb$[ebp]
	call	?GetText@CClipboard@@QBEHAAVCString@@I@Z ; CClipboard::GetText
	test	eax, eax
	je	SHORT $L77709
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?IsPath@FileMisc@@YAHPBG@Z		; FileMisc::IsPath
	add	esp, 4
	test	eax, eax
	je	SHORT $L77709

; 780  : 		PathReplaceSel(sClipText, TRUE);

	push	1
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z ; CUrlRichEditCtrl::PathReplaceSel

; 782  : 	else

	jmp	$L77710
$L77709:

; 784  : 		sClipText.Empty();

	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	?Empty@CString@@QAEXXZ			; CString::Empty

; 785  : 
; 786  : 		// see if there is an associated URL
; 787  : 		CString sClipURL;

	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 788  : 		
; 789  : 		// Internet Explorer
; 790  : 		static UINT CF_MSURL  = ::RegisterClipboardFormat(_T("msSourceUrl"));

	xor	ecx, ecx
	mov	cl, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L77716
	mov	dl, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	or	dl, 1
	mov	BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA, dl
	mov	esi, esp
	push	OFFSET FLAT:$SG77717
	call	DWORD PTR __imp__RegisterClipboardFormatW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _?CF_MSURL@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA, eax
$L77716:

; 791  : 
; 792  : 		if (cb.GetText(sClipURL, CF_MSURL))

	mov	eax, DWORD PTR _?CF_MSURL@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA
	push	eax
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cb$[ebp]
	call	?GetText@CClipboard@@QBEHAAVCString@@I@Z ; CClipboard::GetText
	test	eax, eax
	je	SHORT $L77718

; 794  : 			CString sTemp;

	lea	ecx, DWORD PTR _sTemp$77719[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 795  : 			sTemp.Format(_T("%s ( %s )"), sClipText, sClipURL);

	mov	edx, DWORD PTR _sClipURL$77711[ebp]
	push	edx
	mov	eax, DWORD PTR _sClipText$[ebp]
	push	eax
	push	OFFSET FLAT:$SG77720
	lea	ecx, DWORD PTR _sTemp$77719[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 796  : 
; 797  : 			sClipText = sTemp;

	lea	edx, DWORD PTR _sTemp$77719[ebp]
	push	edx
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=

; 798  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _sTemp$77719[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 799  : 		else

	jmp	$L77732
$L77718:

; 801  : 			// Firefox can use Ansi encoding for name so we test for both
; 802  : 			static UINT CF_MZURLA = ::RegisterClipboardFormatA("text/html");

	xor	eax, eax
	mov	al, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	and	eax, 2
	test	eax, eax
	jne	SHORT $L77724
	mov	cl, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	or	cl, 2
	mov	BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA, cl
	mov	esi, esp
	push	OFFSET FLAT:$SG77725
	call	DWORD PTR __imp__RegisterClipboardFormatA@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _?CF_MZURLA@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA, eax
$L77724:

; 803  : 			static UINT CF_MZURLW = ::RegisterClipboardFormatW(_T("text/html"));

	xor	edx, edx
	mov	dl, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	and	edx, 4
	test	edx, edx
	jne	SHORT $L77728
	mov	al, BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA
	or	al, 4
	mov	BYTE PTR _?$S299@?6??Paste@CUrlRichEditCtrl@@QAEXXZ@4EA, al
	mov	esi, esp
	push	OFFSET FLAT:$SG77729
	call	DWORD PTR __imp__RegisterClipboardFormatW@4
	cmp	esi, esp
	call	__chkesp
	mov	DWORD PTR _?CF_MZURLW@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA, eax
$L77728:

; 806  : 				!cb.GetText(sClipURL, CF_MZURLW))

	mov	ecx, DWORD PTR _?CF_MZURLA@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA
	push	ecx
	lea	edx, DWORD PTR _sClipURL$77711[ebp]
	push	edx
	lea	ecx, DWORD PTR _cb$[ebp]
	call	?GetText@CClipboard@@QBEHAAVCString@@I@Z ; CClipboard::GetText
	test	eax, eax
	jne	SHORT $L77731
	mov	eax, DWORD PTR _?CF_MZURLW@?M@??Paste@CUrlRichEditCtrl@@QAEXXZ@4IA
	push	eax
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cb$[ebp]
	call	?GetText@CClipboard@@QBEHAAVCString@@I@Z ; CClipboard::GetText
	test	eax, eax
	jne	SHORT $L77731

; 808  : 				// Chrome uses CF_HTML encoded as multibyte
; 809  : 				if (cb.GetText(sClipURL, CF_HTML))

	mov	edx, DWORD PTR _CF_HTML
	push	edx
	lea	eax, DWORD PTR _sClipURL$77711[ebp]
	push	eax
	lea	ecx, DWORD PTR _cb$[ebp]
	call	?GetText@CClipboard@@QBEHAAVCString@@I@Z ; CClipboard::GetText
	test	eax, eax
	je	SHORT $L77731

; 811  : #ifdef _UNICODE
; 812  : 					Misc::EncodeAsUnicode(sClipURL);

	push	0
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	push	ecx
	call	?EncodeAsUnicode@Misc@@YAAAVCString@@AAV2@I@Z ; Misc::EncodeAsUnicode
	add	esp, 8
$L77731:

; 816  : 
; 817  : 			// process the HTML returned
; 818  : 			if (!sClipURL.IsEmpty())

	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	$L77732

; 820  : 				CStringArray aLinks, aLinkText;

	lea	ecx, DWORD PTR _aLinks$77733[ebp]
	call	??0CStringArray@@QAE@XZ			; CStringArray::CStringArray
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aLinkText$77734[ebp]
	call	??0CStringArray@@QAE@XZ			; CStringArray::CStringArray
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 821  : 				int nLink = ExtractLinks(sClipURL, aLinks, aLinkText);

	lea	edx, DWORD PTR _aLinkText$77734[ebp]
	push	edx
	lea	eax, DWORD PTR _aLinks$77733[ebp]
	push	eax
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z ; CUrlRichEditCtrl::ExtractLinks
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nLink$77735[ebp], eax
$L77737:

; 822  : 
; 823  : 				// replace link text with text + url
; 824  : 				while (nLink--)

	mov	ecx, DWORD PTR _nLink$77735[ebp]
	mov	edx, DWORD PTR _nLink$77735[ebp]
	sub	edx, 1
	mov	DWORD PTR _nLink$77735[ebp], edx
	test	ecx, ecx
	je	SHORT $L77738

; 826  : 					CString sLinkAndText;

	lea	ecx, DWORD PTR _sLinkAndText$77739[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 827  : 					sLinkAndText.Format(_T("%s ( %s )"), aLinkText[nLink], aLinks[nLink]);

	mov	eax, DWORD PTR _nLink$77735[ebp]
	push	eax
	lea	ecx, DWORD PTR _aLinks$77733[ebp]
	call	??ACStringArray@@QAEAAVCString@@H@Z	; CStringArray::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _nLink$77735[ebp]
	push	edx
	lea	ecx, DWORD PTR _aLinkText$77734[ebp]
	call	??ACStringArray@@QAEAAVCString@@H@Z	; CStringArray::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	push	OFFSET FLAT:$SG77740
	lea	ecx, DWORD PTR _sLinkAndText$77739[ebp]
	push	ecx
	call	?Format@CString@@QAAXPBGZZ		; CString::Format
	add	esp, 16					; 00000010H

; 828  : 
; 829  : 					sClipText.Replace(aLinkText[nLink], sLinkAndText);

	lea	ecx, DWORD PTR _sLinkAndText$77739[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	edx, DWORD PTR _nLink$77735[ebp]
	push	edx
	lea	ecx, DWORD PTR _aLinkText$77734[ebp]
	call	??ACStringArray@@QAEAAVCString@@H@Z	; CStringArray::operator[]
	mov	ecx, eax
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	?Replace@CString@@QAEHPBG0@Z		; CString::Replace

; 830  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _sLinkAndText$77739[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	SHORT $L77737
$L77738:

; 831  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aLinkText$77734[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aLinks$77733[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
$L77732:

; 833  : 		cb.Close();

	lea	ecx, DWORD PTR _cb$[ebp]
	call	?Close@CClipboard@@QAEHXZ		; CClipboard::Close

; 834  : 
; 835  : 		// do the paste else fallback on default processing
; 836  : 		if (!sClipText.IsEmpty())

	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	SHORT $L77741

; 838  : 			ReplaceSel(sClipText, TRUE);

	push	1
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReplaceSel@CRichEditCtrl@@QAEXPBGH@Z	; CRichEditCtrl::ReplaceSel

; 840  : 		else 

	jmp	SHORT $L77742
$L77741:

; 842  : 			CRichEditBaseCtrl::Paste();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Paste@CRichEditCtrl@@QAEXXZ		; CRichEditCtrl::Paste
$L77742:

; 844  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77710:

; 845  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cb$[ebp]
	call	??1CClipboard@@QAE@XZ			; CClipboard::~CClipboard
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80043:
	lea	ecx, DWORD PTR _sClipText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80044:
	lea	ecx, DWORD PTR _cb$[ebp]
	call	??1CClipboard@@QAE@XZ			; CClipboard::~CClipboard
	ret	0
$L80045:
	lea	ecx, DWORD PTR _sClipURL$77711[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80046:
	lea	ecx, DWORD PTR _sTemp$77719[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80047:
	lea	ecx, DWORD PTR _aLinks$77733[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	ret	0
$L80048:
	lea	ecx, DWORD PTR _aLinkText$77734[ebp]
	call	??1CStringArray@@UAE@XZ			; CStringArray::~CStringArray
	ret	0
$L80049:
	lea	ecx, DWORD PTR _sLinkAndText$77739[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80052:
	mov	eax, OFFSET FLAT:$T80051
	jmp	___CxxFrameHandler
text$x	ENDS
?Paste@CUrlRichEditCtrl@@QAEXXZ ENDP			; CUrlRichEditCtrl::Paste
EXTRN	?SetSel@CRichEditCtrl@@QAEXJJ@Z:NEAR		; CRichEditCtrl::SetSel
EXTRN	?GetTextLength@CRichEditCtrl@@QBEJXZ:NEAR	; CRichEditCtrl::GetTextLength
EXTRN	__imp__isspace:NEAR
EXTRN	?GetSelText@CRichEditBaseCtrl@@QAE?AVCString@@XZ:NEAR ; CRichEditBaseCtrl::GetSelText
EXTRN	??ACString@@QBEGH@Z:NEAR			; CString::operator[]
EXTRN	?TrimLeft@CString@@QAEXXZ:NEAR			; CString::TrimLeft
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T80066	DD	019930520H
	DD	04H
	DD	FLAT:$T80068
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80068	DD	0ffffffffH
	DD	FLAT:$L80061
	DD	00H
	DD	FLAT:$L80062
	DD	00H
	DD	FLAT:$L80063
	DD	02H
	DD	FLAT:$L80064
xdata$x	ENDS
;	COMDAT ?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z
_TEXT	SEGMENT
$T80059 = -40
$T80060 = -44
__$EHRec$ = -12
_lpszPath$ = 8
_bFile$ = 12
_this$ = -48
_sPath$ = -24
_crSel$ = -36
_crSelOrg$ = -20
_sSelText$ = -28
?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z PROC NEAR	; CUrlRichEditCtrl::PathReplaceSel, COMDAT

; 848  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80067
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 849  : 	CString sPath(lpszPath);

	mov	eax, DWORD PTR _lpszPath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 850  : 	sPath.TrimLeft();

	lea	ecx, DWORD PTR _sPath$[ebp]
	call	?TrimLeft@CString@@QAEXXZ		; CString::TrimLeft

; 851  : 
; 852  : 	if (bFile || FileMisc::IsPath(lpszPath))

	cmp	DWORD PTR _bFile$[ebp], 0
	jne	SHORT $L77750
	mov	ecx, DWORD PTR _lpszPath$[ebp]
	push	ecx
	call	?IsPath@FileMisc@@YAHPBG@Z		; FileMisc::IsPath
	add	esp, 4
	test	eax, eax
	je	SHORT $L77749
$L77750:

; 853  : 		sPath = CreateFileLink(lpszPath);

	mov	edx, DWORD PTR _lpszPath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T80059[ebp]
	push	eax
	call	?CreateFileLink@CUrlRichEditCtrl@@KA?AVCString@@PBG@Z ; CUrlRichEditCtrl::CreateFileLink
	add	esp, 8
	mov	DWORD PTR -52+[ebp], eax
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR -56+[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR -56+[ebp]
	push	edx
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T80059[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77749:

; 857  : 	GetSel(crSelOrg); // save this off

	lea	eax, DWORD PTR _crSelOrg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 858  : 	GetSel(crSel);

	lea	ecx, DWORD PTR _crSel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 859  : 	
; 860  : 	// enlarge to include end items
; 861  : 	if (crSel.cpMin > 0)

	cmp	DWORD PTR _crSel$[ebp], 0
	jle	SHORT $L77754

; 862  : 		crSel.cpMin--;

	mov	edx, DWORD PTR _crSel$[ebp]
	sub	edx, 1
	mov	DWORD PTR _crSel$[ebp], edx
$L77754:

; 863  : 	
; 864  : 	if (crSel.cpMax < GetTextLength() - 1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTextLength@CRichEditCtrl@@QBEJXZ	; CRichEditCtrl::GetTextLength
	sub	eax, 1
	cmp	DWORD PTR _crSel$[ebp+4], eax
	jge	SHORT $L77755

; 865  : 		crSel.cpMax++;

	mov	eax, DWORD PTR _crSel$[ebp+4]
	add	eax, 1
	mov	DWORD PTR _crSel$[ebp+4], eax
$L77755:

; 866  : 	
; 867  : 	SetSel(crSel);

	lea	ecx, DWORD PTR _crSel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 868  : 	CString sSelText = GetSelText();

	lea	edx, DWORD PTR _sSelText$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSelText@CRichEditBaseCtrl@@QAE?AVCString@@XZ ; CRichEditBaseCtrl::GetSelText
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 869  : 	SetSel(crSelOrg);

	lea	eax, DWORD PTR _crSelOrg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXAAU_charrange@@@Z ; CRichEditCtrl::SetSel

; 870  : 	
; 871  : 	// test
; 872  : 	if (!sSelText.IsEmpty())

	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	jne	$L77761

; 874  : 		if (!isspace(sSelText[0]))

	push	0
	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	??ACString@@QBEGH@Z			; CString::operator[]
	and	eax, 65535				; 0000ffffH
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	cmp	esi, esp
	call	__chkesp
	test	eax, eax
	jne	SHORT $L77759

; 875  : 			sPath = ' ' + sPath;

	lea	ecx, DWORD PTR _sPath$[ebp]
	push	ecx
	push	32					; 00000020H
	lea	edx, DWORD PTR $T80060[ebp]
	push	edx
	call	??H@YG?AVCString@@DABV0@@Z		; operator+
	mov	DWORD PTR -60+[ebp], eax
	mov	eax, DWORD PTR -60+[ebp]
	mov	DWORD PTR -64+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR -64+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T80060[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77759:

; 876  : 		
; 877  : 		if (!isspace(sSelText[sSelText.GetLength() - 1]))

	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	??ACString@@QBEGH@Z			; CString::operator[]
	and	eax, 65535				; 0000ffffH
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	cmp	esi, esp
	call	__chkesp
	test	eax, eax
	jne	SHORT $L77761

; 878  : 			sPath += ' ';

	push	32					; 00000020H
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??YCString@@QAEABV0@D@Z			; CString::operator+=
$L77761:

; 880  : 	
; 881  : 	ReplaceSel(sPath, TRUE);

	push	1
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReplaceSel@CRichEditCtrl@@QAEXPBGH@Z	; CRichEditCtrl::ReplaceSel

; 882  : 	ParseAndFormatText();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ; CUrlRichEditCtrl::ParseAndFormatText

; 883  : 	
; 884  : 	// set the new selection to be the dropped text
; 885  : 	SetSel(crSelOrg.cpMin, crSelOrg.cpMin + sPath.GetLength());

	lea	ecx, DWORD PTR _sPath$[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	mov	edx, DWORD PTR _crSelOrg$[ebp]
	add	edx, eax
	push	edx
	mov	eax, DWORD PTR _crSelOrg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXJJ@Z		; CRichEditCtrl::SetSel

; 886  : 	SetFocus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFocus@CWnd@@QAEPAV1@XZ		; CWnd::SetFocus

; 887  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80061:
	lea	ecx, DWORD PTR _sPath$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80062:
	lea	ecx, DWORD PTR $T80059[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80063:
	lea	ecx, DWORD PTR _sSelText$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80064:
	lea	ecx, DWORD PTR $T80060[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80067:
	mov	eax, OFFSET FLAT:$T80066
	jmp	___CxxFrameHandler
text$x	ENDS
?PathReplaceSel@CUrlRichEditCtrl@@QAEXPBGH@Z ENDP	; CUrlRichEditCtrl::PathReplaceSel
PUBLIC	?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z	; CUrlRichEditCtrl::FindUrl
EXTRN	?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z:NEAR	; CWnd::OnLButtonUp
EXTRN	?KeyIsPressed@Misc@@YAHK@Z:NEAR			; Misc::KeyIsPressed
;	COMDAT ?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_nHitTest$ = 8
_point$ = 12
_this$ = -8
_bShift$ = -4
?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z PROC NEAR ; CUrlRichEditCtrl::OnLButtonUp, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 891  : 	CRichEditBaseCtrl::OnLButtonUp(nHitTest, point);

	mov	eax, DWORD PTR _point$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nHitTest$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnLButtonUp@CWnd@@IAEXIVCPoint@@@Z	; CWnd::OnLButtonUp

; 892  : 
; 893  : 	BOOL bShift = Misc::KeyIsPressed(VK_SHIFT);

	push	16					; 00000010H
	call	?KeyIsPressed@Misc@@YAHK@Z		; Misc::KeyIsPressed
	add	esp, 4
	mov	DWORD PTR _bShift$[ebp], eax

; 894  : 
; 895  : 	if (bShift || FindUrl(point) != m_nContextUrl)

	cmp	DWORD PTR _bShift$[ebp], 0
	jne	SHORT $L77769
	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z ; CUrlRichEditCtrl::FindUrl
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+224]
	je	SHORT $L77768
$L77769:

; 896  : 		m_nContextUrl = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], -1
$L77768:

; 897  : 	
; 898  : 	if (GoToUrl(m_nContextUrl))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GoToUrl@CUrlRichEditCtrl@@QBEHH@Z	; CUrlRichEditCtrl::GoToUrl
	test	eax, eax
	je	SHORT $L77770

; 900  : 		m_nContextUrl = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], -1
$L77770:

; 902  : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnLButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z ENDP	; CUrlRichEditCtrl::OnLButtonUp
_TEXT	ENDS
EXTRN	?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z:NEAR	; CWnd::ClientToScreen
EXTRN	?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z:NEAR	; CWnd::OnRButtonUp
;	COMDAT ?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_nHitTest$ = 8
_point$ = 12
_this$ = -4
?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z PROC NEAR ; CUrlRichEditCtrl::OnRButtonUp, COMDAT

; 905  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 906  : 	m_ptContextMenu = point;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _point$[ebp]
	mov	DWORD PTR [eax+216], ecx
	mov	edx, DWORD PTR _point$[ebp+4]
	mov	DWORD PTR [eax+220], edx

; 907  : 	ClientToScreen(&m_ptContextMenu);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 216				; 000000d8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ClientToScreen

; 908  : 	
; 909  : 	CRichEditBaseCtrl::OnRButtonUp(nHitTest, point);

	mov	ecx, DWORD PTR _point$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _nHitTest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnRButtonUp@CWnd@@IAEXIVCPoint@@@Z	; CWnd::OnRButtonUp

; 910  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnRButtonUp@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z ENDP	; CUrlRichEditCtrl::OnRButtonUp
_TEXT	ENDS
EXTRN	?GetCaretPos@CRichEditBaseCtrl@@QBE?AVCPoint@@XZ:NEAR ; CRichEditBaseCtrl::GetCaretPos
EXTRN	?OnKeyUp@CWnd@@IAEXIII@Z:NEAR			; CWnd::OnKeyUp
;	COMDAT ?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z
_TEXT	SEGMENT
$T80077 = -8
_nChar$ = 8
_nRepCnt$ = 12
_nFlags$ = 16
_this$ = -12
?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z PROC NEAR		; CUrlRichEditCtrl::OnKeyUp, COMDAT

; 913  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 	if (nChar == VK_APPS)

	cmp	DWORD PTR _nChar$[ebp], 93		; 0000005dH
	jne	SHORT $L77782

; 916  : 		m_ptContextMenu = GetCaretPos();

	lea	eax, DWORD PTR $T80077[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCaretPos@CRichEditBaseCtrl@@QBE?AVCPoint@@XZ ; CRichEditBaseCtrl::GetCaretPos
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+216], ecx
	mov	DWORD PTR [eax+220], edx

; 917  : 		
; 918  : 		// does this location lie on a url?
; 919  : 		m_nContextUrl = FindUrl(m_ptContextMenu);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z ; CUrlRichEditCtrl::FindUrl
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], eax

; 920  : 		
; 921  : 		// convert point to screen coords
; 922  : 		ClientToScreen(&m_ptContextMenu);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 216				; 000000d8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ClientToScreen
$L77782:

; 924  : 	
; 925  : 	CRichEditBaseCtrl::OnKeyUp(nChar, nRepCnt, nFlags);

	mov	ecx, DWORD PTR _nFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nRepCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _nChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnKeyUp@CWnd@@IAEXIII@Z		; CWnd::OnKeyUp

; 926  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnKeyUp@CUrlRichEditCtrl@@IAEXIII@Z ENDP		; CUrlRichEditCtrl::OnKeyUp
_TEXT	ENDS
EXTRN	__imp__GetKeyState@4:NEAR
EXTRN	?OnSysKeyDown@CWnd@@IAEXIII@Z:NEAR		; CWnd::OnSysKeyDown
;	COMDAT ?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z
_TEXT	SEGMENT
$T80080 = -8
_nChar$ = 8
_nRepCnt$ = 12
_nFlags$ = 16
_this$ = -12
?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z PROC NEAR	; CUrlRichEditCtrl::OnSysKeyDown, COMDAT

; 929  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 930  :    if (nChar == VK_F10 && GetKeyState(VK_SHIFT))

	cmp	DWORD PTR _nChar$[ebp], 121		; 00000079H
	jne	SHORT $L77790
	mov	esi, esp
	push	16					; 00000010H
	call	DWORD PTR __imp__GetKeyState@4
	cmp	esi, esp
	call	__chkesp
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L77790

; 932  : 		m_ptContextMenu = GetCaretPos();

	lea	ecx, DWORD PTR $T80080[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCaretPos@CRichEditBaseCtrl@@QBE?AVCPoint@@XZ ; CRichEditBaseCtrl::GetCaretPos
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], edx
	mov	DWORD PTR [ecx+220], eax

; 933  : 
; 934  : 		// does this location lie on a url?
; 935  : 		m_nContextUrl = FindUrl(m_ptContextMenu);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z ; CUrlRichEditCtrl::FindUrl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+224], eax

; 936  : 		
; 937  : 		// convert point to screen coords
; 938  : 		ClientToScreen(&m_ptContextMenu);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClientToScreen@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ClientToScreen
$L77790:

; 942  : 	
; 943  : 	CRichEditBaseCtrl::OnSysKeyDown(nChar, nRepCnt, nFlags);

	mov	eax, DWORD PTR _nFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nRepCnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nChar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnSysKeyDown@CWnd@@IAEXIII@Z		; CWnd::OnSysKeyDown

; 944  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnSysKeyDown@CUrlRichEditCtrl@@IAEXIII@Z ENDP		; CUrlRichEditCtrl::OnSysKeyDown
_TEXT	ENDS
EXTRN	?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z:NEAR	; CWnd::OnRButtonDown
;	COMDAT ?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z
_TEXT	SEGMENT
_nFlags$ = 8
_point$ = 12
_this$ = -16
_nChar$ = -4
_crSel$77799 = -12
?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z PROC NEAR ; CUrlRichEditCtrl::OnRButtonDown, COMDAT

; 947  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 948  : 	m_nContextUrl = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+224], -1

; 949  : 	
; 950  : 	// move the caret to the pos clicked
; 951  : 	int nChar = CharFromPoint(point);

	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CharFromPoint@CRichEditBaseCtrl@@QBEHABVCPoint@@@Z ; CRichEditBaseCtrl::CharFromPoint
	mov	DWORD PTR _nChar$[ebp], eax

; 952  : 	
; 953  : 	if (nChar >= 0)

	cmp	DWORD PTR _nChar$[ebp], 0
	jl	SHORT $L77800

; 955  : 		// don't reset the selection if the character
; 956  : 		// falls within the current selection
; 957  : 		CHARRANGE crSel;
; 958  : 		GetSel(crSel);

	lea	edx, DWORD PTR _crSel$77799[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 959  : 		
; 960  : 		if (nChar < crSel.cpMin || nChar > crSel.cpMax)

	mov	eax, DWORD PTR _nChar$[ebp]
	cmp	eax, DWORD PTR _crSel$77799[ebp]
	jl	SHORT $L77801
	mov	ecx, DWORD PTR _nChar$[ebp]
	cmp	ecx, DWORD PTR _crSel$77799[ebp+4]
	jle	SHORT $L77800
$L77801:

; 961  : 			SetSel(nChar, nChar);

	mov	edx, DWORD PTR _nChar$[ebp]
	push	edx
	mov	eax, DWORD PTR _nChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSel@CRichEditCtrl@@QAEXJJ@Z		; CRichEditCtrl::SetSel
$L77800:

; 963  : 	
; 964  : 	CRichEditBaseCtrl::OnRButtonDown(nFlags, point);

	mov	ecx, DWORD PTR _point$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _nFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnRButtonDown@CWnd@@IAEXIVCPoint@@@Z	; CWnd::OnRButtonDown

; 965  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnRButtonDown@CUrlRichEditCtrl@@IAEXIVCPoint@@@Z ENDP	; CUrlRichEditCtrl::OnRButtonDown
_TEXT	ENDS
EXTRN	?OnShowWindow@CWnd@@IAEXHI@Z:NEAR		; CWnd::OnShowWindow
;	COMDAT ?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z
_TEXT	SEGMENT
_bShow$ = 8
_nStatus$ = 12
_this$ = -4
?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z PROC NEAR	; CUrlRichEditCtrl::OnShowWindow, COMDAT

; 968  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 969  : 	CRichEditBaseCtrl::OnShowWindow(bShow, nStatus);

	mov	eax, DWORD PTR _nStatus$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bShow$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnShowWindow@CWnd@@IAEXHI@Z		; CWnd::OnShowWindow

; 970  : 	
; 971  : 	// TODO: Add your message handler code here
; 972  : 	
; 973  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?OnShowWindow@CUrlRichEditCtrl@@IAEXHI@Z ENDP		; CUrlRichEditCtrl::OnShowWindow
_TEXT	ENDS
EXTRN	?OnCreate@CRichEditBaseCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z:NEAR ; CRichEditBaseCtrl::OnCreate
;	COMDAT ?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z
_TEXT	SEGMENT
_lpCreateStruct$ = 8
_this$ = -4
?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z PROC NEAR ; CUrlRichEditCtrl::OnCreate, COMDAT

; 976  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 977  : 	if (CRichEditBaseCtrl::OnCreate(lpCreateStruct) == -1)

	mov	eax, DWORD PTR _lpCreateStruct$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnCreate@CRichEditBaseCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z ; CRichEditBaseCtrl::OnCreate
	cmp	eax, -1
	jne	SHORT $L77811

; 978  : 		return -1;

	or	eax, -1
	jmp	SHORT $L77810
$L77811:

; 979  : 	
; 980  : 	SetEventMask(GetEventMask() | ENM_CHANGE | ENM_DROPFILES | ENM_DRAGDROPDONE | ENM_LINK);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEventMask@CRichEditCtrl@@QBEJXZ	; CRichEditCtrl::GetEventMask
	or	al, 1
	or	eax, 1048576				; 00100000H
	or	al, 16					; 00000010H
	or	eax, 67108864				; 04000000H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEventMask@CRichEditCtrl@@QAEKK@Z	; CRichEditCtrl::SetEventMask

; 981  : 	DragAcceptFiles();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DragAcceptFiles@CWnd@@QAEXH@Z		; CWnd::DragAcceptFiles

; 982  : 	
; 983  : 	// enable multilevel undo
; 984  : 	SendMessage(EM_SETTEXTMODE, TM_MULTILEVELUNDO);

	push	0
	push	8
	push	1113					; 00000459H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 985  : 
; 986  : 	m_ncBorder.Initialize(GetSafeHwnd());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ	; CWnd::GetSafeHwnd
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?Initialize@CRichEditNcBorder@@QAEHPAUHWND__@@@Z ; CRichEditNcBorder::Initialize

; 987  : 
; 988  : 	return 0;

	xor	eax, eax
$L77810:

; 989  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?OnCreate@CUrlRichEditCtrl@@IAEHPAUtagCREATESTRUCTW@@@Z ENDP ; CUrlRichEditCtrl::OnCreate
_TEXT	ENDS
;	COMDAT ?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z
_TEXT	SEGMENT
_point$ = 12
_this$ = -4
?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z PROC NEAR ; CUrlRichEditCtrl::OnContextMenu, COMDAT

; 992  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 993  : 	// if we arrived here then it means that noone had derived
; 994  : 	// from us and handled OnContextMenu. sow e must forward to 
; 995  : 	// our parent else we'll end up in a recursive loop
; 996  : 	GetParent()->SendMessage(WM_CONTEXTMENU, (WPARAM)GetSafeHwnd(), MAKELPARAM(point.x, point.y));

	mov	eax, DWORD PTR _point$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _point$[ebp+4]
	and	ecx, 65535				; 0000ffffH
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ	; CWnd::GetSafeHwnd
	push	eax
	push	123					; 0000007bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParent@CWnd@@QBEPAV1@XZ		; CWnd::GetParent
	mov	ecx, eax
	call	?SendMessageW@CWnd@@QAEJIIJ@Z		; CWnd::SendMessageW

; 997  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnContextMenu@CUrlRichEditCtrl@@IAEXPAVCWnd@@VCPoint@@@Z ENDP ; CUrlRichEditCtrl::OnContextMenu
_TEXT	ENDS
PUBLIC	?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z ; CUrlRichEditCtrl::FindUrl
EXTRN	?GetTextRange@CRichEditBaseCtrl@@QAE?AVCString@@ABU_charrange@@@Z:NEAR ; CRichEditBaseCtrl::GetTextRange
EXTRN	?AfxGetApp@@YGPAVCWinApp@@XZ:NEAR		; AfxGetApp
EXTRN	?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBG@Z:NEAR ; CWinApp::LoadStandardCursor
EXTRN	__imp__SetCursor@4:NEAR
;	COMDAT xdata$x
; File D:\_CODE\Shared\urlricheditctrl.cpp
xdata$x	SEGMENT
$T80095	DD	019930520H
	DD	01H
	DD	FLAT:$T80097
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80097	DD	0ffffffffH
	DD	FLAT:$L80093
xdata$x	ENDS
;	COMDAT ?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z
_TEXT	SEGMENT
_pResult$ = 12
_this$ = -56
_bShift$ = -16
_pENL$ = -20
_crSel$77837 = -44
_ptCursor$77838 = -36
_nCursor$77839 = -28
_nChar$77843 = -24
_sUrl$77854 = -48
$T80091 = -52
__$EHRec$ = -12
_pNMHDR$ = 8
?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z PROC NEAR ; CUrlRichEditCtrl::OnNotifyLink, COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80096
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1001 : 	BOOL bShift = Misc::KeyIsPressed(VK_SHIFT);

	push	16					; 00000010H
	call	?KeyIsPressed@Misc@@YAHK@Z		; Misc::KeyIsPressed
	add	esp, 4
	mov	DWORD PTR _bShift$[ebp], eax

; 1002 : 	ENLINK* pENL = (ENLINK*)pNMHDR;

	mov	eax, DWORD PTR _pNMHDR$[ebp]
	mov	DWORD PTR _pENL$[ebp], eax

; 1005 : 	{

	mov	ecx, DWORD PTR _pENL$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR -60+[ebp], edx
	cmp	DWORD PTR -60+[ebp], 514		; 00000202H
	ja	SHORT $L80092
	cmp	DWORD PTR -60+[ebp], 514		; 00000202H
	je	$L77852
	cmp	DWORD PTR -60+[ebp], 32			; 00000020H
	je	SHORT $L77835
	cmp	DWORD PTR -60+[ebp], 513		; 00000201H
	je	$L77849
	jmp	$L77832
$L80092:
	cmp	DWORD PTR -60+[ebp], 517		; 00000205H
	je	$L77859
	jmp	$L77832
$L77835:

; 1006 : 	case WM_SETCURSOR:
; 1007 : 		if (bShift)

	cmp	DWORD PTR _bShift$[ebp], 0
	je	$L77836

; 1009 : 			// because we're overriding the default behaviour we need to
; 1010 : 			// handle the cursor being over a selected block
; 1011 : 			CHARRANGE crSel;
; 1012 : 			GetSel(crSel);

	lea	eax, DWORD PTR _crSel$77837[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSel@CRichEditCtrl@@QBEXAAU_charrange@@@Z ; CRichEditCtrl::GetSel

; 1013 : 
; 1014 : 			CPoint ptCursor(GetMessagePos());

	mov	esi, esp
	call	DWORD PTR __imp__GetMessagePos@0
	cmp	esi, esp
	call	__chkesp
	push	eax
	lea	ecx, DWORD PTR _ptCursor$77838[ebp]
	call	??0CPoint@@QAE@K@Z			; CPoint::CPoint

; 1015 : 			ScreenToClient(&ptCursor);

	lea	ecx, DWORD PTR _ptCursor$77838[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScreenToClient@CWnd@@QBEXPAUtagPOINT@@@Z ; CWnd::ScreenToClient

; 1016 : 
; 1017 : 			LPCTSTR nCursor = IDC_ARROW;

	mov	DWORD PTR _nCursor$77839[ebp], 32512	; 00007f00H

; 1018 : 
; 1019 : 			int nChar = CharFromPoint(ptCursor);

	lea	edx, DWORD PTR _ptCursor$77838[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CharFromPoint@CRichEditBaseCtrl@@QBEHABVCPoint@@@Z ; CRichEditBaseCtrl::CharFromPoint
	mov	DWORD PTR _nChar$77843[ebp], eax

; 1020 : 				
; 1021 : 			if (nChar < crSel.cpMin || nChar > crSel.cpMax)

	mov	eax, DWORD PTR _nChar$77843[ebp]
	cmp	eax, DWORD PTR _crSel$77837[ebp]
	jl	SHORT $L77845
	mov	ecx, DWORD PTR _nChar$77843[ebp]
	cmp	ecx, DWORD PTR _crSel$77837[ebp+4]
	jle	SHORT $L77844
$L77845:

; 1022 : 				nCursor = IDC_IBEAM;

	mov	DWORD PTR _nCursor$77839[ebp], 32513	; 00007f01H
$L77844:

; 1023 : 
; 1024 : 			SetCursor(AfxGetApp()->LoadStandardCursor(nCursor));

	mov	edx, DWORD PTR _nCursor$77839[ebp]
	push	edx
	call	?AfxGetApp@@YGPAVCWinApp@@XZ		; AfxGetApp
	mov	ecx, eax
	call	?LoadStandardCursor@CWinApp@@QBEPAUHICON__@@PBG@Z ; CWinApp::LoadStandardCursor
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SetCursor@4
	cmp	esi, esp
	call	__chkesp

; 1025 : 
; 1026 : 			*pResult = TRUE;

	mov	eax, DWORD PTR _pResult$[ebp]
	mov	DWORD PTR [eax], 1

; 1027 : 			return TRUE;

	mov	eax, 1
	jmp	$L77827
$L77836:

; 1029 : 		break;

	jmp	$L77832
$L77849:

; 1030 : 
; 1031 : 	case WM_LBUTTONDOWN:
; 1032 : 		if (!bShift)

	cmp	DWORD PTR _bShift$[ebp], 0
	jne	SHORT $L77851

; 1034 : 			m_nContextUrl = FindUrl(pENL->chrg);

	mov	ecx, DWORD PTR _pENL$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z ; CUrlRichEditCtrl::FindUrl
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], eax
$L77851:

; 1042 : 		break;

	jmp	$L77832
$L77852:

; 1043 : 
; 1044 : 	case WM_LBUTTONUP:
; 1045 : 		// handle tasklinks in OnLButtonUp
; 1046 : 		if (m_nContextUrl == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+224], -1
	jne	SHORT $L77853

; 1048 : 			CString sUrl = GetTextRange(pENL->chrg);

	mov	edx, DWORD PTR _pENL$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	lea	eax, DWORD PTR _sUrl$77854[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTextRange@CRichEditBaseCtrl@@QAE?AVCString@@ABU_charrange@@@Z ; CRichEditBaseCtrl::GetTextRange
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1049 : 			
; 1050 : 			if (sUrl.IsEmpty())

	lea	ecx, DWORD PTR _sUrl$77854[ebp]
	call	?IsEmpty@CString@@QBEHXZ		; CString::IsEmpty
	test	eax, eax
	je	SHORT $L77857

; 1052 : 				if (FileMisc::Run(*this, sUrl) > 32)

	push	0
	push	0
	push	1
	push	0
	lea	ecx, DWORD PTR _sUrl$77854[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BCWnd@@QBEPAUHWND__@@XZ		; CWnd::operator HWND__ *
	push	eax
	call	?Run@FileMisc@@YAKPAUHWND__@@PBG1H11@Z	; FileMisc::Run
	add	esp, 24					; 00000018H
	cmp	eax, 32					; 00000020H
	jbe	SHORT $L77857

; 1053 : 					return TRUE;

	mov	DWORD PTR $T80091[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sUrl$77854[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T80091[ebp]
	jmp	SHORT $L77827
$L77857:

; 1055 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sUrl$77854[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L77853:

; 1056 : 		break;

	jmp	SHORT $L77832
$L77859:

; 1057 : 
; 1058 : 	case WM_RBUTTONUP:
; 1059 : 		m_nContextUrl = FindUrl(pENL->chrg);

	mov	ecx, DWORD PTR _pENL$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z ; CUrlRichEditCtrl::FindUrl
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], eax
$L77832:

; 1062 : 
; 1063 : 	return FALSE;

	xor	eax, eax
$L77827:

; 1064 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80093:
	lea	ecx, DWORD PTR _sUrl$77854[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80096:
	mov	eax, OFFSET FLAT:$T80095
	jmp	___CxxFrameHandler
text$x	ENDS
?OnNotifyLink@CUrlRichEditCtrl@@IAEHPAUtagNMHDR@@PAJ@Z ENDP ; CUrlRichEditCtrl::OnNotifyLink
;	COMDAT ?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z
_TEXT	SEGMENT
_cr$ = 8
_this$ = -12
_nUrl$ = -4
_urli$77868 = -8
?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z PROC NEAR ; CUrlRichEditCtrl::FindUrl, COMDAT

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 	int nUrl = m_aUrls.GetSize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrl$[ebp], eax
$L77866:

; 1069 : 	
; 1070 : 	while (nUrl--)

	mov	eax, DWORD PTR _nUrl$[ebp]
	mov	ecx, DWORD PTR _nUrl$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nUrl$[ebp], ecx
	test	eax, eax
	je	SHORT $L77867

; 1072 : 		const URLITEM& urli = m_aUrls[nUrl];

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR _urli$77868[ebp], eax

; 1073 : 		
; 1074 : 		if (urli.cr.cpMax == cr.cpMax && urli.cr.cpMin == cr.cpMin)

	mov	eax, DWORD PTR _urli$77868[ebp]
	mov	ecx, DWORD PTR _cr$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $L77869
	mov	eax, DWORD PTR _urli$77868[ebp]
	mov	ecx, DWORD PTR _cr$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $L77869

; 1075 : 			return nUrl;

	mov	eax, DWORD PTR _nUrl$[ebp]
	jmp	SHORT $L77863
$L77869:

; 1076 : 	}

	jmp	SHORT $L77866
$L77867:

; 1077 : 
; 1078 : 	// not found
; 1079 : 	return -1;

	or	eax, -1
$L77863:

; 1080 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindUrl@CUrlRichEditCtrl@@IAEHABU_charrange@@@Z ENDP	; CUrlRichEditCtrl::FindUrl
_TEXT	ENDS
;	COMDAT ?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z
_TEXT	SEGMENT
_point$ = 8
_this$ = -16
_nPos$ = -8
_nUrl$ = -4
_urli$77879 = -12
?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z PROC NEAR	; CUrlRichEditCtrl::FindUrl, COMDAT

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1084 :    int nPos = CharFromPoint(point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CharFromPoint@CRichEditBaseCtrl@@QBEHABVCPoint@@@Z ; CRichEditBaseCtrl::CharFromPoint
	mov	DWORD PTR _nPos$[ebp], eax

; 1085 : 
; 1086 : 	int nUrl = m_aUrls.GetSize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrl$[ebp], eax
$L77877:

; 1087 : 	
; 1088 : 	while (nUrl--)

	mov	ecx, DWORD PTR _nUrl$[ebp]
	mov	edx, DWORD PTR _nUrl$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nUrl$[ebp], edx
	test	ecx, ecx
	je	SHORT $L77878

; 1090 : 		const URLITEM& urli = m_aUrls[nUrl];

	mov	eax, DWORD PTR _nUrl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR _urli$77879[ebp], eax

; 1091 : 		
; 1092 : 		if (urli.cr.cpMax >= nPos && urli.cr.cpMin < nPos)

	mov	ecx, DWORD PTR _urli$77879[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nPos$[ebp]
	jl	SHORT $L77880
	mov	eax, DWORD PTR _urli$77879[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _nPos$[ebp]
	jge	SHORT $L77880

; 1093 : 			return nUrl;

	mov	eax, DWORD PTR _nUrl$[ebp]
	jmp	SHORT $L77873
$L77880:

; 1094 : 	}

	jmp	SHORT $L77877
$L77878:

; 1095 : 
; 1096 : 	// not found
; 1097 : 	return -1;

	or	eax, -1
$L77873:

; 1098 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindUrl@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z ENDP	; CUrlRichEditCtrl::FindUrl
_TEXT	ENDS
PUBLIC	?FindUrlEx@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z	; CUrlRichEditCtrl::FindUrlEx
EXTRN	?GetCharPos@CRichEditCtrl@@QBE?AVCPoint@@J@Z:NEAR ; CRichEditCtrl::GetCharPos
EXTRN	?GetLineHeight@CRichEditBaseCtrl@@QBEHXZ:NEAR	; CRichEditBaseCtrl::GetLineHeight
EXTRN	??0CRect@@QAE@UtagPOINT@@0@Z:NEAR		; CRect::CRect
EXTRN	?PtInRect@CRect@@QBEHUtagPOINT@@@Z:NEAR		; CRect::PtInRect
;	COMDAT ?FindUrlEx@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z
_TEXT	SEGMENT
_point$ = 8
_this$ = -68
_nUrl$ = -4
_urli$77889 = -8
_rUrl$77892 = -24
$T80106 = -32
$T80107 = -40
$T80108 = -48
$T80109 = -56
$T80110 = -64
?FindUrlEx@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z PROC NEAR ; CUrlRichEditCtrl::FindUrlEx, COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1102 : 	int nUrl = m_aUrls.GetSize();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ; CArray<URLITEM,URLITEM &>::GetSize
	mov	DWORD PTR _nUrl$[ebp], eax
$L77887:

; 1103 : 	
; 1104 : 	while (nUrl--)

	mov	eax, DWORD PTR _nUrl$[ebp]
	mov	ecx, DWORD PTR _nUrl$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nUrl$[ebp], ecx
	test	eax, eax
	je	$L77888

; 1106 : 		const URLITEM& urli = m_aUrls[nUrl];

	mov	edx, DWORD PTR _nUrl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::operator[]
	mov	DWORD PTR _urli$77889[ebp], eax

; 1107 : 
; 1108 : 		CRect rUrl(GetCharPos(urli.cr.cpMin), GetCharPos(urli.cr.cpMax));

	mov	eax, DWORD PTR _urli$77889[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T80107[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCharPos@CRichEditCtrl@@QBE?AVCPoint@@J@Z ; CRichEditCtrl::GetCharPos
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T80106[ebp], ecx
	mov	DWORD PTR $T80106[ebp+4], edx
	mov	eax, DWORD PTR $T80106[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T80106[ebp]
	push	ecx
	mov	edx, DWORD PTR _urli$77889[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T80109[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCharPos@CRichEditCtrl@@QBE?AVCPoint@@J@Z ; CRichEditCtrl::GetCharPos
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T80108[ebp], edx
	mov	DWORD PTR $T80108[ebp+4], eax
	mov	ecx, DWORD PTR $T80108[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T80108[ebp]
	push	edx
	lea	ecx, DWORD PTR _rUrl$77892[ebp]
	call	??0CRect@@QAE@UtagPOINT@@0@Z		; CRect::CRect

; 1109 : 
; 1110 : 		rUrl.bottom += GetLineHeight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLineHeight@CRichEditBaseCtrl@@QBEHXZ ; CRichEditBaseCtrl::GetLineHeight
	mov	ecx, DWORD PTR _rUrl$77892[ebp+12]
	add	ecx, eax
	mov	DWORD PTR _rUrl$77892[ebp+12], ecx

; 1111 : 		
; 1112 : 		if (rUrl.PtInRect(point))

	mov	edx, DWORD PTR _point$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T80110[ebp], eax
	mov	DWORD PTR $T80110[ebp+4], ecx
	mov	edx, DWORD PTR $T80110[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T80110[ebp]
	push	eax
	lea	ecx, DWORD PTR _rUrl$77892[ebp]
	call	?PtInRect@CRect@@QBEHUtagPOINT@@@Z	; CRect::PtInRect
	test	eax, eax
	je	SHORT $L77896

; 1113 : 			return nUrl;

	mov	eax, DWORD PTR _nUrl$[ebp]
	jmp	SHORT $L77884
$L77896:

; 1114 : 	}

	jmp	$L77887
$L77888:

; 1115 : 
; 1116 : 	// not found
; 1117 : 	return -1;

	or	eax, -1
$L77884:

; 1118 : }

	pop	edi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindUrlEx@CUrlRichEditCtrl@@IAEHABVCPoint@@@Z ENDP	; CUrlRichEditCtrl::FindUrlEx
_TEXT	ENDS
EXTRN	?OnTimer@CWnd@@IAEXI@Z:NEAR			; CWnd::OnTimer
;	COMDAT ?OnTimer@CUrlRichEditCtrl@@IAEXI@Z
_TEXT	SEGMENT
_nIDEvent$ = 8
_this$ = -4
?OnTimer@CUrlRichEditCtrl@@IAEXI@Z PROC NEAR		; CUrlRichEditCtrl::OnTimer, COMDAT

; 1121 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1122 : 	// if we've arrived here then it means that the user
; 1123 : 	// has paused for long enough to reparse the latest changes
; 1124 : 	if (nIDEvent == TIMER_REPARSE)

	cmp	DWORD PTR _nIDEvent$[ebp], 1
	jne	SHORT $L77901

; 1125 : 		ParseAndFormatText();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseAndFormatText@CUrlRichEditCtrl@@QAEXH@Z ; CUrlRichEditCtrl::ParseAndFormatText
$L77901:

; 1126 : 	
; 1127 : 	CRichEditBaseCtrl::OnTimer(nIDEvent);

	mov	eax, DWORD PTR _nIDEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnTimer@CWnd@@IAEXI@Z			; CWnd::OnTimer

; 1128 : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?OnTimer@CUrlRichEditCtrl@@IAEXI@Z ENDP			; CUrlRichEditCtrl::OnTimer
_TEXT	ENDS
PUBLIC	?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z ; CXmlCharMap::ConvertFromRep
EXTRN	?GetSize@CStringArray@@QBEHXZ:NEAR		; CStringArray::GetSize
EXTRN	?Add@CStringArray@@QAEHABVCString@@@Z:NEAR	; CStringArray::Add
EXTRN	?Mid@CString@@QBE?AV1@HH@Z:NEAR			; CString::Mid
EXTRN	?Trim@Misc@@YAAAVCString@@AAV2@PBG@Z:NEAR	; Misc::Trim
EXTRN	?Find@CString@@QBEHPBGH@Z:NEAR			; CString::Find
;	COMDAT data
; File D:\_CODE\Shared\urlricheditctrl.cpp
data	SEGMENT
$SG77909 DB	'h', 00H, 'r', 00H, 'e', 00H, 'f', 00H, '=', 00H, '"', 00H
	DB	00H, 00H
	ORG $+2
$SG77911 DB	'"', 00H, 00H, 00H
$SG77913 DB	'>', 00H, 00H, 00H
$SG77915 DB	'<', 00H, '/', 00H, 'a', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG77928 DB	'"', 00H, ' ', 00H, 00H, 00H
data	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80124	DD	019930520H
	DD	07H
	DD	FLAT:$T80126
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80126	DD	0ffffffffH
	DD	FLAT:$L80116
	DD	00H
	DD	FLAT:$L80117
	DD	01H
	DD	FLAT:$L80118
	DD	02H
	DD	FLAT:$L80119
	DD	03H
	DD	FLAT:$L80120
	DD	04H
	DD	FLAT:$L80121
	DD	05H
	DD	FLAT:$L80122
xdata$x	ENDS
;	COMDAT ?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z
_TEXT	SEGMENT
_szHtml$ = 8
_aLinks$ = 12
_aLinkText$ = 16
_sHtml$ = -20
_sLinkStart$ = -16
_sLinkEnd$ = -40
_sTextStart$ = -28
_sTextEnd$ = -32
_nStart$ = -36
_nEnd$ = -24
_sLink$77922 = -44
_sText$77926 = -48
$T80115 = -52
__$EHRec$ = -12
?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z PROC NEAR ; CUrlRichEditCtrl::ExtractLinks, COMDAT

; 1132 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80125
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1133 : 	CString sHtml(szHtml);

	mov	eax, DWORD PTR _szHtml$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1134 : 	const CString sLinkStart(_T("href=\"")), sLinkEnd(_T("\""));

	push	OFFSET FLAT:$SG77909
	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	OFFSET FLAT:$SG77911
	lea	ecx, DWORD PTR _sLinkEnd$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1135 : 	const CString sTextStart(_T(">")), sTextEnd(_T("</a>"));

	push	OFFSET FLAT:$SG77913
	lea	ecx, DWORD PTR _sTextStart$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET FLAT:$SG77915
	lea	ecx, DWORD PTR _sTextEnd$[ebp]
	call	??0CString@@QAE@PBG@Z			; CString::CString
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1136 : 	
; 1137 : 	int nStart = sHtml.Find(sLinkStart), nEnd = -1;

	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Find@CString@@QBEHPBG@Z		; CString::Find
	mov	DWORD PTR _nStart$[ebp], eax
	mov	DWORD PTR _nEnd$[ebp], -1
$L77919:

; 1138 : 	
; 1139 : 	while (nStart != -1)

	cmp	DWORD PTR _nStart$[ebp], -1
	je	$L77920

; 1141 : 		nStart += sLinkStart.GetLength();

	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	mov	ecx, DWORD PTR _nStart$[ebp]
	add	ecx, eax
	mov	DWORD PTR _nStart$[ebp], ecx

; 1142 : 		nEnd = sHtml.Find(sLinkEnd, nStart);

	mov	edx, DWORD PTR _nStart$[ebp]
	push	edx
	lea	ecx, DWORD PTR _sLinkEnd$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Find@CString@@QBEHPBGH@Z		; CString::Find
	mov	DWORD PTR _nEnd$[ebp], eax

; 1143 : 		
; 1144 : 		if (nEnd == -1)

	cmp	DWORD PTR _nEnd$[ebp], -1
	jne	SHORT $L77921

; 1145 : 			break;

	jmp	$L77920
$L77921:

; 1146 : 
; 1147 : 		// else
; 1148 : 		CString sLink = sHtml.Mid(nStart, (nEnd - nStart));

	mov	eax, DWORD PTR _nEnd$[ebp]
	sub	eax, DWORD PTR _nStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sLink$77922[ebp]
	push	edx
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Mid@CString@@QBE?AV1@HH@Z		; CString::Mid
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1149 : 		
; 1150 : 		// get text
; 1151 : 		nStart = sHtml.Find(sTextStart, nEnd + 1);

	mov	eax, DWORD PTR _nEnd$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _sTextStart$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Find@CString@@QBEHPBGH@Z		; CString::Find
	mov	DWORD PTR _nStart$[ebp], eax

; 1152 : 
; 1153 : 		if (nStart == -1)

	cmp	DWORD PTR _nStart$[ebp], -1
	jne	SHORT $L77924

; 1154 : 			break;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _sLink$77922[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L77920
$L77924:

; 1155 : 		
; 1156 : 		nStart += sTextStart.GetLength();

	lea	ecx, DWORD PTR _sTextStart$[ebp]
	call	?GetLength@CString@@QBEHXZ		; CString::GetLength
	mov	ecx, DWORD PTR _nStart$[ebp]
	add	ecx, eax
	mov	DWORD PTR _nStart$[ebp], ecx

; 1157 : 		nEnd = sHtml.Find(sTextEnd, nStart);

	mov	edx, DWORD PTR _nStart$[ebp]
	push	edx
	lea	ecx, DWORD PTR _sTextEnd$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Find@CString@@QBEHPBGH@Z		; CString::Find
	mov	DWORD PTR _nEnd$[ebp], eax

; 1158 : 		
; 1159 : 		if (nEnd == -1)

	cmp	DWORD PTR _nEnd$[ebp], -1
	jne	SHORT $L77925

; 1160 : 			break;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _sLink$77922[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L77920
$L77925:

; 1161 : 		
; 1162 : 		CString sText = sHtml.Mid(nStart, (nEnd - nStart));

	mov	eax, DWORD PTR _nEnd$[ebp]
	sub	eax, DWORD PTR _nStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sText$77926[ebp]
	push	edx
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Mid@CString@@QBE?AV1@HH@Z		; CString::Mid
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1163 : 		
; 1164 : 		// cleanup
; 1165 : 		Misc::Trim(sText, _T("\" "));

	push	OFFSET FLAT:$SG77928
	lea	eax, DWORD PTR _sText$77926[ebp]
	push	eax
	call	?Trim@Misc@@YAAAVCString@@AAV2@PBG@Z	; Misc::Trim
	add	esp, 8

; 1166 : 		
; 1167 : 		// translate HTML represenations
; 1168 : 		CXmlCharMap::ConvertFromRep(sText);

	lea	ecx, DWORD PTR _sText$77926[ebp]
	push	ecx
	call	?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z ; CXmlCharMap::ConvertFromRep
	add	esp, 4

; 1169 : 		
; 1170 : 		// save off
; 1171 : 		aLinks.Add(sLink);

	lea	edx, DWORD PTR _sLink$77922[ebp]
	push	edx
	mov	ecx, DWORD PTR _aLinks$[ebp]
	call	?Add@CStringArray@@QAEHABVCString@@@Z	; CStringArray::Add

; 1172 : 		aLinkText.Add(sText);

	lea	eax, DWORD PTR _sText$77926[ebp]
	push	eax
	mov	ecx, DWORD PTR _aLinkText$[ebp]
	call	?Add@CStringArray@@QAEHABVCString@@@Z	; CStringArray::Add

; 1173 : 		
; 1174 : 		// next link
; 1175 : 		nStart = sHtml.Find(sLinkStart, nEnd);

	mov	ecx, DWORD PTR _nEnd$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	?Find@CString@@QBEHPBGH@Z		; CString::Find
	mov	DWORD PTR _nStart$[ebp], eax

; 1176 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _sText$77926[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _sLink$77922[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	$L77919
$L77920:

; 1177 : 	
; 1178 : 	ASSERT(aLinkText.GetSize() == aLinks.GetSize());

	mov	ecx, DWORD PTR _aLinkText$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize
	mov	esi, eax
	mov	ecx, DWORD PTR _aLinks$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize
	cmp	esi, eax
	je	SHORT $L77932
	push	1178					; 0000049aH
	push	OFFSET FLAT:_THIS_FILE
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L77932
	int	3
$L77932:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L77920

; 1179 : 	
; 1180 : 	return aLinks.GetSize();

	mov	ecx, DWORD PTR _aLinks$[ebp]
	call	?GetSize@CStringArray@@QBEHXZ		; CStringArray::GetSize
	mov	DWORD PTR $T80115[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _sTextEnd$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _sTextStart$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sLinkEnd$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T80115[ebp]

; 1181 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80116:
	lea	ecx, DWORD PTR _sHtml$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80117:
	lea	ecx, DWORD PTR _sLinkStart$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80118:
	lea	ecx, DWORD PTR _sLinkEnd$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80119:
	lea	ecx, DWORD PTR _sTextStart$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80120:
	lea	ecx, DWORD PTR _sTextEnd$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80121:
	lea	ecx, DWORD PTR _sLink$77922[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80122:
	lea	ecx, DWORD PTR _sText$77926[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80125:
	mov	eax, OFFSET FLAT:$T80124
	jmp	___CxxFrameHandler
text$x	ENDS
?ExtractLinks@CUrlRichEditCtrl@@KAHPBGAAVCStringArray@@1@Z ENDP ; CUrlRichEditCtrl::ExtractLinks
PUBLIC	?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z	; CXmlCharMap::Translate
EXTRN	?Left@CString@@QBE?AV1@H@Z:NEAR			; CString::Left
EXTRN	?Find@CString@@QBEHGH@Z:NEAR			; CString::Find
;	COMDAT xdata$x
; File D:\_CODE\Shared\xmlcharmap.h
xdata$x	SEGMENT
$T80140	DD	019930520H
	DD	04H
	DD	FLAT:$T80142
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80142	DD	0ffffffffH
	DD	FLAT:$L80135
	DD	00H
	DD	FLAT:$L80136
	DD	00H
	DD	FLAT:$L80137
	DD	02H
	DD	FLAT:$L80138
xdata$x	ENDS
;	COMDAT ?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z
_TEXT	SEGMENT
$T80132 = -32
$T80133 = -36
$T80134 = -40
__$EHRec$ = -12
_sText$ = 8
_sResult$ = -20
_nStart$ = -16
_nEnd$76152 = -24
_sRep$76155 = -28
?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z PROC NEAR ; CXmlCharMap::ConvertFromRep, COMDAT

; 41   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80141
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 42   : 		CString sResult;

	lea	ecx, DWORD PTR _sResult$[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 43   : 
; 44   : 		// look for '&...;' pairs
; 45   : 		int nStart = sText.Find('&', 0);

	push	0
	push	38					; 00000026H
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Find@CString@@QBEHGH@Z			; CString::Find
	mov	DWORD PTR _nStart$[ebp], eax
$L76150:

; 46   : 
; 47   : 		while (nStart != -1)

	cmp	DWORD PTR _nStart$[ebp], -1
	je	$L76151

; 49   : 			int nEnd = sText.Find(';', nStart);

	mov	eax, DWORD PTR _nStart$[ebp]
	push	eax
	push	59					; 0000003bH
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Find@CString@@QBEHGH@Z			; CString::Find
	mov	DWORD PTR _nEnd$76152[ebp], eax

; 50   : 
; 51   : 			if (nEnd != -1)

	cmp	DWORD PTR _nEnd$76152[ebp], -1
	je	$L76153

; 53   : 				sResult += sText.Left(nStart);

	mov	ecx, DWORD PTR _nStart$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T80132[ebp]
	push	edx
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Left@CString@@QBE?AV1@H@Z		; CString::Left
	mov	DWORD PTR -44+[ebp], eax
	mov	eax, DWORD PTR -44+[ebp]
	mov	DWORD PTR -48+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -48+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sResult$[ebp]
	call	??YCString@@QAEABV0@ABV0@@Z		; CString::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T80132[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 54   : 
; 55   : 				CString sRep = sText.Mid(nStart, nEnd - nStart + 1);

	mov	edx, DWORD PTR _nEnd$76152[ebp]
	sub	edx, DWORD PTR _nStart$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _nStart$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sRep$76155[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Mid@CString@@QBE?AV1@HH@Z		; CString::Mid
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 56   : 				Translate(sRep, &sResult);

	lea	edx, DWORD PTR _sResult$[ebp]
	push	edx
	lea	ecx, DWORD PTR _sRep$76155[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	call	?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z ; CXmlCharMap::Translate
	add	esp, 8

; 57   : 
; 58   : 				sText = sText.Mid(nEnd + 1);

	mov	eax, DWORD PTR _nEnd$76152[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T80133[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Mid@CString@@QBE?AV1@H@Z		; CString::Mid
	mov	DWORD PTR -52+[ebp], eax
	mov	edx, DWORD PTR -52+[ebp]
	mov	DWORD PTR -56+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR -56+[ebp]
	push	eax
	mov	ecx, DWORD PTR _sText$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T80133[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString

; 59   : 				nStart = sText.Find('&', 0);

	push	0
	push	38					; 00000026H
	mov	ecx, DWORD PTR _sText$[ebp]
	call	?Find@CString@@QBEHGH@Z			; CString::Find
	mov	DWORD PTR _nStart$[ebp], eax

; 60   : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sRep$76155[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L76153:

; 61   : 		}

	jmp	$L76150
$L76151:

; 62   : 
; 63   : 		// add whatevers left
; 64   : 		sResult += sText;

	mov	ecx, DWORD PTR _sText$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sResult$[ebp]
	call	??YCString@@QAEABV0@ABV0@@Z		; CString::operator+=

; 65   : 
; 66   : 		sText = sResult;

	lea	edx, DWORD PTR _sResult$[ebp]
	push	edx
	mov	ecx, DWORD PTR _sText$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=

; 67   : 		return sText;

	mov	eax, DWORD PTR _sText$[ebp]
	mov	DWORD PTR $T80134[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sResult$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	mov	eax, DWORD PTR $T80134[ebp]

; 68   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80135:
	lea	ecx, DWORD PTR _sResult$[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80136:
	lea	ecx, DWORD PTR $T80132[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80137:
	lea	ecx, DWORD PTR _sRep$76155[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80138:
	lea	ecx, DWORD PTR $T80133[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80141:
	mov	eax, OFFSET FLAT:$T80140
	jmp	___CxxFrameHandler
text$x	ENDS
?ConvertFromRep@CXmlCharMap@@SAAAVCString@@AAV2@@Z ENDP	; CXmlCharMap::ConvertFromRep
PUBLIC	??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z		; CMap<CString,unsigned short const *,int,int &>::CMap<CString,unsigned short const *,int,int &>
PUBLIC	?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ	; CMap<CString,unsigned short const *,int,int &>::GetCount
PUBLIC	?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z	; CMap<CString,unsigned short const *,int,int &>::Lookup
PUBLIC	?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z	; CMap<CString,unsigned short const *,int,int &>::SetAt
PUBLIC	?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A ; `CXmlCharMap::Translate'::`2'::mapXMLRep
EXTRN	??YCString@@QAEABV0@G@Z:NEAR			; CString::operator+=
EXTRN	??YCString@@QAEABV0@PBG@Z:NEAR			; CString::operator+=
_DATA	SEGMENT
COMM	?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A:BYTE:01cH							; `CXmlCharMap::Translate'::`2'::mapXMLRep
COMM	?$S287@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4EA:BYTE							; `CXmlCharMap::Translate'::`2'::$S287
_DATA	ENDS
;	COMDAT ?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z
_TEXT	SEGMENT
_szXMLRep$ = 8
_pAppendTo$ = 12
_nItem$76253 = -8
_c$ = -4
?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z PROC NEAR	; CXmlCharMap::Translate, COMDAT

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 109  : 		static CMap<CString, LPCTSTR, int, int&> mapXMLRep;

	xor	eax, eax
	mov	al, BYTE PTR ?$S287@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4EA ; `CXmlCharMap::Translate'::`2'::$S287
	and	eax, 1
	test	eax, eax
	jne	SHORT $L76250
	mov	cl, BYTE PTR ?$S287@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4EA ; `CXmlCharMap::Translate'::`2'::$S287
	or	cl, 1
	mov	BYTE PTR ?$S287@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4EA, cl ; `CXmlCharMap::Translate'::`2'::$S287
	push	10					; 0000000aH
	mov	ecx, OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A
	call	??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z	; CMap<CString,unsigned short const *,int,int &>::CMap<CString,unsigned short const *,int,int &>
	push	OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A ; `CXmlCharMap::Translate'::`2'::mapXMLRep
	call	_atexit
	add	esp, 4
$L76250:

; 110  : 
; 111  : 		// init map once only
; 112  : 		if (!mapXMLRep.GetCount())

	mov	ecx, OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A
	call	?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ ; CMap<CString,unsigned short const *,int,int &>::GetCount
	test	eax, eax
	jne	SHORT $L76256

; 114  : 			int nItem = SIZEOFXMLCHARARRAY;

	mov	DWORD PTR _nItem$76253[ebp], 9
$L76255:

; 115  : 
; 116  : 			while (nItem--)

	mov	edx, DWORD PTR _nItem$76253[ebp]
	mov	eax, DWORD PTR _nItem$76253[ebp]
	sub	eax, 1
	mov	DWORD PTR _nItem$76253[ebp], eax
	test	edx, edx
	je	SHORT $L76256

; 117  : 				mapXMLRep.SetAt(XMLCHARARRAY[nItem].szXMLRep, XMLCHARARRAY[nItem].c);

	mov	ecx, DWORD PTR _nItem$76253[ebp]
	lea	edx, DWORD PTR _XMLCHARARRAY[ecx*8]
	push	edx
	mov	eax, DWORD PTR _nItem$76253[ebp]
	mov	ecx, DWORD PTR _XMLCHARARRAY[eax*8+4]
	push	ecx
	mov	ecx, OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A
	call	?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z ; CMap<CString,unsigned short const *,int,int &>::SetAt
	jmp	SHORT $L76255
$L76256:

; 119  : 
; 120  : 		int c = 0;

	mov	DWORD PTR _c$[ebp], 0

; 121  : 
; 122  : 		if (mapXMLRep.Lookup(szXMLRep, c))

	lea	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _szXMLRep$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A
	call	?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z ; CMap<CString,unsigned short const *,int,int &>::Lookup
	test	eax, eax
	je	SHORT $L76258

; 124  : 			if (pAppendTo)

	cmp	DWORD PTR _pAppendTo$[ebp], 0
	je	SHORT $L76259

; 125  : 				(*pAppendTo) += (TCHAR)c;

	mov	cx, WORD PTR _c$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pAppendTo$[ebp]
	call	??YCString@@QAEABV0@G@Z			; CString::operator+=
$L76259:

; 126  : 
; 127  : 			return 1;

	mov	eax, 1
	jmp	SHORT $L76261
$L76258:

; 131  : 			if (pAppendTo)

	cmp	DWORD PTR _pAppendTo$[ebp], 0
	je	SHORT $L76262

; 132  : 				(*pAppendTo) += szXMLRep;

	mov	edx, DWORD PTR _szXMLRep$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAppendTo$[ebp]
	call	??YCString@@QAEABV0@PBG@Z		; CString::operator+=
$L76262:

; 133  : 
; 134  : 			return lstrlen(szXMLRep);

	mov	esi, esp
	mov	eax, DWORD PTR _szXMLRep$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__chkesp
$L76261:

; 136  : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z ENDP	; CXmlCharMap::Translate
_TEXT	ENDS
PUBLIC	??1?$CMap@VCString@@PBGHAAH@@UAE@XZ		; CMap<CString,unsigned short const *,int,int &>::~CMap<CString,unsigned short const *,int,int &>
;	COMDAT ?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A
_TEXT	SEGMENT
?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A PROC NEAR ; `CXmlCharMap::Translate'::`2'::mapXMLRep, COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@4V?$CMap@VCString@@PBGHAAH@@A
	call	??1?$CMap@VCString@@PBGHAAH@@UAE@XZ	; CMap<CString,unsigned short const *,int,int &>::~CMap<CString,unsigned short const *,int,int &>
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	0
?mapXMLRep@?1??Translate@CXmlCharMap@@KAHPBGPAVCString@@@Z@$AV?$CMap@VCString@@PBGHAAH@@A ENDP ; `CXmlCharMap::Translate'::`2'::mapXMLRep
_TEXT	ENDS
PUBLIC	?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z ; CArray<URLITEM,URLITEM &>::Serialize
PUBLIC	?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z ; CArray<URLITEM,URLITEM &>::Dump
PUBLIC	?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ	; CArray<URLITEM,URLITEM &>::AssertValid
PUBLIC	??_7?$CArray@UURLITEM@@AAU1@@@6B@		; CArray<URLITEM,URLITEM &>::`vftable'
PUBLIC	??_G?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z		; CArray<URLITEM,URLITEM &>::`scalar deleting destructor'
PUBLIC	??_E?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z		; CArray<URLITEM,URLITEM &>::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CObject::GetRuntimeClass
EXTRN	??0CObject@@IAE@XZ:NEAR				; CObject::CObject
;	COMDAT ??_7?$CArray@UURLITEM@@AAU1@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
CONST	SEGMENT
??_7?$CArray@UURLITEM@@AAU1@@@6B@ DD FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ ; CArray<URLITEM,URLITEM &>::`vftable'
	DD	FLAT:??_E?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ
	DD	FLAT:?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ PROC NEAR		; CArray<URLITEM,URLITEM &>::CArray<URLITEM,URLITEM &>, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CObject@@IAE@XZ			; CObject::CObject
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UURLITEM@@AAU1@@@6B@ ; CArray<URLITEM,URLITEM &>::`vftable'

; 288  : 	m_pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 289  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 290  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CArray@UURLITEM@@AAU1@@@QAE@XZ ENDP		; CArray<URLITEM,URLITEM &>::CArray<URLITEM,URLITEM &>
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ PROC NEAR	; CArray<URLITEM,URLITEM &>::GetSize, COMDAT

; 245  : 	{ return m_nSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CArray@UURLITEM@@AAU1@@@QBEHXZ ENDP		; CArray<URLITEM,URLITEM &>::GetSize
_TEXT	ENDS
PUBLIC	?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z		; CopyElements
PUBLIC	?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z	; CArray<URLITEM,URLITEM &>::SetSize
EXTRN	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z:NEAR ; AfxAssertValidObject
;	COMDAT ?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z PROC NEAR	; CArray<URLITEM,URLITEM &>::Copy, COMDAT

; 401  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	ASSERT_VALID(this);

	push	402					; 00000192H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78028:

; 403  : 	ASSERT(this != &src);   // cannot append to itself

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR _src$[ebp]
	jne	SHORT $L78031
	push	403					; 00000193H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78031
	int	3
$L78031:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78028

; 404  : 
; 405  : 	SetSize(src.m_nSize);

	push	-1
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z ; CArray<URLITEM,URLITEM &>::SetSize

; 406  : 	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z	; CopyElements

; 407  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$CArray@UURLITEM@@AAU1@@@QAEXABV1@@Z ENDP	; CArray<URLITEM,URLITEM &>::Copy
_TEXT	ENDS
PUBLIC	?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::ElementAt
;	COMDAT ??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::operator[], COMDAT

; 280  : 	{ return ElementAt(nIndex); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::ElementAt
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ENDP	; CArray<URLITEM,URLITEM &>::operator[]
_TEXT	ENDS
PUBLIC	?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::GetAt
;	COMDAT ??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z
_TEXT	SEGMENT
_nIndex$ = 12
___$ReturnUdt$ = 8
_this$ = -8
$T80161 = -4
??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::operator[], COMDAT

; 277  : 	{ return GetAt(nIndex); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T80161[ebp], 0
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ; CArray<URLITEM,URLITEM &>::GetAt
	mov	edx, DWORD PTR $T80161[ebp]
	or	edx, 1
	mov	DWORD PTR $T80161[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
??A?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ENDP	; CArray<URLITEM,URLITEM &>::operator[]
_TEXT	ENDS
PUBLIC	?DestructElements@@YGXPAUURLITEM@@H@Z		; DestructElements
PUBLIC	?ConstructElements@@YGXPAUURLITEM@@H@Z		; ConstructElements
PUBLIC	??4URLITEM@@QAEAAU0@ABU0@@Z			; URLITEM::operator=
EXTRN	__imp__memmove:NEAR
;	COMDAT ?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_newElement$ = 12
_nCount$ = 16
_this$ = -8
_nOldSize$78064 = -4
?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::InsertAt, COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 449  : 	ASSERT_VALID(this);

	push	449					; 000001c1H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78054:

; 450  : 	ASSERT(nIndex >= 0);    // will expand to meet need

	cmp	DWORD PTR _nIndex$[ebp], 0
	jge	SHORT $L78057
	push	450					; 000001c2H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78057
	int	3
$L78057:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78054
$L78056:

; 451  : 	ASSERT(nCount > 0);     // zero or negative size not allowed

	cmp	DWORD PTR _nCount$[ebp], 0
	jg	SHORT $L78061
	push	451					; 000001c3H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78061
	int	3
$L78061:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78056

; 452  : 
; 453  : 	if (nIndex >= m_nSize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L78062

; 455  : 		// adding after the end of the array
; 456  : 		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid

	push	-1
	mov	edx, DWORD PTR _nIndex$[ebp]
	add	edx, DWORD PTR _nCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z ; CArray<URLITEM,URLITEM &>::SetSize

; 458  : 	else

	jmp	$L78063
$L78062:

; 460  : 		// inserting in the middle of the array
; 461  : 		int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOldSize$78064[ebp], ecx

; 462  : 		SetSize(m_nSize + nCount, -1);  // grow it to new size

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _nCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z ; CArray<URLITEM,URLITEM &>::SetSize

; 463  : 		// destroy intial data before copying over it
; 464  : 		DestructElements<TYPE>(&m_pData[nOldSize], nCount);

	mov	ecx, DWORD PTR _nCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nOldSize$78064[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	ecx
	call	?DestructElements@@YGXPAUURLITEM@@H@Z	; DestructElements

; 465  : 		// shift old data up to fill gap
; 466  : 		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
; 467  : 			(nOldSize-nIndex) * sizeof(TYPE));

	mov	edx, DWORD PTR _nOldSize$78064[ebp]
	sub	edx, DWORD PTR _nIndex$[ebp]
	shl	edx, 4
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, eax
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	add	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, eax
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__chkesp

; 468  : 
; 469  : 		// re-init slots we copied from
; 470  : 		ConstructElements<TYPE>(&m_pData[nIndex], nCount);

	mov	eax, DWORD PTR _nCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	push	eax
	call	?ConstructElements@@YGXPAUURLITEM@@H@Z	; ConstructElements
$L78063:

; 472  : 
; 473  : 	// insert new value in the gap
; 474  : 	ASSERT(nIndex + nCount <= m_nSize);

	mov	ecx, DWORD PTR _nIndex$[ebp]
	add	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jle	SHORT $L78079
	push	474					; 000001daH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78079
	int	3
$L78079:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78063
$L78078:

; 475  : 	while (nCount--)

	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L78082

; 476  : 		m_pData[nIndex++] = newElement;

	mov	eax, DWORD PTR _newElement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	DWORD PTR -12+[ebp], eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nIndex$[ebp], ecx
	mov	ecx, DWORD PTR -12+[ebp]
	call	??4URLITEM@@QAEAAU0@ABU0@@Z		; URLITEM::operator=
	jmp	SHORT $L78078
$L78082:

; 477  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsertAt@?$CArray@UURLITEM@@AAU1@@@QAEXHAAUURLITEM@@H@Z ENDP ; CArray<URLITEM,URLITEM &>::InsertAt
_TEXT	ENDS
EXTRN	??1CObject@@UAE@XZ:NEAR				; CObject::~CObject
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80170	DD	019930520H
	DD	01H
	DD	FLAT:$T80172
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80172	DD	0ffffffffH
	DD	FLAT:$L80168
xdata$x	ENDS
;	COMDAT ??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T80167 = -16
__$EHRec$ = -12
??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ PROC NEAR		; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80171
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UURLITEM@@AAU1@@@6B@ ; CArray<URLITEM,URLITEM &>::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 295  : 	ASSERT_VALID(this);

	push	295					; 00000127H
	push	OFFSET FLAT:__szAfxTempl
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 296  : 
; 297  : 	if (m_pData != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L78086

; 299  : 		DestructElements<TYPE>(m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestructElements@@YGXPAUURLITEM@@H@Z	; DestructElements

; 300  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T80167[ebp], edx
	mov	eax, DWORD PTR $T80167[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L78086:

; 302  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80168:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L80171:
	mov	eax, OFFSET FLAT:$T80170
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ ENDP		; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
PUBLIC	?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z ; SerializeElements
EXTRN	?ReadCount@CArchive@@QAEKXZ:NEAR		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:NEAR		; CArchive::WriteCount
EXTRN	?IsStoring@CArchive@@QBEHXZ:NEAR		; CArchive::IsStoring
;	COMDAT ?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_ar$ = 8
_this$ = -8
_nOldSize$78099 = -4
?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::Serialize, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	ASSERT_VALID(this);

	push	515					; 00000203H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 516  : 
; 517  : 	CObject::Serialize(ar);

	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Serialize@CObject@@UAEXAAVCArchive@@@Z	; CObject::Serialize

; 518  : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L78097

; 520  : 		ar.WriteCount(m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?WriteCount@CArchive@@QAEXK@Z		; CArchive::WriteCount

; 522  : 	else

	jmp	SHORT $L78098
$L78097:

; 524  : 		DWORD nOldSize = ar.ReadCount();

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?ReadCount@CArchive@@QAEKXZ		; CArchive::ReadCount
	mov	DWORD PTR _nOldSize$78099[ebp], eax

; 525  : 		SetSize(nOldSize, -1);

	push	-1
	mov	ecx, DWORD PTR _nOldSize$78099[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z ; CArray<URLITEM,URLITEM &>::SetSize
$L78098:

; 527  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ar$[ebp]
	push	eax
	call	?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z ; SerializeElements

; 528  : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Serialize@?$CArray@UURLITEM@@AAU1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<URLITEM,URLITEM &>::Serialize
_TEXT	ENDS
PUBLIC	??_C@_05KIFI@with?5?$AA@			; `string'
PUBLIC	??_C@_09LOPF@?5elements?$AA@			; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z ; DumpElements
EXTRN	?Dump@CObject@@UBEXAAVCDumpContext@@@Z:NEAR	; CObject::Dump
EXTRN	?GetDepth@CDumpContext@@QBEHXZ:NEAR		; CDumpContext::GetDepth
EXTRN	??6CDumpContext@@QAEAAV0@PBD@Z:NEAR		; CDumpContext::operator<<
EXTRN	??6CDumpContext@@QAEAAV0@H@Z:NEAR		; CDumpContext::operator<<
;	COMDAT ??_C@_05KIFI@with?5?$AA@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
_DATA	SEGMENT
??_C@_05KIFI@with?5?$AA@ DB 'with ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LOPF@?5elements?$AA@
_DATA	SEGMENT
??_C@_09LOPF@?5elements?$AA@ DB ' elements', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
_DATA	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
_DATA	ENDS
;	COMDAT ?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_dc$ = 8
_this$ = -4
?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::Dump, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	CObject::Dump(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Dump@CObject@@UBEXAAVCDumpContext@@@Z	; CObject::Dump

; 535  : 
; 536  : 	dc << "with " << m_nSize << " elements";

	push	OFFSET FLAT:??_C@_09LOPF@?5elements?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET FLAT:??_C@_05KIFI@with?5?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@H@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 537  : 	if (dc.GetDepth() > 0)

	mov	ecx, DWORD PTR _dc$[ebp]
	call	?GetDepth@CDumpContext@@QBEHXZ		; CDumpContext::GetDepth
	test	eax, eax
	jle	SHORT $L78112

; 539  : 		dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 540  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _dc$[ebp]
	push	ecx
	call	?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z ; DumpElements
$L78112:

; 542  : 
; 543  : 	dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 544  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Dump@?$CArray@UURLITEM@@AAU1@@@UBEXAAVCDumpContext@@@Z ENDP ; CArray<URLITEM,URLITEM &>::Dump
_TEXT	ENDS
EXTRN	?AssertValid@CObject@@UBEXXZ:NEAR		; CObject::AssertValid
EXTRN	?AfxIsValidAddress@@YGHPBXIH@Z:NEAR		; AfxIsValidAddress
;	COMDAT ?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ PROC NEAR	; CArray<URLITEM,URLITEM &>::AssertValid, COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	CObject::AssertValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssertValid@CObject@@UBEXXZ		; CObject::AssertValid

; 550  : 
; 551  : 	if (m_pData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78123
$L78124:

; 553  : 		ASSERT(m_nSize == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $L78127
	push	553					; 00000229H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78127
	int	3
$L78127:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78124
$L78126:

; 554  : 		ASSERT(m_nMaxSize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L78131
	push	554					; 0000022aH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78131
	int	3
$L78131:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78126

; 556  : 	else

	jmp	$L78147
$L78123:

; 558  : 		ASSERT(m_nSize >= 0);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jge	SHORT $L78136
	push	558					; 0000022eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78136
	int	3
$L78136:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78123
$L78135:

; 559  : 		ASSERT(m_nMaxSize >= 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $L78140
	push	559					; 0000022fH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78140
	int	3
$L78140:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78135
$L78139:

; 560  : 		ASSERT(m_nSize <= m_nMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $L78144
	push	560					; 00000230H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78144
	int	3
$L78144:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78139
$L78143:

; 561  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78149
	push	561					; 00000231H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78149
	int	3
$L78149:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78143
$L78147:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertValid@?$CArray@UURLITEM@@AAU1@@@UBEXXZ ENDP	; CArray<URLITEM,URLITEM &>::AssertValid
_TEXT	ENDS
PUBLIC	?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z ; CArray<PROTOCOL,PROTOCOL &>::Serialize
PUBLIC	?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z ; CArray<PROTOCOL,PROTOCOL &>::Dump
PUBLIC	?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ	; CArray<PROTOCOL,PROTOCOL &>::AssertValid
PUBLIC	??_7?$CArray@UPROTOCOL@@AAU1@@@6B@		; CArray<PROTOCOL,PROTOCOL &>::`vftable'
PUBLIC	??_G?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z	; CArray<PROTOCOL,PROTOCOL &>::`scalar deleting destructor'
PUBLIC	??_E?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z	; CArray<PROTOCOL,PROTOCOL &>::`vector deleting destructor'
;	COMDAT ??_7?$CArray@UPROTOCOL@@AAU1@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
CONST	SEGMENT
??_7?$CArray@UPROTOCOL@@AAU1@@@6B@ DD FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ ; CArray<PROTOCOL,PROTOCOL &>::`vftable'
	DD	FLAT:??_E?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ
	DD	FLAT:?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ PROC NEAR		; CArray<PROTOCOL,PROTOCOL &>::CArray<PROTOCOL,PROTOCOL &>, COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CObject@@IAE@XZ			; CObject::CObject
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UPROTOCOL@@AAU1@@@6B@ ; CArray<PROTOCOL,PROTOCOL &>::`vftable'

; 288  : 	m_pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 289  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 290  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CArray@UPROTOCOL@@AAU1@@@QAE@XZ ENDP		; CArray<PROTOCOL,PROTOCOL &>::CArray<PROTOCOL,PROTOCOL &>
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ PROC NEAR	; CArray<PROTOCOL,PROTOCOL &>::GetSize, COMDAT

; 245  : 	{ return m_nSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CArray@UPROTOCOL@@AAU1@@@QBEHXZ ENDP		; CArray<PROTOCOL,PROTOCOL &>::GetSize
_TEXT	ENDS
PUBLIC	?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z ; CArray<PROTOCOL,PROTOCOL &>::SetAtGrow
;	COMDAT ?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z
_TEXT	SEGMENT
_newElement$ = 8
_this$ = -8
_nIndex$ = -4
?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::Add, COMDAT

; 272  : 	{ int nIndex = m_nSize;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nIndex$[ebp], ecx

; 273  : 		SetAtGrow(nIndex, newElement);

	mov	edx, DWORD PTR _newElement$[ebp]
	push	edx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z ; CArray<PROTOCOL,PROTOCOL &>::SetAtGrow

; 274  : 		return nIndex; }

	mov	eax, DWORD PTR _nIndex$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CArray@UPROTOCOL@@AAU1@@@QAEHAAUPROTOCOL@@@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::Add
_TEXT	ENDS
PUBLIC	?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::ElementAt
;	COMDAT ??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::operator[], COMDAT

; 280  : 	{ return ElementAt(nIndex); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::ElementAt
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ENDP	; CArray<PROTOCOL,PROTOCOL &>::operator[]
_TEXT	ENDS
PUBLIC	?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::GetAt
;	COMDAT ??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z
_TEXT	SEGMENT
$T80193 = -4
_nIndex$ = 12
___$ReturnUdt$ = 8
_this$ = -8
??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::operator[], COMDAT

; 277  : 	{ return GetAt(nIndex); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T80193[ebp], 0
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ; CArray<PROTOCOL,PROTOCOL &>::GetAt
	mov	edx, DWORD PTR $T80193[ebp]
	or	edx, 1
	mov	DWORD PTR $T80193[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
??A?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ENDP	; CArray<PROTOCOL,PROTOCOL &>::operator[]
_TEXT	ENDS
PUBLIC	?DestructElements@@YGXPAUPROTOCOL@@H@Z		; DestructElements
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80200	DD	019930520H
	DD	01H
	DD	FLAT:$T80202
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80202	DD	0ffffffffH
	DD	FLAT:$L80198
xdata$x	ENDS
;	COMDAT ??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ
_TEXT	SEGMENT
$T80197 = -16
__$EHRec$ = -12
_this$ = -20
??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ PROC NEAR		; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80201
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@UPROTOCOL@@AAU1@@@6B@ ; CArray<PROTOCOL,PROTOCOL &>::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 295  : 	ASSERT_VALID(this);

	push	295					; 00000127H
	push	OFFSET FLAT:__szAfxTempl
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 296  : 
; 297  : 	if (m_pData != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L78174

; 299  : 		DestructElements<TYPE>(m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?DestructElements@@YGXPAUPROTOCOL@@H@Z	; DestructElements

; 300  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T80197[ebp], edx
	mov	eax, DWORD PTR $T80197[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L78174:

; 302  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80198:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L80201:
	mov	eax, OFFSET FLAT:$T80200
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ ENDP		; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
PUBLIC	?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z ; SerializeElements
PUBLIC	?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z	; CArray<PROTOCOL,PROTOCOL &>::SetSize
;	COMDAT ?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_ar$ = 8
_this$ = -8
_nOldSize$78188 = -4
?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::Serialize, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	ASSERT_VALID(this);

	push	515					; 00000203H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 516  : 
; 517  : 	CObject::Serialize(ar);

	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Serialize@CObject@@UAEXAAVCArchive@@@Z	; CObject::Serialize

; 518  : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L78186

; 520  : 		ar.WriteCount(m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?WriteCount@CArchive@@QAEXK@Z		; CArchive::WriteCount

; 522  : 	else

	jmp	SHORT $L78187
$L78186:

; 524  : 		DWORD nOldSize = ar.ReadCount();

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?ReadCount@CArchive@@QAEKXZ		; CArchive::ReadCount
	mov	DWORD PTR _nOldSize$78188[ebp], eax

; 525  : 		SetSize(nOldSize, -1);

	push	-1
	mov	ecx, DWORD PTR _nOldSize$78188[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z ; CArray<PROTOCOL,PROTOCOL &>::SetSize
$L78187:

; 527  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ar$[ebp]
	push	eax
	call	?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z ; SerializeElements

; 528  : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Serialize@?$CArray@UPROTOCOL@@AAU1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::Serialize
_TEXT	ENDS
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z ; DumpElements
;	COMDAT ?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_dc$ = 8
_this$ = -4
?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::Dump, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	CObject::Dump(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Dump@CObject@@UBEXAAVCDumpContext@@@Z	; CObject::Dump

; 535  : 
; 536  : 	dc << "with " << m_nSize << " elements";

	push	OFFSET FLAT:??_C@_09LOPF@?5elements?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET FLAT:??_C@_05KIFI@with?5?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@H@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 537  : 	if (dc.GetDepth() > 0)

	mov	ecx, DWORD PTR _dc$[ebp]
	call	?GetDepth@CDumpContext@@QBEHXZ		; CDumpContext::GetDepth
	test	eax, eax
	jle	SHORT $L78199

; 539  : 		dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 540  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _dc$[ebp]
	push	ecx
	call	?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z ; DumpElements
$L78199:

; 542  : 
; 543  : 	dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 544  : }

	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?Dump@?$CArray@UPROTOCOL@@AAU1@@@UBEXAAVCDumpContext@@@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::Dump
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::AssertValid, COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 549  : 	CObject::AssertValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssertValid@CObject@@UBEXXZ		; CObject::AssertValid

; 550  : 
; 551  : 	if (m_pData == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78209
$L78210:

; 553  : 		ASSERT(m_nSize == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $L78213
	push	553					; 00000229H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78213
	int	3
$L78213:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78210
$L78212:

; 554  : 		ASSERT(m_nMaxSize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L78217
	push	554					; 0000022aH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78217
	int	3
$L78217:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78212

; 556  : 	else

	jmp	$L78233
$L78209:

; 558  : 		ASSERT(m_nSize >= 0);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jge	SHORT $L78222
	push	558					; 0000022eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78222
	int	3
$L78222:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78209
$L78221:

; 559  : 		ASSERT(m_nMaxSize >= 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $L78226
	push	559					; 0000022fH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78226
	int	3
$L78226:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78221
$L78225:

; 560  : 		ASSERT(m_nSize <= m_nMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $L78230
	push	560					; 00000230H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78230
	int	3
$L78230:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78225
$L78229:

; 561  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78235
	push	561					; 00000231H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78235
	int	3
$L78235:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78229
$L78233:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertValid@?$CArray@UPROTOCOL@@AAU1@@@UBEXXZ ENDP	; CArray<PROTOCOL,PROTOCOL &>::AssertValid
_TEXT	ENDS
PUBLIC	?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z ; CMap<CString,unsigned short const *,int,int &>::Serialize
PUBLIC	?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z ; CMap<CString,unsigned short const *,int,int &>::Dump
PUBLIC	?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ	; CMap<CString,unsigned short const *,int,int &>::AssertValid
PUBLIC	??_7?$CMap@VCString@@PBGHAAH@@6B@		; CMap<CString,unsigned short const *,int,int &>::`vftable'
PUBLIC	??_G?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z		; CMap<CString,unsigned short const *,int,int &>::`scalar deleting destructor'
PUBLIC	??_E?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z		; CMap<CString,unsigned short const *,int,int &>::`vector deleting destructor'
;	COMDAT ??_7?$CMap@VCString@@PBGHAAH@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
CONST	SEGMENT
??_7?$CMap@VCString@@PBGHAAH@@6B@ DD FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ ; CMap<CString,unsigned short const *,int,int &>::`vftable'
	DD	FLAT:??_E?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ
	DD	FLAT:?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80215	DD	019930520H
	DD	01H
	DD	FLAT:$T80217
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80217	DD	0ffffffffH
	DD	FLAT:$L80213
xdata$x	ENDS
;	COMDAT ??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_nBlockSize$ = 8
_this$ = -16
??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z PROC NEAR		; CMap<CString,unsigned short const *,int,int &>::CMap<CString,unsigned short const *,int,int &>, COMDAT

; 1201 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80216
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CObject@@IAE@XZ			; CObject::CObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CMap@VCString@@PBGHAAH@@6B@ ; CMap<CString,unsigned short const *,int,int &>::`vftable'
$L78329:

; 1202 : 	ASSERT(nBlockSize > 0);

	cmp	DWORD PTR _nBlockSize$[ebp], 0
	jg	SHORT $L78332
	push	1202					; 000004b2H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78332
	int	3
$L78332:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78329

; 1203 : 
; 1204 : 	m_pHashTable = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 1205 : 	m_nHashTableSize = 17;  // default size

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 17			; 00000011H

; 1206 : 	m_nCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1207 : 	m_pFreeList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 1208 : 	m_pBlocks = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1209 : 	m_nBlockSize = nBlockSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nBlockSize$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 1210 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80213:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L80216:
	mov	eax, OFFSET FLAT:$T80215
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CMap@VCString@@PBGHAAH@@QAE@H@Z ENDP		; CMap<CString,unsigned short const *,int,int &>::CMap<CString,unsigned short const *,int,int &>
;	COMDAT ?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::GetCount, COMDAT

; 1182 : 	{ return m_nCount; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCount@?$CMap@VCString@@PBGHAAH@@QBEHXZ ENDP		; CMap<CString,unsigned short const *,int,int &>::GetCount
_TEXT	ENDS
PUBLIC	?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,int,int &>::GetAssocAt
;	COMDAT ?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z
_TEXT	SEGMENT
_key$ = 8
_rValue$ = 12
_this$ = -12
_nHash$ = -8
_pAssoc$ = -4
?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::Lookup, COMDAT

; 1341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1342 : 	ASSERT_VALID(this);

	push	1342					; 0000053eH
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1343 : 
; 1344 : 	UINT nHash;
; 1345 : 	CAssoc* pAssoc = GetAssocAt(key, nHash);

	lea	ecx, DWORD PTR _nHash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,int,int &>::GetAssocAt
	mov	DWORD PTR _pAssoc$[ebp], eax

; 1346 : 	if (pAssoc == NULL)

	cmp	DWORD PTR _pAssoc$[ebp], 0
	jne	SHORT $L78343

; 1347 : 		return FALSE;  // not in map

	xor	eax, eax
	jmp	SHORT $L78340
$L78343:

; 1348 : 
; 1349 : 	rValue = pAssoc->value;

	mov	eax, DWORD PTR _rValue$[ebp]
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 1350 : 	return TRUE;

	mov	eax, 1
$L78340:

; 1351 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?Lookup@?$CMap@VCString@@PBGHAAH@@QBEHPBGAAH@Z ENDP	; CMap<CString,unsigned short const *,int,int &>::Lookup
_TEXT	ENDS
PUBLIC	??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z	; CMap<CString,unsigned short const *,int,int &>::operator[]
;	COMDAT ?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z
_TEXT	SEGMENT
_key$ = 8
_newValue$ = 12
_this$ = -4
?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::SetAt, COMDAT

; 1188 : 	{ (*this)[key] = newValue; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z ; CMap<CString,unsigned short const *,int,int &>::operator[]
	mov	ecx, DWORD PTR _newValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z ENDP	; CMap<CString,unsigned short const *,int,int &>::SetAt
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ	; CMap<CString,unsigned short const *,int,int &>::RemoveAll
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80230	DD	019930520H
	DD	01H
	DD	FLAT:$T80232
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80232	DD	0ffffffffH
	DD	FLAT:$L80228
xdata$x	ENDS
;	COMDAT ??1?$CMap@VCString@@PBGHAAH@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CMap@VCString@@PBGHAAH@@UAE@XZ PROC NEAR		; CMap<CString,unsigned short const *,int,int &>::~CMap<CString,unsigned short const *,int,int &>, COMDAT

; 1270 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80231
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CMap@VCString@@PBGHAAH@@6B@ ; CMap<CString,unsigned short const *,int,int &>::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1271 : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ ; CMap<CString,unsigned short const *,int,int &>::RemoveAll
$L78352:

; 1272 : 	ASSERT(m_nCount == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L78355
	push	1272					; 000004f8H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78355
	int	3
$L78355:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78352

; 1273 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80228:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CObject@@UAE@XZ			; CObject::~CObject
	ret	0
$L80231:
	mov	eax, OFFSET FLAT:$T80230
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CMap@VCString@@PBGHAAH@@UAE@XZ ENDP		; CMap<CString,unsigned short const *,int,int &>::~CMap<CString,unsigned short const *,int,int &>
PUBLIC	?SerializeElements@@YGXAAVCArchive@@PAHH@Z	; SerializeElements
EXTRN	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z:NEAR ; SerializeElements
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80239	DD	019930520H
	DD	01H
	DD	FLAT:$T80241
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80241	DD	0ffffffffH
	DD	FLAT:$L80237
xdata$x	ENDS
;	COMDAT ?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_ar$ = 8
_this$ = -36
_nHash$78366 = -16
_pAssoc$78370 = -20
_nNewCount$78386 = -24
_newKey$78390 = -28
_newValue$78391 = -32
?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::Serialize, COMDAT

; 1445 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80240
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1446 : 	ASSERT_VALID(this);

	push	1446					; 000005a6H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1447 : 
; 1448 : 	CObject::Serialize(ar);

	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Serialize@CObject@@UAEXAAVCArchive@@@Z	; CObject::Serialize

; 1449 : 
; 1450 : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	$L78360

; 1452 : 		ar.WriteCount(m_nCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?WriteCount@CArchive@@QAEXK@Z		; CArchive::WriteCount

; 1453 : 		if (m_nCount == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $L78361

; 1454 : 			return;  // nothing more to do

	jmp	$L78359
$L78361:

; 1455 : 
; 1456 : 		ASSERT(m_pHashTable != NULL);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L78365
	push	1456					; 000005b0H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78365
	int	3
$L78365:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78361

; 1457 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

	mov	DWORD PTR _nHash$78366[ebp], 0
	jmp	SHORT $L78367
$L78368:
	mov	ecx, DWORD PTR _nHash$78366[ebp]
	add	ecx, 1
	mov	DWORD PTR _nHash$78366[ebp], ecx
$L78367:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nHash$78366[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $L78369

; 1459 : 			CAssoc* pAssoc;
; 1460 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _nHash$78366[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pAssoc$78370[ebp], ecx

; 1461 : 			  pAssoc = pAssoc->pNext)

	jmp	SHORT $L78371
$L78372:
	mov	edx, DWORD PTR _pAssoc$78370[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pAssoc$78370[ebp], eax
$L78371:
	cmp	DWORD PTR _pAssoc$78370[ebp], 0
	je	SHORT $L78373

; 1463 : 				SerializeElements<KEY>(ar, &pAssoc->key, 1);

	push	1
	mov	ecx, DWORD PTR _pAssoc$78370[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	call	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z ; SerializeElements

; 1464 : 				SerializeElements<VALUE>(ar, &pAssoc->value, 1);

	push	1
	mov	eax, DWORD PTR _pAssoc$78370[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	call	?SerializeElements@@YGXAAVCArchive@@PAHH@Z ; SerializeElements

; 1465 : 			}

	jmp	SHORT $L78372
$L78373:

; 1466 : 		}

	jmp	SHORT $L78368
$L78369:

; 1468 : 	else

	jmp	SHORT $L78389
$L78360:

; 1470 : 		DWORD nNewCount = ar.ReadCount();

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?ReadCount@CArchive@@QAEKXZ		; CArchive::ReadCount
	mov	DWORD PTR _nNewCount$78386[ebp], eax
$L78388:

; 1471 : 		while (nNewCount--)

	mov	edx, DWORD PTR _nNewCount$78386[ebp]
	mov	eax, DWORD PTR _nNewCount$78386[ebp]
	sub	eax, 1
	mov	DWORD PTR _nNewCount$78386[ebp], eax
	test	edx, edx
	je	SHORT $L78389

; 1473 : 			KEY newKey;

	lea	ecx, DWORD PTR _newKey$78390[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1474 : 			VALUE newValue;
; 1475 : 			SerializeElements<KEY>(ar, &newKey, 1);

	push	1
	lea	ecx, DWORD PTR _newKey$78390[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	call	?SerializeElements@@YGXAAVCArchive@@PAVCString@@H@Z ; SerializeElements

; 1476 : 			SerializeElements<VALUE>(ar, &newValue, 1);

	push	1
	lea	eax, DWORD PTR _newValue$78391[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	call	?SerializeElements@@YGXAAVCArchive@@PAHH@Z ; SerializeElements

; 1477 : 			SetAt(newKey, newValue);

	lea	edx, DWORD PTR _newValue$78391[ebp]
	push	edx
	lea	ecx, DWORD PTR _newKey$78390[ebp]
	call	??BCString@@QBEPBGXZ			; CString::operator unsigned short const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAt@?$CMap@VCString@@PBGHAAH@@QAEXPBGAAH@Z ; CMap<CString,unsigned short const *,int,int &>::SetAt

; 1478 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _newKey$78390[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	jmp	SHORT $L78388
$L78389:
$L78359:

; 1480 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80237:
	lea	ecx, DWORD PTR _newKey$78390[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80240:
	mov	eax, OFFSET FLAT:$T80239
	jmp	___CxxFrameHandler
text$x	ENDS
?Serialize@?$CMap@VCString@@PBGHAAH@@UAEXAAVCArchive@@@Z ENDP ; CMap<CString,unsigned short const *,int,int &>::Serialize
PUBLIC	?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ ; CMap<CString,unsigned short const *,int,int &>::GetStartPosition
PUBLIC	?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z ; CMap<CString,unsigned short const *,int,int &>::GetNextAssoc
PUBLIC	??_C@_03DANH@?6?7?$FL?$AA@			; `string'
PUBLIC	??_C@_04MNLE@?$FN?5?$DN?5?$AA@			; `string'
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ; DumpElements
PUBLIC	?DumpElements@@YGXAAVCDumpContext@@PBHH@Z	; DumpElements
;	COMDAT ??_C@_03DANH@?6?7?$FL?$AA@
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
_DATA	SEGMENT
??_C@_03DANH@?6?7?$FL?$AA@ DB 0aH, 09H, '[', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MNLE@?$FN?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_04MNLE@?$FN?5?$DN?5?$AA@ DB '] = ', 00H		; `string'
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T80248	DD	019930520H
	DD	01H
	DD	FLAT:$T80250
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80250	DD	0ffffffffH
	DD	FLAT:$L80246
xdata$x	ENDS
;	COMDAT ?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_dc$ = 8
_this$ = -28
_key$78407 = -20
_val$78408 = -16
_pos$78409 = -24
?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::Dump, COMDAT

; 1485 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80249
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1486 : 	CObject::Dump(dc);

	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Dump@CObject@@UBEXAAVCDumpContext@@@Z	; CObject::Dump

; 1487 : 
; 1488 : 	dc << "with " << m_nCount << " elements";

	push	OFFSET FLAT:??_C@_09LOPF@?5elements?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET FLAT:??_C@_05KIFI@with?5?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@H@Z		; CDumpContext::operator<<
	mov	ecx, eax
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1489 : 	if (dc.GetDepth() > 0)

	mov	ecx, DWORD PTR _dc$[ebp]
	call	?GetDepth@CDumpContext@@QBEHXZ		; CDumpContext::GetDepth
	test	eax, eax
	jle	SHORT $L78406

; 1491 : 		// Dump in format "[key] -> value"
; 1492 : 		KEY key;

	lea	ecx, DWORD PTR _key$78407[ebp]
	call	??0CString@@QAE@XZ			; CString::CString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1493 : 		VALUE val;
; 1494 : 
; 1495 : 		POSITION pos = GetStartPosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ ; CMap<CString,unsigned short const *,int,int &>::GetStartPosition
	mov	DWORD PTR _pos$78409[ebp], eax
$L78411:

; 1496 : 		while (pos != NULL)

	cmp	DWORD PTR _pos$78409[ebp], 0
	je	SHORT $L78412

; 1498 : 			GetNextAssoc(pos, key, val);

	lea	eax, DWORD PTR _val$78408[ebp]
	push	eax
	lea	ecx, DWORD PTR _key$78407[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$78409[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z ; CMap<CString,unsigned short const *,int,int &>::GetNextAssoc

; 1499 : 			dc << "\n\t[";

	push	OFFSET FLAT:??_C@_03DANH@?6?7?$FL?$AA@	; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1500 : 			DumpElements<KEY>(dc, &key, 1);

	push	1
	lea	eax, DWORD PTR _key$78407[ebp]
	push	eax
	mov	ecx, DWORD PTR _dc$[ebp]
	push	ecx
	call	?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ; DumpElements

; 1501 : 			dc << "] = ";

	push	OFFSET FLAT:??_C@_04MNLE@?$FN?5?$DN?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1502 : 			DumpElements<VALUE>(dc, &val, 1);

	push	1
	lea	edx, DWORD PTR _val$78408[ebp]
	push	edx
	mov	eax, DWORD PTR _dc$[ebp]
	push	eax
	call	?DumpElements@@YGXAAVCDumpContext@@PBHH@Z ; DumpElements

; 1503 : 		}

	jmp	SHORT $L78411
$L78412:

; 1504 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$78407[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
$L78406:

; 1505 : 
; 1506 : 	dc << "\n";

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	ecx, DWORD PTR _dc$[ebp]
	call	??6CDumpContext@@QAEAAV0@PBD@Z		; CDumpContext::operator<<

; 1507 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80246:
	lea	ecx, DWORD PTR _key$78407[ebp]
	call	??1CString@@QAE@XZ			; CString::~CString
	ret	0
$L80249:
	mov	eax, OFFSET FLAT:$T80248
	jmp	___CxxFrameHandler
text$x	ENDS
?Dump@?$CMap@VCString@@PBGHAAH@@UBEXAAVCDumpContext@@@Z ENDP ; CMap<CString,unsigned short const *,int,int &>::Dump
;	COMDAT ?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4
?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::AssertValid, COMDAT

; 1511 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1512 : 	CObject::AssertValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssertValid@CObject@@UBEXXZ		; CObject::AssertValid
$L78427:

; 1513 : 
; 1514 : 	ASSERT(m_nHashTableSize > 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	ja	SHORT $L78430
	push	1514					; 000005eaH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78430
	int	3
$L78430:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78427
$L78429:

; 1515 : 	ASSERT(m_nCount == 0 || m_pHashTable != NULL);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L78434
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78434
	push	1515					; 000005ebH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78434
	int	3
$L78434:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78429

; 1516 : 		// non-empty map should have hash table
; 1517 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertValid@?$CMap@VCString@@PBGHAAH@@UBEXXZ ENDP	; CMap<CString,unsigned short const *,int,int &>::AssertValid
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z PROC NEAR	; CArray<URLITEM,URLITEM &>::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CArray@UURLITEM@@AAU1@@@UAE@XZ	; CArray<URLITEM,URLITEM &>::~CArray<URLITEM,URLITEM &>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L78551
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L78551:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CArray@UURLITEM@@AAU1@@@UAEPAXI@Z ENDP		; CArray<URLITEM,URLITEM &>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??4URLITEM@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4URLITEM@@QAEAAU0@ABU0@@Z PROC NEAR			; URLITEM::operator=, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??4URLITEM@@QAEAAU0@ABU0@@Z ENDP			; URLITEM::operator=
_TEXT	ENDS
;	COMDAT ??_G?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z PROC NEAR	; CArray<PROTOCOL,PROTOCOL &>::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CArray@UPROTOCOL@@AAU1@@@UAE@XZ	; CArray<PROTOCOL,PROTOCOL &>::~CArray<PROTOCOL,PROTOCOL &>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L78556
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L78556:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CArray@UPROTOCOL@@AAU1@@@UAEPAXI@Z ENDP		; CArray<PROTOCOL,PROTOCOL &>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??_G?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_G?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CMap@VCString@@PBGHAAH@@UAE@XZ	; CMap<CString,unsigned short const *,int,int &>::~CMap<CString,unsigned short const *,int,int &>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L78562
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3CObject@@SGXPAX@Z			; CObject::operator delete
$L78562:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CMap@VCString@@PBGHAAH@@UAEPAXI@Z ENDP		; CMap<CString,unsigned short const *,int,int &>::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_memcpy:NEAR
EXTRN	??2@YAPAXIPBDH@Z:NEAR				; operator new
;	COMDAT ?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z
_TEXT	SEGMENT
$T80265 = -16
$T80266 = -20
$T80271 = -24
$T80272 = -28
_nNewSize$ = 8
_nGrowBy$ = 12
_this$ = -32
_nGrowBy$78613 = -8
_nNewMax$78615 = -12
_pNewData$78627 = -4
?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z PROC NEAR	; CArray<URLITEM,URLITEM &>::SetSize, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 	ASSERT_VALID(this);

	push	307					; 00000133H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78571:

; 308  : 	ASSERT(nNewSize >= 0);

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jge	SHORT $L78574
	push	308					; 00000134H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78574
	int	3
$L78574:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78571

; 309  : 
; 310  : 	if (nGrowBy != -1)

	cmp	DWORD PTR _nGrowBy$[ebp], -1
	je	SHORT $L78575

; 311  : 		m_nGrowBy = nGrowBy;  // set new size

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nGrowBy$[ebp]
	mov	DWORD PTR [edx+16], eax
$L78575:

; 312  : 
; 313  : 	if (nNewSize == 0)

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jne	SHORT $L78576

; 315  : 		// shrink to nothing
; 316  : 		if (m_pData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L78577

; 318  : 			DestructElements<TYPE>(m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?DestructElements@@YGXPAUURLITEM@@H@Z	; DestructElements

; 319  : 			delete[] (BYTE*)m_pData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T80265[ebp], ecx
	mov	edx, DWORD PTR $T80265[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 320  : 			m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$L78577:

; 322  : 		m_nSize = m_nMaxSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 324  : 	else if (m_pData == NULL)

	jmp	$L78612
$L78576:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78585
$L78586:

; 326  : 		// create one with exact size
; 327  : #ifdef SIZE_T_MAX
; 328  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow

	cmp	DWORD PTR _nNewSize$[ebp], 268435455	; 0fffffffH
	jbe	SHORT $L78590
	push	328					; 00000148H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78590
	int	3
$L78590:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78586

; 329  : #endif
; 330  : 		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];

	push	330					; 0000014aH
	push	OFFSET FLAT:__szAfxTempl
	mov	edx, DWORD PTR _nNewSize$[ebp]
	shl	edx, 4
	push	edx
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T80266[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T80266[ebp]
	mov	DWORD PTR [eax+4], ecx

; 331  : 		ConstructElements<TYPE>(m_pData, nNewSize);

	mov	edx, DWORD PTR _nNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ConstructElements@@YGXPAUURLITEM@@H@Z	; ConstructElements

; 332  : 		m_nSize = m_nMaxSize = nNewSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 334  : 	else if (nNewSize <= m_nMaxSize)

	jmp	$L78612
$L78585:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jg	SHORT $L78600

; 336  : 		// it fits
; 337  : 		if (nNewSize > m_nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $L78601

; 339  : 			// initialize the new elements
; 340  : 			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	push	eax
	call	?ConstructElements@@YGXPAUURLITEM@@H@Z	; ConstructElements

; 342  : 		else if (m_nSize > nNewSize)

	jmp	SHORT $L78607
$L78601:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _nNewSize$[ebp]
	jle	SHORT $L78607

; 344  : 			// destroy the old elements
; 345  : 			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _nNewSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nNewSize$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	ecx
	call	?DestructElements@@YGXPAUURLITEM@@H@Z	; DestructElements
$L78607:

; 347  : 		m_nSize = nNewSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [edx+8], eax

; 349  : 	else

	jmp	$L78612
$L78600:

; 351  : 		// otherwise, grow array
; 352  : 		int nGrowBy = m_nGrowBy;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _nGrowBy$78613[ebp], edx

; 353  : 		if (nGrowBy == 0)

	cmp	DWORD PTR _nGrowBy$78613[ebp], 0
	jne	SHORT $L78614

; 355  : 			// heuristically determine growth when nGrowBy == 0
; 356  : 			//  (this avoids heap fragmentation in many situations)
; 357  : 			nGrowBy = m_nSize / 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _nGrowBy$78613[ebp], eax

; 358  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

	cmp	DWORD PTR _nGrowBy$78613[ebp], 4
	jge	SHORT $L80269
	mov	DWORD PTR -36+[ebp], 4
	jmp	SHORT $L80270
$L80269:
	cmp	DWORD PTR _nGrowBy$78613[ebp], 1024	; 00000400H
	jle	SHORT $L80267
	mov	DWORD PTR -40+[ebp], 1024		; 00000400H
	jmp	SHORT $L80268
$L80267:
	mov	ecx, DWORD PTR _nGrowBy$78613[ebp]
	mov	DWORD PTR -40+[ebp], ecx
$L80268:
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR -36+[ebp], edx
$L80270:
	mov	eax, DWORD PTR -36+[ebp]
	mov	DWORD PTR _nGrowBy$78613[ebp], eax
$L78614:

; 361  : 		if (nNewSize < m_nMaxSize + nGrowBy)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _nGrowBy$78613[ebp]
	cmp	DWORD PTR _nNewSize$[ebp], edx
	jge	SHORT $L78616

; 362  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _nGrowBy$78613[ebp]
	mov	DWORD PTR _nNewMax$78615[ebp], ecx

; 363  : 		else

	jmp	SHORT $L78617
$L78616:

; 364  : 			nNewMax = nNewSize;  // no slush

	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR _nNewMax$78615[ebp], edx
$L78617:

; 365  : 
; 366  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMax$78615[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L78621
	push	366					; 0000016eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78621
	int	3
$L78621:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78617
$L78620:

; 367  : #ifdef SIZE_T_MAX
; 368  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow

	cmp	DWORD PTR _nNewMax$78615[ebp], 268435455 ; 0fffffffH
	jbe	SHORT $L78626
	push	368					; 00000170H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78626
	int	3
$L78626:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78620

; 369  : #endif
; 370  : 		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

	push	370					; 00000172H
	push	OFFSET FLAT:__szAfxTempl
	mov	ecx, DWORD PTR _nNewMax$78615[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T80271[ebp], eax
	mov	edx, DWORD PTR $T80271[ebp]
	mov	DWORD PTR _pNewData$78627[ebp], edx

; 371  : 
; 372  : 		// copy new data from old
; 373  : 		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pNewData$78627[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L78633:

; 374  : 
; 375  : 		// construct remaining elements
; 376  : 		ASSERT(nNewSize > m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jg	SHORT $L78636
	push	376					; 00000178H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78636
	int	3
$L78636:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78633

; 377  : 		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 4
	mov	eax, DWORD PTR _pNewData$78627[ebp]
	add	eax, edx
	push	eax
	call	?ConstructElements@@YGXPAUURLITEM@@H@Z	; ConstructElements

; 378  : 
; 379  : 		// get rid of old stuff (note: no destructors called)
; 380  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T80272[ebp], edx
	mov	eax, DWORD PTR $T80272[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 381  : 		m_pData = pNewData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pNewData$78627[ebp]
	mov	DWORD PTR [ecx+4], edx

; 382  : 		m_nSize = nNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 383  : 		m_nMaxSize = nNewMax;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewMax$78615[ebp]
	mov	DWORD PTR [edx+12], eax
$L78612:

; 385  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSize@?$CArray@UURLITEM@@AAU1@@@QAEXHH@Z ENDP	; CArray<URLITEM,URLITEM &>::SetSize
_TEXT	ENDS
PUBLIC	??0URLITEM@@QAE@ABU0@@Z				; URLITEM::URLITEM
;	COMDAT ?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z
_TEXT	SEGMENT
$T80276 = -4
_nIndex$ = 12
___$ReturnUdt$ = 8
_this$ = -8
?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::GetAt, COMDAT

; 254  : 	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T80276[ebp], 0
$L78648:
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L78652
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L78651
$L78652:
	push	254					; 000000feH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78651
	int	3
$L78651:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78648

; 255  : 		return m_pData[nIndex]; }

	mov	eax, DWORD PTR _nIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0URLITEM@@QAE@ABU0@@Z			; URLITEM::URLITEM
	mov	eax, DWORD PTR $T80276[ebp]
	or	al, 1
	mov	DWORD PTR $T80276[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAt@?$CArray@UURLITEM@@AAU1@@@QBE?AUURLITEM@@H@Z ENDP ; CArray<URLITEM,URLITEM &>::GetAt
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z PROC NEAR ; CArray<URLITEM,URLITEM &>::ElementAt, COMDAT

; 262  : 	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L78657:
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L78661
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L78660
$L78661:
	push	262					; 00000106H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78660
	int	3
$L78660:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78657

; 263  : 		return m_pData[nIndex]; }

	mov	eax, DWORD PTR _nIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	eax, edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?ElementAt@?$CArray@UURLITEM@@AAU1@@@QAEAAUURLITEM@@H@Z ENDP ; CArray<URLITEM,URLITEM &>::ElementAt
_TEXT	ENDS
;	COMDAT ?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z
_TEXT	SEGMENT
_pDest$ = 8
_pSrc$ = 12
_nCount$ = 16
?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z PROC NEAR	; CopyElements, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
$L78663:

; 79   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78667
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pDest$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78667
	push	80					; 00000050H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78667
	int	3
$L78667:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78663
$L78665:

; 80   : 		AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
; 81   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78672
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78672
	push	82					; 00000052H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78672
	int	3
$L78672:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78665
$L78670:

; 82   : 		AfxIsValidAddress(pSrc, nCount * sizeof(TYPE)));
; 83   : 
; 84   : 	// default is element-copy using assignment
; 85   : 	while (nCount--)

	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L78675

; 86   : 		*pDest++ = *pSrc++;

	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR -4+[ebp], edx
	mov	eax, DWORD PTR -4+[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSrc$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _pSrc$[ebp], ecx
	mov	edx, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR -8+[ebp], edx
	mov	eax, DWORD PTR _pDest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _pDest$[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	call	??4URLITEM@@QAEAAU0@ABU0@@Z		; URLITEM::operator=
	jmp	SHORT $L78670
$L78675:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CopyElements@@YGXPAUURLITEM@@PBU1@H@Z ENDP		; CopyElements
_TEXT	ENDS
PUBLIC	??_GURLITEM@@QAEPAXI@Z				; URLITEM::`scalar deleting destructor'
;	COMDAT ?DestructElements@@YGXPAUURLITEM@@H@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
?DestructElements@@YGXPAUURLITEM@@H@Z PROC NEAR		; DestructElements, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78677:

; 68   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78681
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78681
	push	69					; 00000045H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78681
	int	3
$L78681:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78677

; 69   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 70   : 
; 71   : 	// call the destructor(s)
; 72   : 	for (; nCount--; pElements++)

	jmp	SHORT $L78682
$L78683:
	mov	eax, DWORD PTR _pElements$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _pElements$[ebp], eax
$L78682:
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L78684

; 73   : 		pElements->~TYPE();

	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	call	??_GURLITEM@@QAEPAXI@Z			; URLITEM::`scalar deleting destructor'
	jmp	SHORT $L78683
$L78684:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?DestructElements@@YGXPAUURLITEM@@H@Z ENDP		; DestructElements
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
EXTRN	_memset:NEAR
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80292	DD	019930520H
	DD	01H
	DD	FLAT:$T80294
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80294	DD	0ffffffffH
	DD	FLAT:$L80290
xdata$x	ENDS
;	COMDAT ?ConstructElements@@YGXPAUURLITEM@@H@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
$T80286 = -16
$T80287 = -20
__$EHRec$ = -12
?ConstructElements@@YGXPAUURLITEM@@H@Z PROC NEAR	; ConstructElements, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80293
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
$L78686:

; 54   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78690
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78690
	push	55					; 00000037H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78690
	int	3
$L78690:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78686

; 55   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 56   : 
; 57   : 	// first do bit-wise zero initialization
; 58   : 	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	// then call the constructor(s)
; 61   : 	for (; nCount--; pElements++)

	jmp	SHORT $L78693
$L78694:
	mov	edx, DWORD PTR _pElements$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _pElements$[ebp], edx
$L78693:
	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L78695

; 62   : 		::new((void*)pElements) TYPE;

	mov	edx, DWORD PTR _pElements$[ebp]
	push	edx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T80287[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T80287[ebp], 0
	je	SHORT $L80288
	mov	ecx, DWORD PTR $T80287[ebp]
	call	??0URLITEM@@QAE@XZ			; URLITEM::URLITEM
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L80289
$L80288:
	mov	DWORD PTR -24+[ebp], 0
$L80289:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T80286[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $L78694
$L78695:

; 63   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80290:
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T80287[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L80293:
	mov	eax, OFFSET FLAT:$T80292
	jmp	___CxxFrameHandler
text$x	ENDS
?ConstructElements@@YGXPAUURLITEM@@H@Z ENDP		; ConstructElements
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __P$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
EXTRN	?Read@CArchive@@QAEIPAXI@Z:NEAR			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:NEAR		; CArchive::Write
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z
_TEXT	SEGMENT
_ar$ = 8
_pElements$ = 12
_nCount$ = 16
?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z PROC NEAR ; SerializeElements, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78703:

; 92   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78707
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78707
	push	93					; 0000005dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78707
	int	3
$L78707:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78703

; 93   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 94   : 
; 95   : 	// default is bit-wise read/write
; 96   : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L78708

; 97   : 		ar.Write((void*)pElements, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Write@CArchive@@QAEXPBXI@Z		; CArchive::Write

; 98   : 	else

	jmp	SHORT $L78711
$L78708:

; 99   : 		ar.Read((void*)pElements, nCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nCount$[ebp]
	shl	edx, 4
	push	edx
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Read@CArchive@@QAEIPAXI@Z		; CArchive::Read
$L78711:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?SerializeElements@@YGXAAVCArchive@@PAUURLITEM@@H@Z ENDP ; SerializeElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78715:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78719
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78719
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78719
	int	3
$L78719:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78715

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBUURLITEM@@H@Z ENDP	; DumpElements
_TEXT	ENDS
PUBLIC	?ConstructElements@@YGXPAUPROTOCOL@@H@Z		; ConstructElements
;	COMDAT ?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z
_TEXT	SEGMENT
$T80307 = -16
$T80308 = -20
$T80313 = -24
$T80314 = -28
_nNewSize$ = 8
_nGrowBy$ = 12
_this$ = -32
_nGrowBy$78768 = -8
_nNewMax$78770 = -12
_pNewData$78782 = -4
?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z PROC NEAR	; CArray<PROTOCOL,PROTOCOL &>::SetSize, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 	ASSERT_VALID(this);

	push	307					; 00000133H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78725:

; 308  : 	ASSERT(nNewSize >= 0);

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jge	SHORT $L78728
	push	308					; 00000134H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78728
	int	3
$L78728:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78725

; 309  : 
; 310  : 	if (nGrowBy != -1)

	cmp	DWORD PTR _nGrowBy$[ebp], -1
	je	SHORT $L78729

; 311  : 		m_nGrowBy = nGrowBy;  // set new size

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nGrowBy$[ebp]
	mov	DWORD PTR [edx+16], eax
$L78729:

; 312  : 
; 313  : 	if (nNewSize == 0)

	cmp	DWORD PTR _nNewSize$[ebp], 0
	jne	SHORT $L78730

; 315  : 		// shrink to nothing
; 316  : 		if (m_pData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L78731

; 318  : 			DestructElements<TYPE>(m_pData, m_nSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?DestructElements@@YGXPAUPROTOCOL@@H@Z	; DestructElements

; 319  : 			delete[] (BYTE*)m_pData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T80307[ebp], ecx
	mov	edx, DWORD PTR $T80307[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 320  : 			m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$L78731:

; 322  : 		m_nSize = m_nMaxSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 324  : 	else if (m_pData == NULL)

	jmp	$L78767
$L78730:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78739
$L78740:

; 326  : 		// create one with exact size
; 327  : #ifdef SIZE_T_MAX
; 328  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow

	cmp	DWORD PTR _nNewSize$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $L78744
	push	328					; 00000148H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78744
	int	3
$L78744:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78740

; 329  : #endif
; 330  : 		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];

	push	330					; 0000014aH
	push	OFFSET FLAT:__szAfxTempl
	mov	edx, DWORD PTR _nNewSize$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T80308[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T80308[ebp]
	mov	DWORD PTR [eax+4], ecx

; 331  : 		ConstructElements<TYPE>(m_pData, nNewSize);

	mov	edx, DWORD PTR _nNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ConstructElements@@YGXPAUPROTOCOL@@H@Z	; ConstructElements

; 332  : 		m_nSize = m_nMaxSize = nNewSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 334  : 	else if (nNewSize <= m_nMaxSize)

	jmp	$L78767
$L78739:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jg	SHORT $L78755

; 336  : 		// it fits
; 337  : 		if (nNewSize > m_nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewSize$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $L78756

; 339  : 			// initialize the new elements
; 340  : 			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	push	ecx
	call	?ConstructElements@@YGXPAUPROTOCOL@@H@Z	; ConstructElements

; 342  : 		else if (m_nSize > nNewSize)

	jmp	SHORT $L78762
$L78756:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jle	SHORT $L78762

; 344  : 			// destroy the old elements
; 345  : 			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _nNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	call	?DestructElements@@YGXPAUPROTOCOL@@H@Z	; DestructElements
$L78762:

; 347  : 		m_nSize = nNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 349  : 	else

	jmp	$L78767
$L78755:

; 351  : 		// otherwise, grow array
; 352  : 		int nGrowBy = m_nGrowBy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nGrowBy$78768[ebp], ecx

; 353  : 		if (nGrowBy == 0)

	cmp	DWORD PTR _nGrowBy$78768[ebp], 0
	jne	SHORT $L78769

; 355  : 			// heuristically determine growth when nGrowBy == 0
; 356  : 			//  (this avoids heap fragmentation in many situations)
; 357  : 			nGrowBy = m_nSize / 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _nGrowBy$78768[ebp], eax

; 358  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

	cmp	DWORD PTR _nGrowBy$78768[ebp], 4
	jge	SHORT $L80311
	mov	DWORD PTR -36+[ebp], 4
	jmp	SHORT $L80312
$L80311:
	cmp	DWORD PTR _nGrowBy$78768[ebp], 1024	; 00000400H
	jle	SHORT $L80309
	mov	DWORD PTR -40+[ebp], 1024		; 00000400H
	jmp	SHORT $L80310
$L80309:
	mov	eax, DWORD PTR _nGrowBy$78768[ebp]
	mov	DWORD PTR -40+[ebp], eax
$L80310:
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
$L80312:
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR _nGrowBy$78768[ebp], edx
$L78769:

; 361  : 		if (nNewSize < m_nMaxSize + nGrowBy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _nGrowBy$78768[ebp]
	cmp	DWORD PTR _nNewSize$[ebp], ecx
	jge	SHORT $L78771

; 362  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _nGrowBy$78768[ebp]
	mov	DWORD PTR _nNewMax$78770[ebp], eax

; 363  : 		else

	jmp	SHORT $L78772
$L78771:

; 364  : 			nNewMax = nNewSize;  // no slush

	mov	ecx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR _nNewMax$78770[ebp], ecx
$L78772:

; 365  : 
; 366  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewMax$78770[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $L78776
	push	366					; 0000016eH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78776
	int	3
$L78776:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78772
$L78775:

; 367  : #ifdef SIZE_T_MAX
; 368  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow

	cmp	DWORD PTR _nNewMax$78770[ebp], 536870911 ; 1fffffffH
	jbe	SHORT $L78781
	push	368					; 00000170H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78781
	int	3
$L78781:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78775

; 369  : #endif
; 370  : 		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

	push	370					; 00000172H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _nNewMax$78770[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T80313[ebp], eax
	mov	ecx, DWORD PTR $T80313[ebp]
	mov	DWORD PTR _pNewData$78782[ebp], ecx

; 371  : 
; 372  : 		// copy new data from old
; 373  : 		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pNewData$78782[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L78788:

; 374  : 
; 375  : 		// construct remaining elements
; 376  : 		ASSERT(nNewSize > m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jg	SHORT $L78791
	push	376					; 00000178H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78791
	int	3
$L78791:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L78788

; 377  : 		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nNewSize$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pNewData$78782[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	?ConstructElements@@YGXPAUPROTOCOL@@H@Z	; ConstructElements

; 378  : 
; 379  : 		// get rid of old stuff (note: no destructors called)
; 380  : 		delete[] (BYTE*)m_pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T80314[ebp], edx
	mov	eax, DWORD PTR $T80314[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 381  : 		m_pData = pNewData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pNewData$78782[ebp]
	mov	DWORD PTR [ecx+4], edx

; 382  : 		m_nSize = nNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 383  : 		m_nMaxSize = nNewMax;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nNewMax$78770[ebp]
	mov	DWORD PTR [edx+12], eax
$L78767:

; 385  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z ENDP	; CArray<PROTOCOL,PROTOCOL &>::SetSize
_TEXT	ENDS
PUBLIC	??0PROTOCOL@@QAE@ABU0@@Z			; PROTOCOL::PROTOCOL
;	COMDAT ?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z
_TEXT	SEGMENT
$T80318 = -4
_nIndex$ = 12
___$ReturnUdt$ = 8
_this$ = -8
?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::GetAt, COMDAT

; 254  : 	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T80318[ebp], 0
$L78803:
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L78807
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L78806
$L78807:
	push	254					; 000000feH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78806
	int	3
$L78806:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78803

; 255  : 		return m_pData[nIndex]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0PROTOCOL@@QAE@ABU0@@Z		; PROTOCOL::PROTOCOL
	mov	ecx, DWORD PTR $T80318[ebp]
	or	ecx, 1
	mov	DWORD PTR $T80318[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAt@?$CArray@UPROTOCOL@@AAU1@@@QBE?AUPROTOCOL@@H@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::GetAt
_TEXT	ENDS
;	COMDAT ?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8
_this$ = -4
?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::ElementAt, COMDAT

; 262  : 	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L78812:
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L78816
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L78815
$L78816:
	push	262					; 00000106H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78815
	int	3
$L78815:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78812

; 263  : 		return m_pData[nIndex]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
?ElementAt@?$CArray@UPROTOCOL@@AAU1@@@QAEAAUPROTOCOL@@H@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::ElementAt
_TEXT	ENDS
PUBLIC	??4PROTOCOL@@QAEAAU0@ABU0@@Z			; PROTOCOL::operator=
;	COMDAT ?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z
_TEXT	SEGMENT
_nIndex$ = 8
_newElement$ = 12
_this$ = -4
?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z PROC NEAR ; CArray<PROTOCOL,PROTOCOL &>::SetAtGrow, COMDAT

; 437  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 	ASSERT_VALID(this);

	push	438					; 000001b6H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78822:

; 439  : 	ASSERT(nIndex >= 0);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jge	SHORT $L78825
	push	439					; 000001b7H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78825
	int	3
$L78825:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L78822

; 440  : 
; 441  : 	if (nIndex >= m_nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nIndex$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jl	SHORT $L78826

; 442  : 		SetSize(nIndex+1, -1);

	push	-1
	mov	ecx, DWORD PTR _nIndex$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CArray@UPROTOCOL@@AAU1@@@QAEXHH@Z ; CArray<PROTOCOL,PROTOCOL &>::SetSize
$L78826:

; 443  : 	m_pData[nIndex] = newElement;

	mov	edx, DWORD PTR _newElement$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8]
	call	??4PROTOCOL@@QAEAAU0@ABU0@@Z		; PROTOCOL::operator=

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAtGrow@?$CArray@UPROTOCOL@@AAU1@@@QAEXHAAUPROTOCOL@@@Z ENDP ; CArray<PROTOCOL,PROTOCOL &>::SetAtGrow
_TEXT	ENDS
PUBLIC	??_GPROTOCOL@@QAEPAXI@Z				; PROTOCOL::`scalar deleting destructor'
;	COMDAT ?DestructElements@@YGXPAUPROTOCOL@@H@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
?DestructElements@@YGXPAUPROTOCOL@@H@Z PROC NEAR	; DestructElements, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78828:

; 68   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78832
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78832
	push	69					; 00000045H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78832
	int	3
$L78832:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78828

; 69   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 70   : 
; 71   : 	// call the destructor(s)
; 72   : 	for (; nCount--; pElements++)

	jmp	SHORT $L78833
$L78834:
	mov	eax, DWORD PTR _pElements$[ebp]
	add	eax, 8
	mov	DWORD PTR _pElements$[ebp], eax
$L78833:
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L78835

; 73   : 		pElements->~TYPE();

	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	call	??_GPROTOCOL@@QAEPAXI@Z			; PROTOCOL::`scalar deleting destructor'
	jmp	SHORT $L78834
$L78835:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?DestructElements@@YGXPAUPROTOCOL@@H@Z ENDP		; DestructElements
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z
_TEXT	SEGMENT
_ar$ = 8
_pElements$ = 12
_nCount$ = 16
?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z PROC NEAR ; SerializeElements, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78837:

; 92   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78841
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78841
	push	93					; 0000005dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78841
	int	3
$L78841:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78837

; 93   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 94   : 
; 95   : 	// default is bit-wise read/write
; 96   : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L78842

; 97   : 		ar.Write((void*)pElements, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Write@CArchive@@QAEXPBXI@Z		; CArchive::Write

; 98   : 	else

	jmp	SHORT $L78845
$L78842:

; 99   : 		ar.Read((void*)pElements, nCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nCount$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Read@CArchive@@QAEIPAXI@Z		; CArchive::Read
$L78845:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?SerializeElements@@YGXAAVCArchive@@PAUPROTOCOL@@H@Z ENDP ; SerializeElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78849:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78853
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78853
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78853
	int	3
$L78853:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78849

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBUPROTOCOL@@H@Z ENDP ; DumpElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z PROC NEAR ; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L78945:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L78949
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L78949
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78949
	int	3
$L78949:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78945

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBVCString@@H@Z ENDP	; DumpElements
_TEXT	ENDS
PUBLIC	?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z ; CMap<CString,unsigned short const *,int,int &>::InitHashTable
PUBLIC	?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ ; CMap<CString,unsigned short const *,int,int &>::NewAssoc
EXTRN	??4CString@@QAEABV0@PBG@Z:NEAR			; CString::operator=
;	COMDAT ??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z
_TEXT	SEGMENT
_key$ = 8
_this$ = -12
_nHash$ = -8
_pAssoc$ = -4
??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::operator[], COMDAT

; 1355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1356 : 	ASSERT_VALID(this);

	push	1356					; 0000054cH
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1357 : 
; 1358 : 	UINT nHash;
; 1359 : 	CAssoc* pAssoc;
; 1360 : 	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)

	lea	ecx, DWORD PTR _nHash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z ; CMap<CString,unsigned short const *,int,int &>::GetAssocAt
	mov	DWORD PTR _pAssoc$[ebp], eax
	cmp	DWORD PTR _pAssoc$[ebp], 0
	jne	SHORT $L78956

; 1362 : 		if (m_pHashTable == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L78957

; 1363 : 			InitHashTable(m_nHashTableSize);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z ; CMap<CString,unsigned short const *,int,int &>::InitHashTable
$L78957:

; 1364 : 
; 1365 : 		// it doesn't exist, add a new Association
; 1366 : 		pAssoc = NewAssoc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ ; CMap<CString,unsigned short const *,int,int &>::NewAssoc
	mov	DWORD PTR _pAssoc$[ebp], eax

; 1367 : 		pAssoc->nHashValue = nHash;

	mov	eax, DWORD PTR _pAssoc$[ebp]
	mov	ecx, DWORD PTR _nHash$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1368 : 		pAssoc->key = key;

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	add	ecx, 8
	call	??4CString@@QAEABV0@PBG@Z		; CString::operator=

; 1369 : 		// 'pAssoc->value' is a constructed object, nothing more
; 1370 : 
; 1371 : 		// put into hash table
; 1372 : 		pAssoc->pNext = m_pHashTable[nHash];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	eax, DWORD PTR _nHash$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], ecx

; 1373 : 		m_pHashTable[nHash] = pAssoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nHash$[ebp]
	mov	edx, DWORD PTR _pAssoc$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
$L78956:

; 1375 : 	return pAssoc->value;  // return new reference

	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH

; 1376 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CMap@VCString@@PBGHAAH@@QAEAAHPBG@Z ENDP		; CMap<CString,unsigned short const *,int,int &>::operator[]
_TEXT	ENDS
PUBLIC	?DestructElements@@YGXPAHH@Z			; DestructElements
EXTRN	?FreeDataChain@CPlex@@QAEXXZ:NEAR		; CPlex::FreeDataChain
EXTRN	?DestructElements@@YGXPAVCString@@H@Z:NEAR	; DestructElements
;	COMDAT ?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16
_nHash$78962 = -4
_pAssoc$78966 = -8
$T80336 = -12
?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ PROC NEAR	; CMap<CString,unsigned short const *,int,int &>::RemoveAll, COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1241 : 	ASSERT_VALID(this);

	push	1241					; 000004d9H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 1242 : 
; 1243 : 	if (m_pHashTable != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L78965

; 1245 : 		// destroy elements (values and keys)
; 1246 : 		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)

	mov	DWORD PTR _nHash$78962[ebp], 0
	jmp	SHORT $L78963
$L78964:
	mov	edx, DWORD PTR _nHash$78962[ebp]
	add	edx, 1
	mov	DWORD PTR _nHash$78962[ebp], edx
$L78963:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nHash$78962[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $L78965

; 1248 : 			CAssoc* pAssoc;
; 1249 : 			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nHash$78962[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pAssoc$78966[ebp], edx

; 1250 : 			  pAssoc = pAssoc->pNext)

	jmp	SHORT $L78967
$L78968:
	mov	eax, DWORD PTR _pAssoc$78966[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAssoc$78966[ebp], ecx
$L78967:
	cmp	DWORD PTR _pAssoc$78966[ebp], 0
	je	SHORT $L78969

; 1252 : 				DestructElements<VALUE>(&pAssoc->value, 1);

	push	1
	mov	edx, DWORD PTR _pAssoc$78966[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	?DestructElements@@YGXPAHH@Z		; DestructElements

; 1253 : 				DestructElements<KEY>(&pAssoc->key, 1);

	push	1
	mov	eax, DWORD PTR _pAssoc$78966[ebp]
	add	eax, 8
	push	eax
	call	?DestructElements@@YGXPAVCString@@H@Z	; DestructElements

; 1254 : 			}

	jmp	SHORT $L78968
$L78969:

; 1255 : 		}

	jmp	SHORT $L78964
$L78965:

; 1257 : 
; 1258 : 	// free hash table
; 1259 : 	delete[] m_pHashTable;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T80336[ebp], edx
	mov	eax, DWORD PTR $T80336[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1260 : 	m_pHashTable = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1261 : 
; 1262 : 	m_nCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1263 : 	m_pFreeList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1264 : 	m_pBlocks->FreeDataChain();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?FreeDataChain@CPlex@@QAEXXZ		; CPlex::FreeDataChain

; 1265 : 	m_pBlocks = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1266 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CMap@VCString@@PBGHAAH@@QAEXXZ ENDP	; CMap<CString,unsigned short const *,int,int &>::RemoveAll
_TEXT	ENDS
;	COMDAT ?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::GetStartPosition, COMDAT

; 1191 : 	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	neg	eax
	sbb	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStartPosition@?$CMap@VCString@@PBGHAAH@@QBEPAU__POSITION@@XZ ENDP ; CMap<CString,unsigned short const *,int,int &>::GetStartPosition
_TEXT	ENDS
;	COMDAT ?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z
_TEXT	SEGMENT
_rNextPosition$ = 8
_rKey$ = 12
_rValue$ = 16
_this$ = -20
_pAssocRet$ = -4
_nBucket$79003 = -12
_pAssocNext$ = -8
_nBucket$79019 = -16
?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::GetNextAssoc, COMDAT

; 1408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 	ASSERT_VALID(this);

	push	1409					; 00000581H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L78990:

; 1410 : 	ASSERT(m_pHashTable != NULL);  // never call on empty map

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L78993
	push	1410					; 00000582H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78993
	int	3
$L78993:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78990

; 1411 : 
; 1412 : 	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	mov	eax, DWORD PTR _rNextPosition$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAssocRet$[ebp], ecx
$L78996:

; 1413 : 	ASSERT(pAssocRet != NULL);

	cmp	DWORD PTR _pAssocRet$[ebp], 0
	jne	SHORT $L78999
	push	1413					; 00000585H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L78999
	int	3
$L78999:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L78996

; 1414 : 
; 1415 : 	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)

	cmp	DWORD PTR _pAssocRet$[ebp], -1
	jne	SHORT $L79010

; 1417 : 		// find the first association
; 1418 : 		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)

	mov	DWORD PTR _nBucket$79003[ebp], 0
	jmp	SHORT $L79004
$L79005:
	mov	eax, DWORD PTR _nBucket$79003[ebp]
	add	eax, 1
	mov	DWORD PTR _nBucket$79003[ebp], eax
$L79004:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nBucket$79003[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $L79006

; 1419 : 			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nBucket$79003[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pAssocRet$[ebp], eax
	cmp	DWORD PTR _pAssocRet$[ebp], 0
	je	SHORT $L79007

; 1420 : 				break;

	jmp	SHORT $L79006
$L79007:

; 1421 : 		ASSERT(pAssocRet != NULL);  // must find something

	jmp	SHORT $L79005
$L79006:
	cmp	DWORD PTR _pAssocRet$[ebp], 0
	jne	SHORT $L79011
	push	1421					; 0000058dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79011
	int	3
$L79011:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L79006
$L79010:

; 1423 : 
; 1424 : 	// find next association
; 1425 : 	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));

	push	1
	push	16					; 00000010H
	mov	edx, DWORD PTR _pAssocRet$[ebp]
	push	edx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79016
	push	1425					; 00000591H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79016
	int	3
$L79016:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L79010

; 1426 : 	CAssoc* pAssocNext;
; 1427 : 	if ((pAssocNext = pAssocRet->pNext) == NULL)

	mov	ecx, DWORD PTR _pAssocRet$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pAssocNext$[ebp], edx
	cmp	DWORD PTR _pAssocNext$[ebp], 0
	jne	SHORT $L79022

; 1429 : 		// go to next bucket
; 1430 : 		for (UINT nBucket = pAssocRet->nHashValue + 1;

	mov	eax, DWORD PTR _pAssocRet$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _nBucket$79019[ebp], ecx

; 1431 : 		  nBucket < m_nHashTableSize; nBucket++)

	jmp	SHORT $L79020
$L79021:
	mov	edx, DWORD PTR _nBucket$79019[ebp]
	add	edx, 1
	mov	DWORD PTR _nBucket$79019[ebp], edx
$L79020:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nBucket$79019[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $L79022

; 1432 : 			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nBucket$79019[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pAssocNext$[ebp], edx
	cmp	DWORD PTR _pAssocNext$[ebp], 0
	je	SHORT $L79023

; 1433 : 				break;

	jmp	SHORT $L79022
$L79023:

; 1434 : 	}

	jmp	SHORT $L79021
$L79022:

; 1435 : 
; 1436 : 	rNextPosition = (POSITION) pAssocNext;

	mov	eax, DWORD PTR _rNextPosition$[ebp]
	mov	ecx, DWORD PTR _pAssocNext$[ebp]
	mov	DWORD PTR [eax], ecx

; 1437 : 
; 1438 : 	// fill in return data
; 1439 : 	rKey = pAssocRet->key;

	mov	edx, DWORD PTR _pAssocRet$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _rKey$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=

; 1440 : 	rValue = pAssocRet->value;

	mov	eax, DWORD PTR _rValue$[ebp]
	mov	ecx, DWORD PTR _pAssocRet$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 1441 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNextAssoc@?$CMap@VCString@@PBGHAAH@@QBEXAAPAU__POSITION@@AAVCString@@AAH@Z ENDP ; CMap<CString,unsigned short const *,int,int &>::GetNextAssoc
_TEXT	ENDS
PUBLIC	?CompareElements@@YGHPBVCString@@PBQBG@Z	; CompareElements
EXTRN	?HashKey@@YGIPBG@Z:NEAR				; HashKey
;	COMDAT ?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z
_TEXT	SEGMENT
_key$ = 8
_nHash$ = 12
_this$ = -8
_pAssoc$ = -4
?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::GetAssocAt, COMDAT

; 1323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1324 : 	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	?HashKey@@YGIPBG@Z			; HashKey
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _nHash$[ebp]
	mov	DWORD PTR [eax], edx

; 1325 : 
; 1326 : 	if (m_pHashTable == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L79033

; 1327 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L79029
$L79033:

; 1331 : 	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)

	mov	edx, DWORD PTR _nHash$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pAssoc$[ebp], eax
	jmp	SHORT $L79035
$L79036:
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pAssoc$[ebp], edx
$L79035:
	cmp	DWORD PTR _pAssoc$[ebp], 0
	je	SHORT $L79037

; 1333 : 		if (CompareElements(&pAssoc->key, &key))

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAssoc$[ebp]
	add	ecx, 8
	push	ecx
	call	?CompareElements@@YGHPBVCString@@PBQBG@Z ; CompareElements
	test	eax, eax
	je	SHORT $L79044

; 1334 : 			return pAssoc;

	mov	eax, DWORD PTR _pAssoc$[ebp]
	jmp	SHORT $L79029
$L79044:

; 1335 : 	}

	jmp	SHORT $L79036
$L79037:

; 1336 : 	return NULL;

	xor	eax, eax
$L79029:

; 1337 : }

	add	esp, 8
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAssocAt@?$CMap@VCString@@PBGHAAH@@IBEPAUCAssoc@1@PBGAAI@Z ENDP ; CMap<CString,unsigned short const *,int,int &>::GetAssocAt
_TEXT	ENDS
;	COMDAT ?SerializeElements@@YGXAAVCArchive@@PAHH@Z
_TEXT	SEGMENT
_ar$ = 8
_pElements$ = 12
_nCount$ = 16
?SerializeElements@@YGXAAVCArchive@@PAHH@Z PROC NEAR	; SerializeElements, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L79046:

; 92   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L79050
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79050
	push	93					; 0000005dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79050
	int	3
$L79050:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79046

; 93   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 94   : 
; 95   : 	// default is bit-wise read/write
; 96   : 	if (ar.IsStoring())

	mov	ecx, DWORD PTR _ar$[ebp]
	call	?IsStoring@CArchive@@QBEHXZ		; CArchive::IsStoring
	test	eax, eax
	je	SHORT $L79051

; 97   : 		ar.Write((void*)pElements, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Write@CArchive@@QAEXPBXI@Z		; CArchive::Write

; 98   : 	else

	jmp	SHORT $L79054
$L79051:

; 99   : 		ar.Read((void*)pElements, nCount * sizeof(TYPE));

	mov	edx, DWORD PTR _nCount$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	?Read@CArchive@@QAEIPAXI@Z		; CArchive::Read
$L79054:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?SerializeElements@@YGXAAVCArchive@@PAHH@Z ENDP		; SerializeElements
_TEXT	ENDS
;	COMDAT ?DumpElements@@YGXAAVCDumpContext@@PBHH@Z
_TEXT	SEGMENT
_pElements$ = 12
_nCount$ = 16
?DumpElements@@YGXAAVCDumpContext@@PBHH@Z PROC NEAR	; DumpElements, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L79058:

; 106  : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L79062
	push	0
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79062
	push	107					; 0000006bH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79062
	int	3
$L79062:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79058

; 107  : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE), FALSE));
; 108  : 	&dc; // not used
; 109  : 	pElements;  // not used
; 110  : 	nCount; // not used
; 111  : 
; 112  : 	// default does nothing
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	12					; 0000000cH
?DumpElements@@YGXAAVCDumpContext@@PBHH@Z ENDP		; DumpElements
_TEXT	ENDS
;	COMDAT ??0URLITEM@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0URLITEM@@QAE@ABU0@@Z PROC NEAR			; URLITEM::URLITEM, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??0URLITEM@@QAE@ABU0@@Z ENDP				; URLITEM::URLITEM
_TEXT	ENDS
;	COMDAT ??_GURLITEM@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GURLITEM@@QAEPAXI@Z PROC NEAR			; URLITEM::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1URLITEM@@QAE@XZ			; URLITEM::~URLITEM
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L79167
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L79167:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GURLITEM@@QAEPAXI@Z ENDP				; URLITEM::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??0PROTOCOL@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0PROTOCOL@@QAE@ABU0@@Z PROC NEAR			; PROTOCOL::PROTOCOL, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CString@@QAE@ABV0@@Z			; CString::CString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??0PROTOCOL@@QAE@ABU0@@Z ENDP				; PROTOCOL::PROTOCOL
_TEXT	ENDS
;	COMDAT ??4PROTOCOL@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4PROTOCOL@@QAEAAU0@ABU0@@Z PROC NEAR			; PROTOCOL::operator=, COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4CString@@QAEABV0@ABV0@@Z		; CString::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??4PROTOCOL@@QAEAAU0@ABU0@@Z ENDP			; PROTOCOL::operator=
_TEXT	ENDS
;	COMDAT ??_GPROTOCOL@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GPROTOCOL@@QAEPAXI@Z PROC NEAR			; PROTOCOL::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PROTOCOL@@QAE@XZ			; PROTOCOL::~PROTOCOL
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L79174
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L79174:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPROTOCOL@@QAEPAXI@Z ENDP				; PROTOCOL::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File C:\Program Files (x86)\Microsoft Visual Studio\VC98\MFC\INCLUDE\afxtempl.h
xdata$x	SEGMENT
$T80367	DD	019930520H
	DD	01H
	DD	FLAT:$T80369
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T80369	DD	0ffffffffH
	DD	FLAT:$L80365
xdata$x	ENDS
;	COMDAT ?ConstructElements@@YGXPAUPROTOCOL@@H@Z
_TEXT	SEGMENT
$T80361 = -16
$T80362 = -20
__$EHRec$ = -12
_pElements$ = 8
_nCount$ = 12
?ConstructElements@@YGXPAUPROTOCOL@@H@Z PROC NEAR	; ConstructElements, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L80368
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
$L79176:

; 54   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L79180
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79180
	push	55					; 00000037H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79180
	int	3
$L79180:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79176

; 55   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 56   : 
; 57   : 	// first do bit-wise zero initialization
; 58   : 	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	// then call the constructor(s)
; 61   : 	for (; nCount--; pElements++)

	jmp	SHORT $L79183
$L79184:
	mov	edx, DWORD PTR _pElements$[ebp]
	add	edx, 8
	mov	DWORD PTR _pElements$[ebp], edx
$L79183:
	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L79185

; 62   : 		::new((void*)pElements) TYPE;

	mov	edx, DWORD PTR _pElements$[ebp]
	push	edx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T80362[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T80362[ebp], 0
	je	SHORT $L80363
	push	0
	push	0
	mov	ecx, DWORD PTR $T80362[ebp]
	call	??0PROTOCOL@@QAE@PBGH@Z			; PROTOCOL::PROTOCOL
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L80364
$L80363:
	mov	DWORD PTR -24+[ebp], 0
$L80364:
	mov	eax, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T80361[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $L79184
$L79185:

; 63   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L80365:
	mov	eax, DWORD PTR _pElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T80362[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
$L80368:
	mov	eax, OFFSET FLAT:$T80367
	jmp	___CxxFrameHandler
text$x	ENDS
?ConstructElements@@YGXPAUPROTOCOL@@H@Z ENDP		; ConstructElements
;	COMDAT ?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z
_TEXT	SEGMENT
_nHashSize$ = 8
_bAllocNow$ = 12
_this$ = -12
$T80374 = -4
$T80375 = -8
?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::InitHashTable, COMDAT

; 1218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1219 : 	ASSERT_VALID(this);

	push	1219					; 000004c3H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject
$L79214:

; 1220 : 	ASSERT(m_nCount == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L79217
	push	1220					; 000004c4H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79217
	int	3
$L79217:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79214
$L79216:

; 1221 : 	ASSERT(nHashSize > 0);

	cmp	DWORD PTR _nHashSize$[ebp], 0
	ja	SHORT $L79221
	push	1221					; 000004c5H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79221
	int	3
$L79221:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L79216

; 1222 : 
; 1223 : 	if (m_pHashTable != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L79222

; 1225 : 		// free hash table
; 1226 : 		delete[] m_pHashTable;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T80374[ebp], eax
	mov	ecx, DWORD PTR $T80374[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1227 : 		m_pHashTable = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L79222:

; 1229 : 
; 1230 : 	if (bAllocNow)

	cmp	DWORD PTR _bAllocNow$[ebp], 0
	je	SHORT $L79224

; 1232 : 		m_pHashTable = new CAssoc* [nHashSize];

	push	1232					; 000004d0H
	push	OFFSET FLAT:__szAfxTempl
	mov	eax, DWORD PTR _nHashSize$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXIPBDH@Z			; operator new
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T80375[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T80375[ebp]
	mov	DWORD PTR [ecx+4], edx

; 1233 : 		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);

	mov	eax, DWORD PTR _nHashSize$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$L79224:

; 1235 : 	m_nHashTableSize = nHashSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nHashSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1236 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?InitHashTable@?$CMap@VCString@@PBGHAAH@@QAEXIH@Z ENDP	; CMap<CString,unsigned short const *,int,int &>::InitHashTable
_TEXT	ENDS
PUBLIC	?ConstructElements@@YGXPAHH@Z			; ConstructElements
PUBLIC	?data@CPlex@@QAEPAXXZ				; CPlex::data
EXTRN	?ConstructElements@@YGXPAVCString@@H@Z:NEAR	; ConstructElements
EXTRN	?Create@CPlex@@SGPAU1@AAPAU1@II@Z:NEAR		; CPlex::Create
;	COMDAT ?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ
_TEXT	SEGMENT
_this$ = -20
_newBlock$79232 = -8
_pAssoc$79234 = -16
_i$79236 = -12
_pAssoc$ = -4
?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ PROC NEAR ; CMap<CString,unsigned short const *,int,int &>::NewAssoc, COMDAT

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1279 : 	if (m_pFreeList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L79239

; 1281 : 		// add another block
; 1282 : 		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?Create@CPlex@@SGPAU1@AAPAU1@II@Z	; CPlex::Create
	mov	DWORD PTR _newBlock$79232[ebp], eax

; 1283 : 		// chain them into free list
; 1284 : 		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();

	mov	ecx, DWORD PTR _newBlock$79232[ebp]
	call	?data@CPlex@@QAEPAXXZ			; CPlex::data
	mov	DWORD PTR _pAssoc$79234[ebp], eax

; 1285 : 		// free in reverse order to make it easier to debug
; 1286 : 		pAssoc += m_nBlockSize - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _pAssoc$79234[ebp]
	add	eax, edx
	mov	DWORD PTR _pAssoc$79234[ebp], eax

; 1287 : 		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, 1
	mov	DWORD PTR _i$79236[ebp], edx
	jmp	SHORT $L79237
$L79238:
	mov	eax, DWORD PTR _i$79236[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$79236[ebp], eax
	mov	ecx, DWORD PTR _pAssoc$79234[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR _pAssoc$79234[ebp], ecx
$L79237:
	cmp	DWORD PTR _i$79236[ebp], 0
	jl	SHORT $L79239

; 1289 : 			pAssoc->pNext = m_pFreeList;

	mov	edx, DWORD PTR _pAssoc$79234[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx], ecx

; 1290 : 			m_pFreeList = pAssoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pAssoc$79234[ebp]
	mov	DWORD PTR [edx+16], eax

; 1291 : 		}

	jmp	SHORT $L79238
$L79239:

; 1293 : 	ASSERT(m_pFreeList != NULL);  // we must have something

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L79243
	push	1293					; 0000050dH
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79243
	int	3
$L79243:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79239

; 1294 : 
; 1295 : 	CMap::CAssoc* pAssoc = m_pFreeList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pAssoc$[ebp], ecx

; 1296 : 	m_pFreeList = m_pFreeList->pNext;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+16], edx

; 1297 : 	m_nCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$L79245:

; 1298 : 	ASSERT(m_nCount > 0);  // make sure we don't overflow

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jg	SHORT $L79248
	push	1298					; 00000512H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79248
	int	3
$L79248:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L79245

; 1299 : 	ConstructElements<KEY>(&pAssoc->key, 1);

	push	1
	mov	edx, DWORD PTR _pAssoc$[ebp]
	add	edx, 8
	push	edx
	call	?ConstructElements@@YGXPAVCString@@H@Z	; ConstructElements

; 1300 : 	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values

	push	1
	mov	eax, DWORD PTR _pAssoc$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	?ConstructElements@@YGXPAHH@Z		; ConstructElements

; 1301 : 	return pAssoc;

	mov	eax, DWORD PTR _pAssoc$[ebp]

; 1302 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	0
?NewAssoc@?$CMap@VCString@@PBGHAAH@@IAEPAUCAssoc@1@XZ ENDP ; CMap<CString,unsigned short const *,int,int &>::NewAssoc
_TEXT	ENDS
;	COMDAT ?data@CPlex@@QAEPAXXZ
text$AFX_COL1	SEGMENT
_this$ = -4
?data@CPlex@@QAEPAXXZ PROC NEAR				; CPlex::data, COMDAT

; 34   : 	void* data() { return this+1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?data@CPlex@@QAEPAXXZ ENDP				; CPlex::data
text$AFX_COL1	ENDS
;	COMDAT ?DestructElements@@YGXPAHH@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
?DestructElements@@YGXPAHH@Z PROC NEAR			; DestructElements, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L79259:

; 68   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L79263
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79263
	push	69					; 00000045H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79263
	int	3
$L79263:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79259

; 69   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 70   : 
; 71   : 	// call the destructor(s)
; 72   : 	for (; nCount--; pElements++)

	jmp	SHORT $L79264
$L79265:
	mov	eax, DWORD PTR _pElements$[ebp]
	add	eax, 4
	mov	DWORD PTR _pElements$[ebp], eax
$L79264:
	mov	ecx, DWORD PTR _nCount$[ebp]
	mov	edx, DWORD PTR _nCount$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nCount$[ebp], edx
	test	ecx, ecx
	je	SHORT $L79266

; 73   : 		pElements->~TYPE();

	jmp	SHORT $L79265
$L79266:

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?DestructElements@@YGXPAHH@Z ENDP			; DestructElements
_TEXT	ENDS
EXTRN	??8@YG_NABVCString@@PBG@Z:NEAR			; operator==
;	COMDAT ?CompareElements@@YGHPBVCString@@PBQBG@Z
_TEXT	SEGMENT
_pElement1$ = 8
_pElement2$ = 12
?CompareElements@@YGHPBVCString@@PBQBG@Z PROC NEAR	; CompareElements, COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
$L79268:

; 119  : 	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));

	push	0
	push	4
	mov	eax, DWORD PTR _pElement1$[ebp]
	push	eax
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79272
	push	119					; 00000077H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79272
	int	3
$L79272:
	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L79268
$L79270:

; 120  : 	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	push	0
	push	4
	mov	edx, DWORD PTR _pElement2$[ebp]
	push	edx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79277
	push	120					; 00000078H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79277
	int	3
$L79277:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $L79270

; 121  : 
; 122  : 	return *pElement1 == *pElement2;

	mov	ecx, DWORD PTR _pElement2$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pElement1$[ebp]
	push	eax
	call	??8@YG_NABVCString@@PBG@Z		; operator==
	and	eax, 255				; 000000ffH

; 123  : }

	pop	edi
	pop	esi
	pop	ebx
	cmp	ebp, esp
	call	__chkesp
	pop	ebp
	ret	8
?CompareElements@@YGHPBVCString@@PBQBG@Z ENDP		; CompareElements
_TEXT	ENDS
;	COMDAT ?ConstructElements@@YGXPAHH@Z
_TEXT	SEGMENT
_pElements$ = 8
_nCount$ = 12
$T80386 = -4
?ConstructElements@@YGXPAHH@Z PROC NEAR			; ConstructElements, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
$L79412:

; 54   : 	ASSERT(nCount == 0 ||

	cmp	DWORD PTR _nCount$[ebp], 0
	je	SHORT $L79416
	push	1
	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	?AfxIsValidAddress@@YGHPBXIH@Z		; AfxIsValidAddress
	test	eax, eax
	jne	SHORT $L79416
	push	55					; 00000037H
	push	OFFSET FLAT:__szAfxTempl
	call	?AfxAssertFailedLine@@YGHPBDH@Z		; AfxAssertFailedLine
	test	eax, eax
	je	SHORT $L79416
	int	3
$L79416:
	xor	edx, edx
	test	edx, edx
	jne	SHORT $L79412

; 55   : 		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));
; 56   : 
; 57   : 	// first do bit-wise zero initialization
; 58   : 	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	mov	eax, DWORD PTR _nCount$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _pElements$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	// then call the constructor(s)
; 61   : 	for (; nCount--; pElements++)

	jmp	SHORT $L79419
$L79420:
	mov	edx, DWORD PTR _pElements$[ebp]
	add	edx, 4
	mov	DWORD PTR _pElements$[ebp], edx
$L79419:
	mov	eax, DWORD PTR _nCount$[ebp]
	mov	ecx, DWORD PTR _nCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nCount$[ebp], ecx
	test	eax, eax
	je	SHORT $L79421

; 62   : 		::new((void*)pElements) TYPE;

	mov	edx, DWORD PTR _pElements$[ebp]
	push	edx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T80386[ebp], eax
	jmp	SHORT $L79420
$L79421:

; 63   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 4
	cmp	ebp, esp
	call	__chkesp
	mov	esp, ebp
	pop	ebp
	ret	8
?ConstructElements@@YGXPAHH@Z ENDP			; ConstructElements
_TEXT	ENDS
END
